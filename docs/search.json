[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introdução à Ciência de Dados em R",
    "section": "",
    "text": "Prefácio\nA ciência de dados se tornou uma área essencial para a análise e tomada de decisões baseadas em informações. Neste material, nosso objetivo é compartilhar experiências e técnicas utilizando a linguagem de programação R, uma das ferramentas mais utilizadas para manipulação, visualização e modelagem de dados.\nEste material foi elaborado para atender tanto aqueles que estão dando os primeiros passos na ciência de dados, quanto para aqueles que já possuem algum conhecimento prévio e desejam aprofundar suas habilidades. A proposta é oferecer um aprendizado estruturado e prático, promovendo a autonomia do leitor para que possa avançar em seus estudos e aplicações.\nAo longo dos capítulos, exploraremos desde conceitos fundamentais até técnicas mais elaboradas, sempre com exemplos práticos e direcionados para desafios reais. Esperamos que este material sirva para que você se sinta mais preparado para aplicar a ciência de dados em seus próprios projetos.",
    "crumbs": [
      "Prefácio"
    ]
  },
  {
    "objectID": "ciencia-dados.html",
    "href": "ciencia-dados.html",
    "title": "1  Ciência de dados",
    "section": "",
    "text": "1.1 O que é Ciência de Dados?\nA ciência de dados, como o próprio termo sugere, consiste na extração de informações relevantes por meio da análise de dados, utilizando técnicas e conhecimentos multidisciplinares.\nNos últimos anos, o termo se tornou amplamente difundido em diversos meios, alcançando grande notoriedade devido à proliferação massiva de dados em elevada quantidade, diversidade e velocidade.\nComo resultado, diversos setores reconheceram a necessidade de contar com profissionais qualificados para extrair informações a partir de dados, a fim de auxiliar em seu desenvolvimento.\nApesar da popularização recente, a concepção da ciência de dados remonta ao século passado, seja por figuras notáveis como o matemático e estatístico John W. Tukey, bem como indivíduos atuantes nos campos de negócios e pesquisa. Mesmo sem a intenção explícita de formar uma nova área do conhecimento, estes podem ser considerados os precursores da ciência de dados.\nA concepção recente de ciência de dados abrange pelo menos três grandes áreas do conhecimento, podendo ser descrita por meio de um diagrama de Venn elaborado por Drew Conway e ilustrado na Figura 1.1.\nFigura 1.1: Diagrama de Venn da ciência de dados.\nFonte: Drew Conway, 2010 (Adaptado).\nO diagrama é composto pelo conjunto de habilidades computacionais, conhecimento de matemática e estatística e domínio da área de conhecimento. Assim, as intersecções entre os conjuntos resultam em certas habilidades, descritas da seguinte maneira:\nTendo uma breve noção sobre o que se trata a ciência de dados, vamos explorar as etapas que compõem o seu processo.",
    "crumbs": [
      "Introdução",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Ciência de dados</span>"
    ]
  },
  {
    "objectID": "ciencia-dados.html#o-que-é-ciência-de-dados",
    "href": "ciencia-dados.html#o-que-é-ciência-de-dados",
    "title": "1  Ciência de dados",
    "section": "",
    "text": "Aprendizado de máquinas: do termo em inglês machine learning, consiste na intersecção entre as habilidades computacionais e de matemática e estatística. Utiliza estas bases para entender os modelos utilizados e detectar os padrões que serão replicados a partir dos artifícios da programação, com o intuito de colocar em prática os algoritmos.\nPesquisa tradicional: é a intersecção entre as áreas da matemática e estatística e área de conhecimento. Consiste na aplicação das bases matemáticas e estatísticas para solucionar problemas em uma área de atuação específica, sendo uma prática comum e tradicional no meio da pesquisa, principalmente a acadêmica.\nZona de perigo: a intersecção entre habilidades computacionais e área de conhecimento resulta em uma chamada zona de perigo, pois quem se encontra nesta situação consegue resolver problemas aplicando algoritmos, porém sem as bases teóricas da matemática e estatística para compreender ou averiguar os resultados.\nCiência de dados: a ciência de dados é o resultado da intersecção entre as três áreas - habilidades computacionais, matemática e estatística e área de conhecimento. Na prática, um cientista de dados não precisa ter total domínio destas três áreas. Normalmente, possui especialização em alguma das três, porém sabe aplicá-las para resolver problemas.",
    "crumbs": [
      "Introdução",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Ciência de dados</span>"
    ]
  },
  {
    "objectID": "ciencia-dados.html#etapas-da-ciência-de-dados",
    "href": "ciencia-dados.html#etapas-da-ciência-de-dados",
    "title": "1  Ciência de dados",
    "section": "\n1.2 Etapas da Ciência de Dados",
    "text": "1.2 Etapas da Ciência de Dados\nO fluxograma da Figura 1.2 representa as etapas que compõem o trabalho de um cientista de dados. A seguir, descreveremos brevemente as etapas para termos noção sobre a relevância de cada uma delas.\n\n\n\n\n\n\n\nFigura 1.2: Etapas do trabalho em ciência de dados. O ato de programar abrange todos os processos do fluxograma.\nFonte: R for Data Science, 2023 (Adaptado).\n\n\n\n\n\nImportar (Import): é a importação dos dados para dentro do software (no nosso caso, o R), seja a partir de arquivos ou banco de dados presentes na web ou coletados pelo próprio cientista de dados. Basicamente é a etapa sine qua non da ciência de dados, pois sem dados, não há o que analisar. Trataremos desse assunto no Capítulo 4;\nLimpar/Arrumar (Tidy): limpar ou arrumar os dados significa organizá-los em uma estrutura consistente, que esteja de acordo com a semântica de um conjunto de dados, a fim de evitar problemas ao realizar as análises. No Capítulo 5, veremos como estruturar os dados de maneira desejável, designando cada variável a uma coluna e cada observação a uma linha, semalhante a uma planilha Excel;\nTransformar (Transform): a transformação consiste em selecionar as observações de interesse no banco de dados. Em outras palavras, reduzir o banco de dados para conter somente as informações necessárias para a análise. Também podemos criar novas variáveis em função das variáveis já existentes, além de gerar estatísticas como média, variância e proporções. Esta etapa será abordada no Capítulo 6 que está dividido em outros sete (Capítulos -Capítulo 7, -Capítulo 8, -?sec-numbers, -?sec-lubridate, -?sec-forcats, -?sec-strigr e -?sec-val-ausentes);\nVisualizar (Visualize): a visualização gráfica dos dados permite enxergar as informações com mais clareza, levantar novos questionamentos e até mesmo indicar se a pesquisa está no caminho correto ou não. Veremos mais sobre este assunto nos Capítulo 9, Capítulo 10 e Capítulo 11;\nModelar (Model): os modelos são usados para responder as perguntas norteadoras. Entra em cena a matemática, estatística e a computação como ferramentas para sua realização. Esta etapa não será aborada neste material, pois se tratar de um tema muito abrangente1.\n\n\n\nComunicar (Communicate): é a parte crítica de um projeto analítico (data analysis), pois é necessário expor os resultados de maneira inteligível para o público, seja ele técnico ou leigo. Existem diversas extensões do R que permitem fazer apresentações, relatórios, sites e até mesmo aplicativos dinâmicos. 2\n\n\n\n\nProgramar (Program): a programação abrange todas as etapas citadas anteriormente. Em ciência de dados, não precisamos ter um domínio avançado para começarmos um projeto, porém quanto mais se sabe, mais automático ficam as tarefas comuns e mais facilmente se resolve novos problemas. Dessa forma, o Capítulo 3 trará os principais conceitos para começarmos a programar em R.\n\nAinda, podemos destacar o termo Wrangling, que abrange as etapas de Limpar/Arrumar e Transformar. Traduzindo o termo, podemos entender que essas etapas são, literalmente, uma luta para que se consiga deixar os dados de forma mais concisa para serem analisados.\nPor fim, vale destacar que as etapas de Transformar, Visualizar e Modelar são processos iterativos, ou seja, fazem parte de um processo de repetição cíclica de tarefas até que se alcance o resultado final da análise.\nNo capítulo seguinte, apresentaremos o software R e a IDE RStudio, desde a instalação, configuração e os primeiros passos a serem dados. Também vamos conhecer mais sobre o pacote tidyverse, que contém as principais funcionalidades a serem utilizadas em ciência de dados com R, detalhando os pacotes específicos para cada uma das etapas descritas anteriormente.",
    "crumbs": [
      "Introdução",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Ciência de dados</span>"
    ]
  },
  {
    "objectID": "ciencia-dados.html#footnotes",
    "href": "ciencia-dados.html#footnotes",
    "title": "1  Ciência de dados",
    "section": "",
    "text": "Para os interessados no assunto, recomendo o livro Tidy Modeling with R.↩︎\nPara ter uma noção introdutória sobre este tópico, recomendo os capítulos 28 e 29 do livro R for Data Science.↩︎",
    "crumbs": [
      "Introdução",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Ciência de dados</span>"
    ]
  },
  {
    "objectID": "intro-r.html",
    "href": "intro-r.html",
    "title": "2  R / RStudio",
    "section": "",
    "text": "2.1 Conhecendo o R e o RStudio\nO R é uma das linguagens de programação mais utilizadas por cientistas de dados. Foi desenvolvido por Ross Ihaka e Robert Gentleman, na Universidade de Auckland, Nova Zelândia, em 1993. Iniciou como uma linguagem focada em programação estatística, mas que, ao longo do tempo, tornou-se cada vez mais encorpada e diversificada. Atualmente, o R Development Core Team atua na manutenção e no desenvolvimento da linguagem, sendo composto por diversos colaboradores.\nPor ser um software gratuito de código aberto (open source), possibilitou a formação de uma comunidade que atua diretamente em seu desenvolvimento, promovendo constantes facilidades, melhorias e inovações acessíveis ao público em geral. O compartilhamento de um conjunto de funcionalidades é dado através de pacotes, os quais devemos instalar para utilizá-las. Detalharemos a instalação de pacotes na Seção 2.3.\nE, justamente, uma das principais contribuições idealizadas é o RStudio. O RStudio é uma IDE (Integrated Development Environment), ou seja, um ambiente de trabalho que executa o R a partir de uma interface gráfica mais agradável e com diversas funcionalidades (Figura 2.2), o que nos proporciona um maior conforto quando comparado ao R original, composto basicamente pelas janelas de script e console (Figura 2.1).\nFigura 2.1: Tela do R original. Composto apenas pelo script e console.\nFigura 2.2: Tela do RStudio. Como podemos perceber, bem diferente do R original.\nMais adiante, na Seção 2.2, entraremos em mais detalhes sobre o ambiente do RStudio.\nVale salientar que o R pode ser utilizado sem o RStudio, porém o RStudio não funciona sem o R. No nosso caso, utilizaremos o RStudio para desenvolver nossas análises. Assim, precisamos ter instalados ambos os programas.",
    "crumbs": [
      "Introdução",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R / RStudio</span>"
    ]
  },
  {
    "objectID": "intro-r.html#conhecendo-o-r-e-o-rstudio",
    "href": "intro-r.html#conhecendo-o-r-e-o-rstudio",
    "title": "2  R / RStudio",
    "section": "",
    "text": "2.1.1 Instalando o R\nO R está disponível para todos os sistemas operacionais. Sua instalação é feita via CRAN (Comprehensive R Archive Network), ou seja, uma rede com diversos servidores localizados em várias regiões do mundo que armazenam versões idênticas e atualizadas de códigos e documentações para o R. Assim, para instalar o R, recomenda-se selecionar o servidor mais próximo à sua região. A seguir está o passo-a-passo para o download.\n\nAcessar: https://www.r-project.org/;\nNo canto superior esquerdo, clicar em CRAN;\nSelecionar o servidor (mirror) mais próximo a você;\nEm Download and Install R escolha o link referente ao seu sistema operacional;\nSistemas operacionais:\n\n\nWindows: após clicar em ‘Download R for Windows’, selecione a opção ‘base’ e, posteriormente, ‘Download R x.x.x for Windows’, sendo ‘x.x.x’ a versão mais recente a ser baixada;\nLinux: após clicar em ‘Download R for Linux’, selecione a distribuição que você utiliza e siga as instruções da página para instalar o R;\nMacOS: após clicar em ‘Download R for macOS’, selecione a opção mais recente do R, a partir do link ‘R-x.x.x.pkg’, sendo ‘x.x.x’ a versão mais recente a ser baixada;\n\n\nFeito o download, abra o arquivo baixado e siga as instruções para a instalação. Uma vez que utilizaremos o R a partir do RStudio, não há necessidade de criar um ícone de inicialização do R na área de trabalho, portanto, apenas instale o R em seu computador.\n\n2.1.2 Instalando o RStudio\nUma vez feita a instalação do R, precisamos instalar o RStudio. Também está disponível para todos os sistemas operacionais e sua instalação pode ser feita a partir do link: https://posit.co/download/rstudio-desktop/.\nEscolha a versão referente ao seu sistema operacional (Figura 2.3) e siga as instruções para baixar a IDE em seu computador.\n\n\n\n\n\n\n\nFigura 2.3: Na página referente ao link acima, vá até à seção ilustrada. Lá encontraremos as versões disponíveis do RStudio de acordo com o sistema operacional.\n\n\n\n\n\n2.1.3 Atualizando o R e o RStudio\nO R passa por algumas atualizações durante o ano. A maneira mais simples de verificar novas atualizações é pelo mesmo site em que realizamos o seu download. Para atualizar o R, será necessário instalá-lo novamente, realizando o mesmo processo descrito na Seção 2.1.1.\nDe maneira geral, as atualizações visam corrigir falhas e melhorar o desempenho do programa. Contudo, são mudanças ligeiras que não interferem muito no seu uso cotidiano. Assim, recomendo que atualize o R anualmente ou quando notar algum problema que não consiga explicar.\nAssim como o R, o RStudio passa por constantes melhorias. Quando é lançada uma nova atualização, ao inicializar uma nova seção, o RStudio nos informa sobre a sua disponibilidade, como ilustrado na Figura 2.4.\n\n\n\n\n\n\n\nFigura 2.4: A cada nova atualização, o RStudio nos informa sobre sua disponibilidade ao iniciar uma nova seção.\n\n\n\n\nSelecionando a opção Quit and Download…, o RStudio é fechado e será aberto em seu navegador o mesmo site em que realizamos a instalação do RStudio. Para atualizá-lo, devemos instalar novamente o RStudio, realizando o mesmo processo descrito na Seção 2.1.2.\nRecomendo realizar a atualização do RStudio semestralmente ou quando notar algum problema.",
    "crumbs": [
      "Introdução",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R / RStudio</span>"
    ]
  },
  {
    "objectID": "intro-r.html#sec-rstudio",
    "href": "intro-r.html#sec-rstudio",
    "title": "2  R / RStudio",
    "section": "\n2.2 Ambiente RStudio",
    "text": "2.2 Ambiente RStudio\nAgora que temos o R e o RStudio instalados, vamos conhecer mais sobre o ambiente do RStudio.\n\n2.2.1 Janelas\nA Figura 2.5 ilustra as quatro janelas presentes no RStudio, cada qual com suas particularidades e funções. A seguir, apresentaremos as principais funcionalidades de cada janela.\n\n\n\n\n\n\n\nFigura 2.5: O RStudio apresenta 4 janelas principais, algumas com abas específicas, cada qual apresentando funcionalidades particulares.\n\n\n\n\n\nScript: é a janela na qual escreveremos os códigos e comandos, podendo ser editado e salvo. Para abrir um novo script, clicamos no ícone logo abaixo da aba file, no canto superior esquerdo, e em seguida em R Script ou podemos utilizar o atalho Ctrl + Shift + N (Cmd + Shift + N);\nConsole: local onde são apresentadas as saídas e resultados dos códigos e comandos redigidos no script. Também podemos escrever comandos no console, porém, ao contrário do script, não é possível editar ou salvar, sendo necessário reescrevê-los, caso preciso.\nEnvironment: onde se localiza e armazena os objetos criados. O ícone da vassoura exclui os objetos desejados. Esta janela contém outras abas, porém a Environment é a principal.\nFile, Plots, Packages, Help, Viewer: esta janela contém cinco abas.\n\n\nFile: mostra os arquivos presentes no diretório do seu computador;\nPlots: permite a visualização dos gráficos gerados;\nPackages: mostra todos os pacotes instalados em seu RStudio;\nHelp: retorna documentações detalhadas sobre diversas funcionalidades;\nViewer: apresenta os resultados gerados a partir do R Markdown, Bookdown, Quarto, dentre outras extensões relacionadas a execução de relatórios e apresentações.\n\nA princípio, pode parecer complexo o uso das janelas do RStudio, dada às suas variadas possibilidades e funcionalidades. Porém, com o tempo e experiência, cada janela terá sua importância justificada.\n\n2.2.2 Aparência\nPara dar um toque pessoal e melhorar a experiência de uso do RStudio, podemos alterar sua aparência. Para isso, acessamos a aba Tools, presente no menu superior e clicamos em Global Options.... Na aba Appearance, podemos alterar o tema de fundo, regular o zoom do ambiente como um todo ou somente dos textos, além de modificar a fonte dos textos. Na Figura 2.6 está ilustrado um exemplo de configuração da aparência do RStudio e na Figura 2.7, o resultado dessa alteração.\n\n\n\n\n\n\n\nFigura 2.6: Podemos configurar a aparência do RStudio em diversos aspectos. Faça alguns testes e veja qual lhe agrada mais.\n\n\n\n\n\n\n\n\n\n\n\nFigura 2.7: Um exemplo de alteração na aparência do RStudio.\n\n\n\n\nNo mesmo local, também podemos alterar a disposição das janelas e abas em Panel Layout.\n\n\n\n\n\n\n\nFigura 2.8: Em Panel Layout, podemos alterar a disposição das janelas no RStudio, conforme a preferência do usuário.\n\n\n\n\n\n2.2.3 Projetos\nUma funcionalidade importante do RStudio são os projetos. Ao criar um projeto, uma nova pasta é criada em seu computador. Nela, podemos (e devemos) direcionar os arquivos a serem utiilizados para o projeto, além de abrigar os novos arquivos criados para a análise.\nCom isso, a criação de projetos nos proporciona uma melhor organização dos arquivos, separando-os de acordo com o projeto realizado no R. Além disso, facilita a importação de dados para dentro do R, como veremos no Capítulo 4.\nPara criar um projeto, clique em File, presente no menu superior, depois em New Project.... Em seguida, clique em New Directory &gt; New Project e nomeie seu projeto em Directory name. Em Create project as subdirectory of: escolha o diretório em seu computador (pasta) no qual seu novo projeto será alocado. Finalize clicando em Create Project. A Figura 2.9 ilustra o processo.\n\n\n\n\n\n\n\nFigura 2.9: Tela referente à criação de um novo projeto no RStudio.\n\n\n\n\nPronto, seu projeto está criado. No canto superior direito aparecerá o nome do projeto. Além disso, na aba Files, estarão todos os arquivos direcionados para a pasta do projeto, incluindo o arquivo .Rproj, referente ao projeto recém criado. Portanto, direcione todos os arquivos que você utilizará para a respectiva pasta do projeto em uso.\n\n\n\n\n\n\n\nFigura 2.10: No ambiente do RStudio, estará indicado o nome do projeto em funcionamento, além de seus documentos e pastas, indicados na aba file.\n\n\n\n\nClicando no mesmo ícone o qual aparece o nome do projeto, podemos criar um novo, abrir um outro existente ou fechar o projeto em funcionamento. Ao reiniciar o programa, o RStudio é restaurado, automaticamente, a partir do último projeto utilizado. Por tanto, atente-se a qual projeto se encontra ativo.\nPor fim, dentro do diretório do projeto, podemos criar subdiretórios, ou seja, pastas dentro da pasta do projeto. Isso nos ajuda a alocar os arquivos de acordo com sua utilidade. Por exemplo, podemos criar os seguintes subdiretórios:\n\ndados: pasta com os dados a serem analisados;\nR: pasta com os scripts do R;\nnotas: pasta com anotações em arquivos .txt ou .docx.\n\nDessa forma, quanto mais departamentalizado os arquivos, mais organizado e fácil será o seu trabalho.\n\n2.2.4 Executando o primeiro comando\nComo comentado na Seção 2.2.1, podemos executar um comando tanto no script, como no console. No script, os comandos redigidos podem ser salvos e editados, enquanto no console, não. Portanto, no console, recomenda-se executar comandos de teste ou temporários, que não interfiram, diretamente, no raciocínio ou fluxo de uma análise.\nPara rodar um comando no script, utilizamos o atalho do teclado Ctrl + Enter (Cmd + Return). O resultado aparecerá no console. Como exemplo, podemos realizar uma operação matemática simples.\n\n1 + 1\n#&gt; [1] 2\n\nEnquanto isso, no console, inserimos o comando e clicamos em Enter (Return). Novamente, o resultado aparecerá no console.\nVale destacar que, neste material, os resultados de comandos e códigos são apresentados seguidos do operador #&gt;. O valor presente nos colchetes [1] apenas informa a linha em que começa o primeiro valor de seu resultado. Em alguns comandos cujo resultado é mais extenso, pode-se preencher mais de uma linha.\n\n1:30\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n#&gt; [26] 26 27 28 29 30\n\nNo caso anterior, criamos uma sequência de números inteiros de 1 a 30, em que a saída dos resultados ocupam duas linhas. Como sempre, a primeira linha começará no primeiro valor [1] e, neste caso, a segunda linha começa no 26º valor [26].\nPor fim, para salvar os códigos redigidos no script, utilizamos o atalho Ctrl + S (Cmd + S). No caso de um script recém criado, salve e coloque-o no diretório referente ao projeto em uso.\n\n2.2.5 Comentários\nPodemos inserir comentários no script, sem que estes interfiram na execução dos códigos.\nInserir comentários ao longo do script é muito importante para quem está começando, pois possibilita fazer registros para, posteriormente, revisar a utilidade de certas funcionalidades ou realizar alguma manutenção no código. Além disso é muito relevante para que se possa compartilhar um código inteligível com outras pessoas.\nPara inserir um comentário, basta colocar o símbolo # antes da parte comentada.\n\n\n\n\n\n\n\nFigura 2.11: Perceba que os comentários apresentam uma coloração diferenciada e padronizada, o que auxilia a sua identificação no script.\n\n\n\n\nComo visto na Figura 2.11, além de inserir um comentário no início de uma linha, também podemos realizá-lo após um comando, desde que não interfira no fluxo dos códigos.\nNo caso de scripts longos, podemos utilizar comentários seccionados para dividir o arquivo em partes gerenciáveis. Para criá-los, utilizamos o atalho Ctrl + Shift + R (Cmd + Shift + R).\n\n\n\n\n\n\n\nFigura 2.12: Os comentários seccionados facilitam a navegação e organização de scripts longos.\n\n\n\n\nOs comentários seccionados nos fornece um menu de navegação na parte inferior do script, além de permitir recolher uma seção ao clicar na flecha ao lado da linha da respectiva seção, como ilustra a Figura 2.12.\n\n2.2.6 Ajuda\nCada ferramenta presente no R contém uma documentação que explica a sua utilização. Para acessarmos tais documentos, podemos prosseguir das seguintes maneiras:\n\n?mean\n\nhelp(mean)\n\nNeste exemplo, queremos saber mais sobre a função mean, ou seja, a função que calcula a média aritmética. Ao rodar um destes comandos, a documentação referente à função será aberta na aba Help. Nela, são apresentadas algumas descrições importantes, como a noção geral de seu uso, possíveis argumentos e exemplos, como ilustra a Figura 2.13.\n\n\n\n\n\n\n\nFigura 2.13: Com o comando ?mean (ou help(mean)), abre-se uma documentação contendo informações de uso da função ‘mean()’.\n\n\n\n\nAinda, podemos utilizar o atalho F1 do teclado, selecionando uma ferramenta presente no script ou console e clicar em F1.\nOutra via de auxílio são as folhas de cola, ou Cheatsheets. Basicamente, trazem resumos sobre as principais funcionalidades contidas em determinados pacotes. A Figura 2.14 traz um exemplo da folha de cola do RStudio. Podemos acessar outras Cheatsheets em: https://posit.co/resources/cheatsheets/.\n\n\n\n\n\n\n\nFigura 2.14: Cheatsheet do RStudio. Nela podemos verificar, de maneira geral, as principais funcionalidades presentes no ambiente do RStudio.\n\n\n\n\nPor fim, caso ainda tenha dúvidas, não exite em fazer uma busca no Google, encontrar tutoriais explicativos - seja no YouTube ou no próprio site do RStudio -, acessar fóruns de perguntas e respostas - como o Stack Overflow e acessar o Rseek ou o Search R-project, que são buscadores específicos para assuntos relacionados ao R.\nPara mais informações sobre o RStudio, acesse o guia do usuário, disponível em: https://docs.posit.co/ide/user/.",
    "crumbs": [
      "Introdução",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R / RStudio</span>"
    ]
  },
  {
    "objectID": "intro-r.html#sec-pacotes",
    "href": "intro-r.html#sec-pacotes",
    "title": "2  R / RStudio",
    "section": "\n2.3 Pacotes",
    "text": "2.3 Pacotes\nComo citado no início do capítulo, o R apresenta pacotes com funcionalidades específicas que nos auxiliam em diversas tarefas. Alguns pacotes base já vêm pré-instalados juntos ao R, enquanto outros precisamos instalar para poder utilizar suas ferramentas.\n\n2.3.1 Instalação de pacotes\nPara instalar novos pacotes no R utilizamos a função install.packages().\n\ninstall.packages(\"ggplot2\")\n\nAtente-se ao fato que, para a instalação, o nome do pacote deve estar entre aspas. O processo de instalação pode demorar alguns segundos. Portanto, espere até que se complete a instalação.\nVale destacar que a instalação de um pacote precisa ser executado somente uma única vez. Dessa forma, uma vez instalado um determinado pacote, tal função não precisa ser executada novamente a cada nova seção.\nOutra maneira de instalar pacotes é utilizando a aba Packages do RStudio. Para isso, clicamos em Install e colocamos o nome do pacote desejado, como ilustra a Figura 2.15.\n\n\n\n\n\n\n\nFigura 2.15: A aba Packages do RStudio traz um atalho para instalarmos pacotes.\n\n\n\n\nAlém disso, a aba Packages lista todos os pacotes instalados. Portanto, caso precise consultar se um pacote já está instalado em seu computador, utilize este atalho do RStudio.\n\n2.3.2 Carregar pacotes\nUma vez instalado, para que possamos utilizar todas as suas funcionalidades, devemos carregar o pacote com a função library(). Agora, o nome do pacote não precisa estar entre aspas.\n\nlibrary(ggplot2)\n\nAo contrário da função de instalação, a função library() deve ser executada a cada nova seção inicializada no R, de acordo com o pacote que se deseja utilizar.\nTambém temos a possibilidade de usar apenas uma única função de um pacote sem carregá-lo por completo. Para isso, utilizamos o operador :: entre o nome do pacote e o nome da função desejada.\n\nggplot2::ggplot()\n\nAo utilizar esta sintaxe, o código é executado um pouco mais rápido, pois é carregada apenas a função declarada e não todas as funções presentes no respectivo pacote, como acontece quando utilizamos a library().\nAssim, caso você utilize uma única ou poucas funções de um determinado pacote, ou ainda, tenha um script com muitas linhas de código, pode ser interessante utilizar o operador :: ao invés da função library(). Além disso, utilizar o :: permite identificar de qual pacote vem a função e evitar conflitos com funções de mesmo nome, oriundas de pacotes distintos.\n\n2.3.3 Atualização de pacotes\nConforme surgem melhorias e correções, são lançadas novas atualizações de pacotes. Para atualizar um pacote no R, utilizamos a função update.packages().\n\nupdate.packages(\"ggplot2\")\n\nBem como a instalação, podemos utilizar a aba Packages para atualizar os pacotes. Para isso, clicamos em Update e selecionamos os pacotes que desejamos atualizar. A Figura 2.16 ilustra o processo.\n\n\n\n\n\n\n\nFigura 2.16: A aba Packages também nos permite realizar atualizações de pacotes de maneira intuitiva.",
    "crumbs": [
      "Introdução",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R / RStudio</span>"
    ]
  },
  {
    "objectID": "intro-r.html#pacote-tidyverse",
    "href": "intro-r.html#pacote-tidyverse",
    "title": "2  R / RStudio",
    "section": "\n2.4 Pacote tidyverse\n",
    "text": "2.4 Pacote tidyverse\n\nO tidyverse é um “pacote mestre” que abriga diversos outros, cada qual apresentando um conjunto de funcionalidades específicas.\nA Figura 2.17 traz os principais pacotes utilizados em cada uma das etapas que compõem o trabalho em ciência de dados.\n\n\n\n\n\n\n\nFigura 2.17: Para cada etapa do fluxograma de trabalho da ciência de dados, existem pacotes específicos no R.\nFonte: R for Data Science, 2023 (Adaptado).\n\n\n\n\nNesta apostila, focaremos no tidyverse aplicado às etapas de Programar, Importar, Arrumar, Transformar e Visualizar. Apenas os pacotes relacionados às etapas de Modelar e Comunicar não estão presentes no tidyverse.\nAssim sendo, vamos instalar e carregar o pacote tidyverse.\n\ninstall.packages(\"tidyverse\")\n\n\nlibrary(tidyverse)\n\nA função library(tidyverse) nos informa que nove pacotes foram carregados: dplyr, forcats, ggplot2, lubridate, purrr, readr, stringr, tibble e tidyr.\nContudo, o tidyverse também possui outros pacotes. Para se ter uma visão geral de quais estão presentes, utilizamos a função tidyverse_packages().\n\ntidyverse_packages()\n#&gt;  [1] \"broom\"         \"conflicted\"    \"cli\"           \"dbplyr\"       \n#&gt;  [5] \"dplyr\"         \"dtplyr\"        \"forcats\"       \"ggplot2\"      \n#&gt;  [9] \"googledrive\"   \"googlesheets4\" \"haven\"         \"hms\"          \n#&gt; [13] \"httr\"          \"jsonlite\"      \"lubridate\"     \"magrittr\"     \n#&gt; [17] \"modelr\"        \"pillar\"        \"purrr\"         \"ragg\"         \n#&gt; [21] \"readr\"         \"readxl\"        \"reprex\"        \"rlang\"        \n#&gt; [25] \"rstudioapi\"    \"rvest\"         \"stringr\"       \"tibble\"       \n#&gt; [29] \"tidyr\"         \"xml2\"          \"tidyverse\"\n\nDessa forma, caso queira carregar outro pacote do tidyverse que não tenha sido carregado previamente, utilize a função library(). Para carregar mais de um pacote em um único comando library(), coloque-os dentro da função c(), separados por vírgulas.\n\nlibrary(c(modelr, rvest, magrittr))\n\nDentre estes pacotes, utilizaremos o readr e o readxl para importar os dados; o tidyr e o tibble para arrumar; o dplyr, stringr, forcats e lubridate para transformar; e, por último, o ggplot2 para visualizar.\nAo longo do material, utilizaremos alguns outros pacotes que não estão presentes no tidyverse, cuja instalação será realizada em momento oportuno.\nCaso o leitor tenha curiosidade em saber mais detalhes sobre o tidyverse, acesse o link da página oficial do pacote: https://www.tidyverse.org/packages/.\nNos capítulos seguintes, abordaremos as etapas de Importar, Arrumar, Transformar e Visualizar, apresentando as principais utilidades e funções de cada um dos respectivos pacotes presentes no tidyverse. Mas antes, veremos alguns conceitos básicos de programação em R.",
    "crumbs": [
      "Introdução",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R / RStudio</span>"
    ]
  },
  {
    "objectID": "basico.html",
    "href": "basico.html",
    "title": "3  Noções básicas em R",
    "section": "",
    "text": "3.1 Introdução\nPara trabalhar com ciência de dados em R, devemos ter algumas noções básicas de programação nessa linguagem. Os conceitos discutidos neste capítulo serão a base para aplicarmos as demais ferramentas ao longo da apostila.\nFigura 3.1: As noções básicas de programação em R serão o alicerce para aplicarmos ciência de dados nesta linguagem de programação.",
    "crumbs": [
      "Introdução",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Noções básicas em R</span>"
    ]
  },
  {
    "objectID": "basico.html#operações-matemáticas",
    "href": "basico.html#operações-matemáticas",
    "title": "3  Noções básicas em R",
    "section": "\n3.2 Operações matemáticas",
    "text": "3.2 Operações matemáticas\nA Tabela 3.1 lista as principais operações matemáticas presentes no R, seguida de exemplos.\n\n\nTabela 3.1: Operações matemáticas no R.\n\n\n\nOperação\nSímbolo\n\n\n\nAdição\n+\n\n\nSubtração\n-\n\n\nMultiplicação\n*\n\n\nDivisão\n/\n\n\nPotência\n\n^ ou **\n\n\n\nRaiz quadrada\n\n^(1/2) ou sqrt()\n\n\n\nResto da divisão\n%%\n\n\nParte inteira da divisão\n%/%\n\n\n\n\n\n\n\n# Adição\n1 + 1.2\n#&gt; [1] 2.2\n\n\n# Subtração\n2 - 1\n#&gt; [1] 1\n\n\n# Multiplicação\n5 * 5\n#&gt; [1] 25\n\n\n# Divisão\n6 / 4\n#&gt; [1] 1.5\n\n\n# Potência\n2 ^ 3\n#&gt; [1] 8\n2 ** 3\n#&gt; [1] 8\n\n\n# Raiz quadrada\n4 ^ (1/2)\n#&gt; [1] 2\nsqrt(4)\n#&gt; [1] 2\n\n\n# Resto da divisão\n7 %% 3\n#&gt; [1] 1\n\n\n# Parte inteira de uma divisão\n7 %/% 3\n#&gt; [1] 2\n\nAssim como na matemática, o R segue a ordem de precedência de sinais, calculando primeiro a multiplicação e divisão, além dos valores entre parênteses, para, posteriormente, calcular a adição e a subtração.\n\n1 + 2 * 5 - (4 - 2) / 2\n#&gt; [1] 10\n\nOutra informação relevante quando tratamos de números no R é que os decimais são delimitados por ponto (.) e não por vírgula. Essa informação é importante para que possamos escrever números decimais da maneira a qual o R aceita.\n\n# Separador decimal correto\n10.5\n\n# Separador decimal incorreto\n10,5\n#&gt; Error: &lt;text&gt;:5:3: ',' inesperado\n#&gt; 4: # Separador decimal incorreto\n#&gt; 5: 10,\n#&gt;      ^\n\nUma função útil para tratar de números decimais é a round(). Ela arredonda valores de acordo com o número de casas decimais informadas no argumento digits.\n\nround(10.456783452, digits = 1)\n#&gt; [1] 10.5\n\nAbordaremos com mais detalhes as funções na Seção 3.4.",
    "crumbs": [
      "Introdução",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Noções básicas em R</span>"
    ]
  },
  {
    "objectID": "basico.html#sec-objetos",
    "href": "basico.html#sec-objetos",
    "title": "3  Noções básicas em R",
    "section": "\n3.3 Objetos",
    "text": "3.3 Objetos\nObjetos são nomes que recebem e salvam um determinado valor, comando ou código. Para criar um objeto, utilizamos o operador &lt;-, cujo atalho no teclado é Alt + -.\nNo exemplo a seguir, salvaremos o valor 10 dentro do nome a.\n\na &lt;- 10\n\nAo rodar o objeto a, o R retorna o valor 10.\n\na\n#&gt; [1] 10\n\nUma vez que temos o valor 10 salvo no nome a, podemos utilizá-lo da seguinte maneira:\n\na + 4\n#&gt; [1] 14\n\nOu seja, o valor 10, salvo no objeto de nome a, é somado ao valor 4, resultando em 14.\nA janela Enviroment armazena e indica todos os objetos criados. Caso queira excluir um ou mais objetos, selecione-os e clique no ícone da vassoura (Habilite o modo de apresentação Grid, caso o modo List esteja ativado).\n\n\n\n\n\n\n\nFigura 3.2: Um objeto criado estará salvo na janela Environment. Para excluí-lo, selecione-o e clique no ícone da vassoura.\n\n\n\n\nDevemos nos atentar a alguns detalhes ao criarmos um objeto. Primeiramente, o R diferencia letras maiúsculas e minúsculas.\n\na &lt;- 10\na\n#&gt; [1] 10\n\n\nA &lt;- 50\nA\n#&gt; [1] 50\n\nAlém disso, existem nomes de sintaxe inválida, ou seja, não podemos nomear um objeto começando por números, underline (_), ponto (.) e traço (-) ou com espaço entre nomes compostos.\n\n# Nomes não permitidos!\n1objeto &lt;- 1\n_objeto &lt;- 2\n-objeto &lt;- 3\nnomear-objeto &lt;- 4\n.objeto &lt;- 5\nnomear objeto &lt;- 6\n\nContudo, podemos utilizar números, underline e pontos, desde que não estejam no início do nome.\n\n# Permitido\nobjeto1 &lt;- 7\nnomear_objeto &lt;- 25\nnomear.objeto &lt;- 52\n\nTambém não é recomendado nomear objetos com nomes de pacotes e funções já existentes, pois podem gerar conflitos.\n\n# Não dê nomes do tipo:\ntidyverse &lt;- 31\nmean &lt;- \"a\"\n\nPor fim, ao escolher um nome para um objeto, tenha em mente que este deve ser conciso, porém claro quanto ao seu significado.\nNeste primeiro momento, criamos objetos que recebem um único valor. Ao longo da apostila, criaremos objetos mais complexos e diversos, como os vetores, data frames e listas, os quais trataremos ao longo deste capítulo.",
    "crumbs": [
      "Introdução",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Noções básicas em R</span>"
    ]
  },
  {
    "objectID": "basico.html#sec-func",
    "href": "basico.html#sec-func",
    "title": "3  Noções básicas em R",
    "section": "\n3.4 Funções",
    "text": "3.4 Funções\nAs funções são nomes que guardam um código em R. Portanto, cada função apresenta certas ferramentas específicas que nos trazem alguma resposta.\nComo exemplo, utilizaremos a função sum(), que soma os valores indicados.\n\nsum(1, 2, 10)\n#&gt; [1] 13\n\nDentro dos parênteses de uma função estão os argumentos. Estes argumentos são separados por vírgulas e não há um limite de argumentos que uma função pode receber. Por tanto, uma função executa determinado comando, em resposta aos argumentos especificados dentro dela.\nNo exemplo, 1, 2 e 10 são argumentos da função sum(). Portanto, a função sum() realizou a operação de soma dos argumentos especificados dentro dela, retornando o resultado da operação, igual a 13.\nAlguns argumentos de funções possuem nomenclaturas específicas, que podemos ou não explicitar em uma função. Utilizaremos como exemplo a função seq().\n\nseq(from = 2, to = 10, by = 2)\n#&gt; [1]  2  4  6  8 10\n\nA função seq() cria uma sequência numérica de acordo com os argumentos indicados. O from = indica por qual número se inicia a sequência, o to =, em qual número termina e o by =, de quanto em quanto a sequência será construída. Assim, no exemplo, criamos uma sequência que começa do 2, termina no 10 e que vai de 2 em 2.\nTemos a possibilidade de não explicitar os nomes dos argumentos, desde que se respeite a ordem em que os argumentos aparecem.\n\nseq(2, 10, 2)\n#&gt; [1]  2  4  6  8 10\n\nPara saber qual a ordem dos argumentos da função seq(), acessamos a sua documentação com o comando help(seq).\nCaso seja explicitado o nome dos argumentos, a ordem não interfere no resultado final.\n\nseq(by = 2, from = 2, to = 10)\n#&gt; [1]  2  4  6  8 10\n\nMas caso os nomes não sejam explicitados, a ordem incorreta gera outro resultado.\n\nseq(2, 2, 10)\n#&gt; [1] 2\n\nDa mesma forma como salvamos um único valor em um objeto (Seção 3.3), também podemos salvar o resultado de uma função. No exemplo a seguir, guardaremos o resultado da sequência numérica em um objeto de nome sequencia_numerica.\n\nsequencia_numerica &lt;- seq(from = 2, to = 10, by = 2)\nsequencia_numerica\n#&gt; [1]  2  4  6  8 10\n\nAs funções serão a base para realizarmos cada etapa do fluxograma da ciência de dados, assim, nos depararemos com diversas funções e argumentos específicos ao longo dos processos.",
    "crumbs": [
      "Introdução",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Noções básicas em R</span>"
    ]
  },
  {
    "objectID": "basico.html#sec-classes",
    "href": "basico.html#sec-classes",
    "title": "3  Noções básicas em R",
    "section": "\n3.5 Classes",
    "text": "3.5 Classes\nAs classes de objetos nos indicam qual o tipo de valor que está armazenado em um determinado objeto. São divididas em quatro principais tipos:\n\nnumeric: apresenta valores numéricos, sejam inteiros (integer) ou decimais (double);\ncharacter: valores do tipo caractere. Também podemos chamá-los de valores do tipo texto ou string, nome mais comum no meio da programação;\nfactor: apresentam variáveis qualitativas possíveis de serem agrupadas em categorias. Veremos com mais detalhes na Seção 3.7;\nlogical: valores lógicos do tipo verdadeiro ou falso (TRUE/FALSE). Também são conhecidos como valores booleanos. Abordaremos mais detalhadamente esta classe na Seção 3.8.\n\nPara verificarmos a classe de um objeto, utilizamos a função class(), tendo como argumento o nome do objeto. Vejamos alguns exemplos a seguir.\n\na &lt;- 10\nclass(a)\n#&gt; [1] \"numeric\"\n\n\nb &lt;- \"a\"\nclass(b)\n#&gt; [1] \"character\"\n\nPara criarmos um objeto com a classe do tipo caractere, devemos escrevê-lo entre aspas \"\". As aspas servem para diferenciar nomes (objetos, funções e pacotes) de textos (letras e palavras).\nNo exemplo anterior, perceba que na classe numérica criamos um objeto de nome a que recebe o valor 10, enquanto que na classe caractere, criamos um objeto de nome b que recebe o texto \"a\".\nPortanto, de modo conciso: no primeiro caso, criamos um objeto chamado a, enquanto no outro exemplo, criamos um objeto que contém o caractere \"a\".\nConhecer a classe de objetos e valores é importante para definirmos os procedimentos e operações possíveis de serem realizadas. Por exemplo, podemos realizar uma operação matemática com números, porém não podemos realizar com caracteres.\n\n10 + 10\n#&gt; [1] 20\n\n\n\"a\" + \"b\"\n#&gt; Error in \"a\" + \"b\": argumento não-numérico para operador binário\n\n\"1\" + \"1\"\n#&gt; Error in \"1\" + \"1\": argumento não-numérico para operador binário\n\nNo último exemplo, perceba que os números \"1\" foram escritos entre aspas, logo passam a serem tratados como caracteres.\n\nclass(\"1\")\n#&gt; [1] \"character\"\n\nPor este motivo não conseguimos realizar a operação de soma.",
    "crumbs": [
      "Introdução",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Noções básicas em R</span>"
    ]
  },
  {
    "objectID": "basico.html#sec-vetor",
    "href": "basico.html#sec-vetor",
    "title": "3  Noções básicas em R",
    "section": "\n3.6 Vetores",
    "text": "3.6 Vetores\nO vetor é um conjunto de valores sequenciais agrupados. Para criarmos um vetor, devemos utilizar a função c(), cujos argumentos devem estar separados por vírgulas.\n\nc(2, 6, -10, 14, 18.3, 22)\n#&gt; [1]   2.0   6.0 -10.0  14.0  18.3  22.0\n\n\nc(\"a\", \"f\", \"c\")\n#&gt; [1] \"a\" \"f\" \"c\"\n\nDa mesma maneira vista na Seção 3.3, podemos salvar um comando em um objeto. Agora, guardaremos um vetor.\n\nvetor_numerico &lt;- c(2, 6, -10, 14, 18.3, 22)\nvetor_numerico\n#&gt; [1]   2.0   6.0 -10.0  14.0  18.3  22.0\n\nlength(vetor_numerico)\n#&gt; [1] 6\nclass(vetor_numerico)\n#&gt; [1] \"numeric\"\n\n\nvetor_texto &lt;- c(\"a\", \"f\", \"c\")\nvetor_texto\n#&gt; [1] \"a\" \"f\" \"c\"\n\nlength(vetor_texto)\n#&gt; [1] 3\nclass(vetor_texto)\n#&gt; [1] \"character\"\n\nA função length() traz a quantidades de elementos que o vetor apresenta. O objeto vetor_numerico apresenta seis elementos e o vetor_texto, três.\nCom a função class(), verificamos a classe dos elementos presentes nos vetores.\nContudo, um vetor só pode guardar um tipo de classe. Caso misturemos um vetor com números e caracteres, os números serão convertidos para texto. Esse comportamento é conhecido como coerção.\n\nvetor_misto &lt;- c(1, 5, \"a\")\nvetor_misto\n#&gt; [1] \"1\" \"5\" \"a\"\n\nclass(vetor_misto)\n#&gt; [1] \"character\"\n\nOs números 1 e 5, dentro de um vetor que contém o caractere \"a\", são convertidos para texto, resultando em um vetor com os textos \"1\", \"5\" e \"a\", como constatado ao utilizar a função class(), que nos retorna uma classe do tipo caractere.\nPortanto, devemos ter em mente que, para vetores com valores de classes diferentes, os caracteres serão dominantes em relação aos números.\nPara criar um conjunto de valores com classes diferentes, devemos criar uma lista, assunto que veremos mais adiante na Seção 3.11.\nPodemos criar um vetor com uma sequência de números interios utilizando o operador :.\n\nsequencia_numerica &lt;- 1:4\nsequencia_numerica\n#&gt; [1] 1 2 3 4\n\nAlém disso, podemos utilizar objetos que guardam um vetor dentro de funções. Como exemplo, utilizaremos a função sum() para somar os valores contidos no vetor sequencia_numerica.\n\nsum(sequencia_numerica)\n#&gt; [1] 10\n\nAo criarmos um vetor, cada elemento ocupa uma posição dentro dele. A posição é dada pela ordem em que estão declarados no vetor, começando pela posição de número 1.\nA operação que encontra valores em um vetor de acordo com sua posição é conhecida por subsetting.\nPara isso, logo após o nome do objeto que desejamos analisar, colocamos o número da posição dentro de colchetes [].\n\nposicao_vetor &lt;- c(11, 22, 33, 44)\nposicao_vetor\n#&gt; [1] 11 22 33 44\n\nposicao_vetor[1]\n#&gt; [1] 11\nposicao_vetor[2]\n#&gt; [1] 22\nposicao_vetor[3]\n#&gt; [1] 33\nposicao_vetor[4]\n#&gt; [1] 44\nposicao_vetor[5]\n#&gt; [1] NA\n\nO objeto de nome posicao_vetor é um vetor com 4 valores. Com o comando posicao_vetor[1], temos o valor 11, contido na primeira posição do vetor, seguindo a mesma lógica para as demais posições.\nPerceba que o comando posicao_vetor[5] nos retorna o valor NA, pois não existe esta posição dentro do vetor. Mais adiante, na Seção 3.9, trataremos sobre o valor NA.\nTambém podemos inserir um conjunto de posições dentro dos colchetes, o que nos retorna um subconjunto de valores dentro de um vetor. Para isso, utilizamos a função c(), tendo como argumentos as posições que se deseja acessar.\n\nvetor_letras &lt;- c(\"w\", \"x\", \"y\", \"z\")\nvetor_letras\n#&gt; [1] \"w\" \"x\" \"y\" \"z\"\n\nvetor_letras[c(2, 4)]\n#&gt; [1] \"x\" \"z\"\n\nPartindo da lógica do subsetting, podemos substituir elementos de um vetor existente.\n\nvetor_letras[4] &lt;- \"a\"\nvetor_letras\n#&gt; [1] \"w\" \"x\" \"y\" \"a\"\n\nNo comando acima, trocamos a letra \"z\" do objeto vetor_letras pela letra \"a\". Primeiramente, selecionamos a posição em que se encontra a letra \"z\" com o comando vetor_letras[4]. Em seguida, atribuímos a letra \"a\", com o operador &lt;-, à posição que se deseja substituir.\nA mesma lógica vale para substituir mais de um elemento de um vetor.\n\nvetor_letras[c(1,3)] &lt;- c(\"b\",\"q\")\nvetor_letras\n#&gt; [1] \"b\" \"x\" \"q\" \"a\"\n\nPara acrescentar um elemento novo ao vetor, selecionamos uma nova posição e, em seguida, atribuímos o valor desejado.\n\nvetor_letras[5] &lt;- \"m\"\nvetor_letras\n#&gt; [1] \"b\" \"x\" \"q\" \"a\" \"m\"\n\nTambém é possível realizar operações matemáticas com vetores de classe numérica.\n\nvetor_valor &lt;- c(8, 19, 24, 25)\n\nvetor_valor + 1\n#&gt; [1]  9 20 25 26\nvetor_valor - 1\n#&gt; [1]  7 18 23 24\nvetor_valor / 2\n#&gt; [1]  4.0  9.5 12.0 12.5\nvetor_valor * 2\n#&gt; [1] 16 38 48 50\nvetor_valor ^ 2\n#&gt; [1]  64 361 576 625\n\nPerceba que as operações matemáticas são executadas para cada um dos elementos do vetor.\nTambém podemos fazer operações entre vetores:\n\nvetor1 &lt;- c(1, 2, 3, 4)\nvetor2 &lt;- c(5, 6, 7, 8)\n\nvetor1 + vetor2\n#&gt; [1]  6  8 10 12\n\nPara realizar a operação, ambos os vetores são alinhados, sendo somados os valores de acordo com a posição correlata entre os elementos dos vetores. Portanto, o elemento que oculpa a primeira posição no vetor1 é somado com o primeiro elemento do vetor2, seguindo a mesma lógica para os demais elementos.\nNo caso de vetores com tamanhos diferentes, ocorre o processo de reciclagem.\n\nvetor3 &lt;- c(1, 3)\nvetor4 &lt;- c(11, 22, 33, 44)\n\nvetor3 + vetor4\n#&gt; [1] 12 25 34 47\n\nA operação entre vetores de tamanhos diferentes segue a mesma lógica citada anteriormente: ambos os vetores são alinhados, porém, por apresentarem diferentes dimensões, é realizada uma repetição (reciclagem) do vetor3 para que esse fique com o mesmo tamanho do vetor4, assim, possibilitando a operação matemática. Portanto, é como se o vetor3 tivesse a dimensão de c(1, 3, 1, 3).\nVale destacar que o comportamento de reciclagem foi aplicado quando fizemos as operações matemáticas em um só vetor. Por exemplo, quando somamos 1 ao vetor de dimensão c(8, 19, 24, 25), o R reciclou o número 1 (que nada mais é do que um vetor de tamanho 1, igual a c(1)) formando um vetor c(1, 1, 1, 1) para que fosse possível realizar a soma.\nAté então, fizemos operações entre vetores com comprimentos múltiplos entre si. Ao realizar operações entre vetores cujos tamanhos não são múltiplos, a reciclagem atua da seguinte maneira.\n\nvetor5 &lt;- c(1, 2, 3)\nvetor6 &lt;- c(10, 20, 30, 40, 50)\n\nvetor5 + vetor6\n#&gt; Warning in vetor5 + vetor6: comprimento do objeto maior não é múltiplo do\n#&gt; comprimento do objeto menor\n#&gt; [1] 11 22 33 41 52\n\nNessa situação, foi realizada a reciclagem do vetor5 até que ele adquirisse a mesma dimensão do vetor6. Assim, o vetor5 se apresenta da seguinte maneira após a reciclagem: c(1, 2, 3, 1, 2). Perceba que o último valor do vetor5 não foi reciclado na operação, pois sua presença na reciclagem ultrapassaria a dimensão do vetor6.\nNormalmente, esse tipo de operação não é desejado devido a não reciclagem de certos valores de um vetor, o que pode causar problemas de inconsistências. E, justamente, por ser um processo incomum, o R gera uma mensagem de aviso (warning) no console, alertando o ocorrido.\nGuarde com carinho os conceitos explicados nesta seção, pois os utilizaremos com muita frequência nos próximos capítulos, principalmente na Seção 3.12 que trata sobre os data frames.",
    "crumbs": [
      "Introdução",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Noções básicas em R</span>"
    ]
  },
  {
    "objectID": "basico.html#sec-fator",
    "href": "basico.html#sec-fator",
    "title": "3  Noções básicas em R",
    "section": "\n3.7 Fatores",
    "text": "3.7 Fatores\nAs variáveis do tipo fator são um caso especial de classe de objetos que representam variáveis qualitativas possíveis de serem agrupadas em categorias, como, por exemplo, o sexo e grau de escolaridade.\nAs categorias presentes em um fator são indicadas pelo atributo levels, como os masculino e feminino, no caso do sexo, e ensino fundamental, médio e superior, no caso do grau de escolaridade.\nNormalmente, este tipo de variável é criada ou importada como texto, sendo necessário transformá-la em fator. Para isso, utilizamos a função as.factor().\n\nsexo &lt;- c(\"F\", \"F\", \"M\", \"F\", \"M\", \"M\")\nsexo\n#&gt; [1] \"F\" \"F\" \"M\" \"F\" \"M\" \"M\"\n\nclass(sexo)\n#&gt; [1] \"character\"\n\n\nas.factor(sexo)\n#&gt; [1] F F M F M M\n#&gt; Levels: F M\n\nCriando o objeto sexo, sendo os argumentos F para o sexo feminino e M para o masculino, temos um vetor do tipo caractere. Como o sexo é uma variável possível de ser categorizada, transformamos essa variável para a classe fator, a partir da função as.factor(), sendo criados os levels F e M.\nAinda, podemos criar diretamente um vetor do tipo fator utilizando a função factor().\n\nsexo_fator &lt;- factor(c(\"F\", \"F\", \"M\", \"F\", \"M\", \"M\"))\nsexo_fator\n#&gt; [1] F F M F M M\n#&gt; Levels: F M\n\nclass(sexo_fator)\n#&gt; [1] \"factor\"\n\nPor padrão, os levels são ordenados por ordem alfabética. No exemplo anterior, a categoria F vem antes da M. Para reordená-las, utilizamos o argumento levels na função factor(), ordenando as categorias de acordo com sua posição no vetor.\n\nsexo_fator &lt;- factor(sexo_fator, levels = c(\"M\", \"F\"))\n\nlevels(sexo_fator)\n#&gt; [1] \"M\" \"F\"\n\nEm outro exemplo, agora com o grau de escolaridade, também se trata de variáveis categorizáveis, portanto, do tipo fator. Porém, são categorias possíveis de serem ordenadas a partir de um critério, como por exemplo, do menor grau de escolaridade ao maior. Para criar esta ordenação, declaramos o argumento ordered = TRUE dentro da função factor().\n\nescolaridade &lt;- factor(\n  c(\"NE\", \"ES\", \"EF\", \"EM\", \"EF\", \"EF\", \"EM\", \"ES\"),\n  levels = c(\"NE\", \"EF\", \"EM\", \"ES\"),\n  ordered = TRUE\n)\nescolaridade\n#&gt; [1] NE ES EF EM EF EF EM ES\n#&gt; Levels: NE &lt; EF &lt; EM &lt; ES\n\nclass(escolaridade)\n#&gt; [1] \"ordered\" \"factor\"\n\nO vetor escolaridade apresenta informações do nível de escolaridade, cujas categorias são não escolarizado (NE), ensino fundamental (EF), ensino médio (EM) e ensino superior (ES).\nSemelhante ao realizado nos exemplos anteriores, utilizamos a função factor() para criar o vetor do tipo fator, definimos as categorias no argumento levels = e, com o ordered = TRUE, indicamos que as categorias são ordenadas de acordo com a ordem estabelecida em levels =.\nNote que o resultado nos trouxe níveis ordenados Levels: NE &lt; EF &lt; EM &lt; ES e uma classe do tipo \"ordered\" \"factor\", ou seja, um classe do tipo fator ordenado.\n\n3.7.1 Diferenças entre fatores e caracteres\nApesar dos objetos do tipo fator serem representados por letras ou palavras, o R os enxerga como números inteiros, diferentemente dos objetos da classe caractere, que são puramente textos. Podemos notar essas diferenças ao tentar convertê-las em classe numérica com a função as.numeric().\n\nsexo &lt;- c(\"F\", \"F\", \"M\", \"F\", \"M\", \"M\")\n\nclass(sexo)\n#&gt; [1] \"character\"\nas.numeric(sexo)\n#&gt; [1] NA NA NA NA NA NA\n\n\nsexo_fator &lt;- factor(c(\"F\", \"F\", \"M\", \"F\", \"M\", \"M\"))\n\nclass(sexo_fator)\n#&gt; [1] \"factor\"\nas.numeric(sexo_fator)\n#&gt; [1] 1 1 2 1 2 2\n\nPodemos notar que não foi possível converter o vetor do tipo caractere para um vetor numérico, pois o R não consegue atribuir uma classificação numérica para textos. Porém, no caso do vetor tipo fator, foi possível transformá-lo em um tipo numérico, sendo representado como 1 o nível F e como 2, o nível M.\nPortanto, para o R, os levels dos fatores são números inteiros sequenciais, começando do 1, atribuídos conforme a ordem dos argumentos estabelecidos no vetor. Isso facilita a utilização de variáveis de classe fator em modelos estatísticos, uma vez que as variáveis já estão codificadas como números.",
    "crumbs": [
      "Introdução",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Noções básicas em R</span>"
    ]
  },
  {
    "objectID": "basico.html#sec-logica",
    "href": "basico.html#sec-logica",
    "title": "3  Noções básicas em R",
    "section": "\n3.8 Operações lógicas",
    "text": "3.8 Operações lógicas\nAs operações lógicas nos retornam valores do tipo verdadeiro ou falso, representados no R por TRUE e FALSE (em letras maiúsculas), respectivamente. Dessa forma, a classe atribuida a estes tipos de valores é a logical, aceitando somente estes dois valores.\n\nclass(TRUE)\n#&gt; [1] \"logical\"\n\nclass(FALSE)\n#&gt; [1] \"logical\"\n\nTambém podemos abreviá-los por suas iniciais T e F.\n\nclass(T)\n#&gt; [1] \"logical\"\n\nclass(F)\n#&gt; [1] \"logical\"\n\nContudo, recomenda-se utilizar a forma completa de seus nomes para deixar o código mais claro e evitar conflitos, caso um objeto seja nomeado com tais letras.\nDa mesma forma que os fatores, os operadores lógicos são codificados por números, sendo 1 atribuído ao TRUE e 0 ao FALSE.\n\nas.numeric(TRUE)\n#&gt; [1] 1\n\nas.numeric(FALSE)\n#&gt; [1] 0\n\nPara aplicarmos testes lógicos, ou seja, comparações entre valores, podemos utilizar o operador == para verificar se dois valores são iguais, ou o operador != para ver se os valores são diferentes.\n\n# Resultados verdadeiros (TRUE)\n52 == 52\n#&gt; [1] TRUE\n\"x\" == \"x\"\n#&gt; [1] TRUE\n\"a\" != \"b\"\n#&gt; [1] TRUE\n1 != 2\n#&gt; [1] TRUE\n\n\n# Resultados falsos (FALSE)\n52 != 52\n#&gt; [1] FALSE\n\"x\" != \"x\"\n#&gt; [1] FALSE\n\"a\" == \"b\"\n#&gt; [1] FALSE\n1 == 2\n#&gt; [1] FALSE\n\nAlém disso, podemos utilizar outros operadores lógicos, como por exemplo:\n\n&lt; se um valor é menor que o outro;\n&gt; se um valor é maior que o outro;\n&lt;= se um valor é menor ou igual que o outro;\n&gt;= se um valor é maior ou igual que o outro.\n\n\n# Menor\n3 &lt; 5\n#&gt; [1] TRUE\n3 &lt; 2\n#&gt; [1] FALSE\n\n\n# Maior\n3 &gt; 1\n#&gt; [1] TRUE\n4 &gt; 7\n#&gt; [1] FALSE\n\n\n# Menor ou igual\n3 &lt;= 3\n#&gt; [1] TRUE\n2 &lt;= 1\n#&gt; [1] FALSE\n\n\n# Maior ou igual\n10 &gt;= 5\n#&gt; [1] TRUE\n1 &gt;= 6\n#&gt; [1] FALSE\n\nO operador %in% verifica se um dado valor pertence a um vetor, ou seja, se um valor está contido dentro de um conjunto de valores.\n\n3 %in% c(1, 2, 3)\n#&gt; [1] TRUE\n\nc(\"y\", \"a\") %in% c(\"x\", \"y\")\n#&gt; [1]  TRUE FALSE\n\nNo último exemplo, testamos se os elementos \"y\" e \"a\" estão presentes no vetor c(\"x\", \"y\"). Como resultado, temos que \"y\" está contido no vetor (TRUE) e \"a\", não (FALSE), independentemente da posição em que se encontram declarados.\nA Tabela 3.2 traz um resumo dos principais operadores lógicos.\n\n\nTabela 3.2: Operadores lógicos do R.\n\n\n\nOperador\nSintaxe\nTeste\n\n\n\n==\na == b\na é igual a b?\n\n\n!=\na != b\na é diferente de b?\n\n\n&gt;\na &gt; b\na é maior que b?\n\n\n&gt;=\na &gt;= b\na é maior ou igual a b?\n\n\n&lt;\na &lt; b\na é menor que b?\n\n\n&lt;=\na &lt;= b\na é menor ou igual a b?\n\n\n%in%\na %in% c(a, b, c)\na está presente em c(a, b, c)?\n\n\n\n\n\n\nTratando dos vetores e operações lógicas, observe o seguinte exemplo.\n\nvet &lt;- c(1, 0, 6, -9, 10, 52, 3)\n\nvet &gt; 3\n#&gt; [1] FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE\n\nvet[vet &gt; 3]\n#&gt; [1]  6 10 52\n\nAqui teremos que relembrar alguns conceitos expostos anteriormente.\nPrimeiramente, criamos um vetor de nome vet, que recebe 7 valores. Posteriormente, utilizamos um teste lógico para verificar quais valores de vet são maiores que 3, cuja resposta é dada por TRUE ou FALSE.\nNessa situação, ocorre uma reciclagem (Seção 3.6) do valor 3, portanto, resultando em um vetor igual a c(3, 3, 3, 3, 3, 3, 3).\nA partir disso, o R alinha o vetor c(1, 0, 6, -9, 10, 52, 3) com o vetor c(3, 3, 3, 3, 3, 3, 3) e testa a lógica proposta, elemento por elemento (1 &gt; 3, 0 &gt; 3, 6 &gt; 3, -9 &gt; 3, 10 &gt; 3, 52 &gt; 3 e 3 &gt; 3), formando um vetor de verdadeiros e falsos.\nToda essa explicação embasa a operação lógica vet[vet &gt; 3], que nos retorna apenas os valores do vetor que são maiores que 3, ou seja, todos os valores iguais a TRUE.\nEsse tipo de operação será muito utilizado nos capítulos seguintes, mais especificamente no Capítulo 7 ao utilizarmos a função dplyr::filter(), essa muito mais simples de operar do que em relação ao apresentado anteriormente, porém seguindo a mesma lógica.",
    "crumbs": [
      "Introdução",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Noções básicas em R</span>"
    ]
  },
  {
    "objectID": "basico.html#sec-especial",
    "href": "basico.html#sec-especial",
    "title": "3  Noções básicas em R",
    "section": "\n3.9 Valores especiais",
    "text": "3.9 Valores especiais\nNesta seção, explicaremos alguns valores particulares presentes no R.\n\n3.9.1 NA\nO NA (not available) representa a ausência de informação, ou seja, a informação existe, porém não se sabe qual é.\nPodemos exemplificar o significado de NA com uma coleta de dados em que certos indivíduos não informaram suas idades. Isso não significa que os entrevistados não possuem idade, mas que o registro de algumas idades é uma informação ausente na pesquisa.\n\nidade_jose &lt;- 24\nidade_joao &lt;- NA\nidade_maria &lt;- NA\n\nSabendo do significado de NA, podemos aprofundar sua utilização em testes lógicos.\n\nidade_jose == idade_joao\n#&gt; [1] NA\n\nidade_joao == idade_maria\n#&gt; [1] NA\n\nConhecemos apenas a idade do José e não sabemos a idade do João e da Maria, logo, a idade dos dois últimos são representados pelo valor NA.\nAo aplicar o teste lógico idade_jose == idade_joao, o resultado é o valor NA, ou seja, o R não sabe responder se a idade do José é a mesma de João, uma vez que a idade do João não foi informada.\nNo teste idade_joao == idade_maria, também nos é retornado o valor NA, pois ambas as idades não foram informadas, logo tanto a idade do João pode ser a mesma da Maria, como pode ser diferente. Assim, o R não tentará adivinhar uma resposta e simplesmente responderá: NA - com base nas informações disponíveis, não é possível ter uma resposta concreta.\nTambém podemos utilizar testes lógicos com a função is.na(), que verifica a presença ou ausência de NA em objetos.\n\nis.na(c(idade_jose, idade_joao, idade_maria))\n#&gt; [1] FALSE  TRUE  TRUE\n\nDessa forma, em conjuntos de dados, é comum que algumas informações não tenham registro, sendo assim representadas pelo valor NA. Com isso, devemos saber interpretar e tratar estes valores.\nEm algumas operações, como a média (mean()), não conseguimos executá-la na presença desses valores.\n\nvetor_ausente &lt;- c(1, 2, 3, NA)\n\nmean(vetor_ausente)\n#&gt; [1] NA\n\nNo caso da função mean(), ela possui o argumento na.rm = TRUE para excluir os NA da operação matemática.\n\nmean(vetor_ausente, na.rm = TRUE)\n#&gt; [1] 2\n\nTodavia, algumas outras funções não possuem um argumento semelhante, sendo necessário realizar outras manipulações de dados, as quais veremos no Capítulo 7.\n\n3.9.2 NaN\nO NaN (not a number) representa indeterminações matemáticas.\n\n0/0\n#&gt; [1] NaN\n\nlog(-1)\n#&gt; [1] NaN\n\nTambém podemos utilizar testes lógicos com a função is.nan().\n\nis.nan(0/0)\n#&gt; [1] TRUE\n\n\n3.9.3 Inf\nO Inf (infinite) representa um valor muito grande, o qual o R não consegue retratar.\n\n100 ^ 200\n#&gt; [1] Inf\n\nE também pode representar um limite matemático.\n\n1 / 0\n#&gt; [1] Inf\n-1 / 0\n#&gt; [1] -Inf\n\nNovamente, podemos utilizar testes lógicos para identificar se um objeto apresenta valor infinito. Para isso, utilizamos a função is.infinite().\n\nis.infinite(1 / 0)\n#&gt; [1] TRUE\n\nPara valores testar valores finitos, utilizamos a função is.finite().\n\nis.finite(1 / 0)\n#&gt; [1] FALSE\n\n\n3.9.4 NULL\nO NULL representa a ausência de um objeto. Seu significado está mais atrelado a lógica de programação, quando não queremos atribuir valor à um objeto. Portanto, diferentemente do NA, o NULL indica a inexistência de um parâmetro qualquer.\n\nvalor_nulo &lt;- NULL\nvalor_nulo\n#&gt; NULL\n\nPara utilizar teste lógico à valores nulos, utilizamos a função is.null().\n\nis.null(valor_nulo)\n#&gt; [1] TRUE",
    "crumbs": [
      "Introdução",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Noções básicas em R</span>"
    ]
  },
  {
    "objectID": "basico.html#sec-dataf",
    "href": "basico.html#sec-dataf",
    "title": "3  Noções básicas em R",
    "section": "\n3.10 Data frames",
    "text": "3.10 Data frames\nO data frame é o objeto que armazena os dados criados ou importados para o R. São estruturados a partir de linhas e colunas, sendo que cada coluna representa uma variável e cada linha, uma observação, estrutura muito semelhante a uma planilha Excel.\n\nPlantGrowth\n#&gt;    weight group\n#&gt; 1    4.17  ctrl\n#&gt; 2    5.58  ctrl\n#&gt; 3    5.18  ctrl\n#&gt; 4    6.11  ctrl\n#&gt; 5    4.50  ctrl\n#&gt; 6    4.61  ctrl\n#&gt; 7    5.17  ctrl\n#&gt; 8    4.53  ctrl\n#&gt; 9    5.33  ctrl\n#&gt; 10   5.14  ctrl\n#&gt; 11   4.81  trt1\n#&gt; 12   4.17  trt1\n#&gt; 13   4.41  trt1\n#&gt; 14   3.59  trt1\n#&gt; 15   5.87  trt1\n#&gt; 16   3.83  trt1\n#&gt; 17   6.03  trt1\n#&gt; 18   4.89  trt1\n#&gt; 19   4.32  trt1\n#&gt; 20   4.69  trt1\n#&gt; 21   6.31  trt2\n#&gt; 22   5.12  trt2\n#&gt; 23   5.54  trt2\n#&gt; 24   5.50  trt2\n#&gt; 25   5.37  trt2\n#&gt; 26   5.29  trt2\n#&gt; 27   4.92  trt2\n#&gt; 28   6.15  trt2\n#&gt; 29   5.80  trt2\n#&gt; 30   5.26  trt2\n\nO data frame PlantGrowth é nativo do R e contém dados sobre o crescimento de plantas sob 2 tipos diferentes de tratamentos, além do controle (mais informações em ?PlantGrowth). Possui 30 linhas (observações) e 2 colunas (variáveis).\nPortanto, podemos dizer que o objeto de nome PlantGrowth guarda um data frame com 30 observações (ou linhas) e 2 variáveis (ou colunas).\nPodemos aplicar algumas funções em data frames, a fim de visualizarmos melhor sua estrutura e elementos presentes. A seguir, demonstraremos algumas delas.\n\n# Mostra as 6 primeiras linhas\nhead(PlantGrowth)\n#&gt;   weight group\n#&gt; 1   4.17  ctrl\n#&gt; 2   5.58  ctrl\n#&gt; 3   5.18  ctrl\n#&gt; 4   6.11  ctrl\n#&gt; 5   4.50  ctrl\n#&gt; 6   4.61  ctrl\n\n\n# Mostra as 6 últimas linhas\ntail(PlantGrowth)\n#&gt;    weight group\n#&gt; 25   5.37  trt2\n#&gt; 26   5.29  trt2\n#&gt; 27   4.92  trt2\n#&gt; 28   6.15  trt2\n#&gt; 29   5.80  trt2\n#&gt; 30   5.26  trt2\n\n\n# Mostra as dimensões (nº de linhas x nº de coluna)\ndim(PlantGrowth)\n#&gt; [1] 30  2\n\n\n# Mostra os nomes das variáveis (colunas)\nnames(PlantGrowth)\n#&gt; [1] \"weight\" \"group\"\n\n\n# Estrutura geral do data frame (tipo, dimensão e classes)\nstr(PlantGrowth)\n#&gt; 'data.frame':    30 obs. of  2 variables:\n#&gt;  $ weight: num  4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...\n#&gt;  $ group : Factor w/ 3 levels \"ctrl\",\"trt1\",..: 1 1 1 1 1 1 1 1 1 1 ...\n\n\n# Medidas-resumo\nsummary(PlantGrowth)\n#&gt;      weight       group   \n#&gt;  Min.   :3.590   ctrl:10  \n#&gt;  1st Qu.:4.550   trt1:10  \n#&gt;  Median :5.155   trt2:10  \n#&gt;  Mean   :5.073            \n#&gt;  3rd Qu.:5.530            \n#&gt;  Max.   :6.310\n\nTambém podemos criar um data frame dentro do R com a função data.frame().\n\ndados_df &lt;- data.frame(\n  nome = c(\"José\", \"Joao\", \"Maria\"),\n  sexo = c(\"M\", \"M\", \"F\"),\n  idade = c(24, 19, 20)\n)\n\ndados_df\n#&gt;    nome sexo idade\n#&gt; 1  José    M    24\n#&gt; 2  Joao    M    19\n#&gt; 3 Maria    F    20\n\nDentro da função, designamos nomes para as colunas (nome, sexo e idade), seguidos dos vetores com as observações.\nOutra função útil quando trabalhamos com data frames é a View(). Ela nos dá uma visão ampliada e interativa dos dados ao abrir uma nova aba na janela do script.\n\nView(dados_df)\n\n\n\n\n\n\n\n\nFigura 3.3: A função View() nos auxilia a visualizar os dados de maneira ampliada e interativa.\n\n\n\n\nNa nova aba, ilustrada na Figura 3.3, podemos filtrar as colunas de acordo com alguma especificação. Clicando no nome das colunas, pode-se ordenar as observações alfabética ou numericamente. Ao lado do ícone de filtrar, podemos abrir esta aba em uma nova janela, sendo muito útil para utilizá-la em uma segunda tela.\nOutra forma de abrir a opção View() é clicando no ícone ao lado do objeto criado na janela Environment, quando selecionado o modo de apresentação Grid da mesma janela.\nOs data frames serão o nosso principal objeto de estudo para aplicarmos ciência de dados, uma vez que guardam os dados a serem analisados. Estudaremos os data frames com mais detalhes na Seção 3.12. Já no Capítulo 4 veremos como importar dados para o R, transformando-os em data frames. Mas antes, trataremos das listas, assunto do tópico a seguir.",
    "crumbs": [
      "Introdução",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Noções básicas em R</span>"
    ]
  },
  {
    "objectID": "basico.html#sec-list",
    "href": "basico.html#sec-list",
    "title": "3  Noções básicas em R",
    "section": "\n3.11 Listas",
    "text": "3.11 Listas\nAs listas são objetos semelhantes a um vetor, porém, com algumas diferenças. Como citado na Seção 3.6, não podemos misturar objetos de classes distintas em um mesmo vetor. Contudo, podemos realizar essa mescla de classes com as listas.\nPara criarmos uma lista, utilizamos a função list(), tendo como argumentos os valores desejados.\n\nlista &lt;- list(5, \"x\", FALSE)\nlista\n#&gt; [[1]]\n#&gt; [1] 5\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"x\"\n#&gt; \n#&gt; [[3]]\n#&gt; [1] FALSE\n\nclass(lista)\n#&gt; [1] \"list\"\n\nNesse caso, criamos uma lista com elementos de classes numérica, caractere e lógica, sem que ocorresse coerção, ou seja, não houve a conversão dos elementos do objeto para uma única classe, como vimos ocorrer com os vetores. Assim, as listas nos permite unir classes distintas em um mesmo objeto.\nOutro diferencial é o fato de que cada elemento de uma lista também é uma lista. Portanto, para acessarmos um elemento de uma lista, devemos utilizar dois colchetes [[]].\n\nlista &lt;- list(5, \"x\", FALSE)\n\n# Utilizando 1 colchete, nos retorna uma classe do tipo lista\nlista[2]\n#&gt; [[1]]\n#&gt; [1] \"x\"\nclass(lista[2])\n#&gt; [1] \"list\"\n\n# Utilizando 2 colchetes, nos retorna a classe do elemento\nlista[[2]]\n#&gt; [1] \"x\"\nclass(lista[[2]])\n#&gt; [1] \"character\"\n\nAssim, utilizando um colchete, é retornado a classe da lista que contém um único elemento. Já com dois colchetes, nos é retornado a classe do elemento que está na lista, no caso do exemplo, a classe do elemento \"x\".\nO fato de cada elemento ser uma lista dentro de uma lista é importante para podermos colocar vetores de tamanhos diferentes em cada posição. Isso faz das listas objetos muito flexíveis para armazenar dados.\n\nlistas_sao_flexiveis &lt;- list(\n  1:5, \n  c(\"a\", \"b\", \"c\"),\n  c(TRUE, FALSE, TRUE, FALSE)\n)\n\nlistas_sao_flexiveis[1]\n#&gt; [[1]]\n#&gt; [1] 1 2 3 4 5\nlistas_sao_flexiveis[2]\n#&gt; [[1]]\n#&gt; [1] \"a\" \"b\" \"c\"\nlistas_sao_flexiveis[3]\n#&gt; [[1]]\n#&gt; [1]  TRUE FALSE  TRUE FALSE\n\nDa mesma forma realizada com os data frames (Seção 3.10), podemos nomear cada posição de uma lista. Para isso, colocamos dentro da função list() os argumentos com as respectivas denominações e valores.\n\ndados_estudantes &lt;- list(\n  nome = c(\"José\", \"Joao\", \"Maria\"),\n  sexo = c(\"M\", \"M\", \"F\"),\n  idade = c(24, 19, 20)\n)\n\ndados_estudantes\n#&gt; $nome\n#&gt; [1] \"José\"  \"Joao\"  \"Maria\"\n#&gt; \n#&gt; $sexo\n#&gt; [1] \"M\" \"M\" \"F\"\n#&gt; \n#&gt; $idade\n#&gt; [1] 24 19 20\n\nQuando a posição de uma lista possui um nome, podemos acessar seus valores com o operador $. Esse operador é equivalente a dados_alunos[[]].\n\n# Equivalente a dados_estudantes[[1]]\ndados_estudantes$nome\n#&gt; [1] \"José\"  \"Joao\"  \"Maria\"\n\n# Equivalente a dados_estudantes[[2]]\ndados_estudantes$sexo\n#&gt; [1] \"M\" \"M\" \"F\"\n\n# Equivalente a dados_estudantes[[3]]\ndados_estudantes$idade\n#&gt; [1] 24 19 20",
    "crumbs": [
      "Introdução",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Noções básicas em R</span>"
    ]
  },
  {
    "objectID": "basico.html#sec-lista-df",
    "href": "basico.html#sec-lista-df",
    "title": "3  Noções básicas em R",
    "section": "\n3.12 Data frames e listas",
    "text": "3.12 Data frames e listas\nA relação entre listas e data frames é que, basicamente, os data frames são um tipo de lista. Assim, as propriedades expostas sobre as listas se aplicam aos data frames.\nNa Seção 3.10, apresentamos o básico sobre os data frames, exemplificado com o PlantGrowth. Assim, para entendermos a equivalência entre listas e data frames, converteremos o PlantGrowth em uma lista com a função as.list().\n\nhead(PlantGrowth)\n#&gt;   weight group\n#&gt; 1   4.17  ctrl\n#&gt; 2   5.58  ctrl\n#&gt; 3   5.18  ctrl\n#&gt; 4   6.11  ctrl\n#&gt; 5   4.50  ctrl\n#&gt; 6   4.61  ctrl\n\nclass(PlantGrowth)\n#&gt; [1] \"data.frame\"\n\n\nas.list(PlantGrowth)\n#&gt; $weight\n#&gt;  [1] 4.17 5.58 5.18 6.11 4.50 4.61 5.17 4.53 5.33 5.14 4.81 4.17 4.41 3.59 5.87\n#&gt; [16] 3.83 6.03 4.89 4.32 4.69 6.31 5.12 5.54 5.50 5.37 5.29 4.92 6.15 5.80 5.26\n#&gt; \n#&gt; $group\n#&gt;  [1] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl trt1 trt1 trt1 trt1 trt1\n#&gt; [16] trt1 trt1 trt1 trt1 trt1 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2\n#&gt; Levels: ctrl trt1 trt2\n\nPerceba que os nomes das colunas do data frame se tornam o nome das posições de uma lista ($weight e $group) e cada um dos valores das colunas são convertidos em elementos da respectiva lista.\nPortanto, podemos dizer que cada coluna de um data frame também é um data frame.\n\n# Classe do data frame PlantGrowth\nclass(PlantGrowth)\n#&gt; [1] \"data.frame\"\n\n# Classe da primeira coluna (weight)\nclass(PlantGrowth[1])\n#&gt; [1] \"data.frame\"\n\nDessa forma, podemos utilizar o operador $ para acessar os elementos de uma coluna, como fizemos para o nome das lista.\n\nPlantGrowth$weight\n#&gt;  [1] 4.17 5.58 5.18 6.11 4.50 4.61 5.17 4.53 5.33 5.14 4.81 4.17 4.41 3.59 5.87\n#&gt; [16] 3.83 6.03 4.89 4.32 4.69 6.31 5.12 5.54 5.50 5.37 5.29 4.92 6.15 5.80 5.26\n\nPlantGrowth$group\n#&gt;  [1] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl trt1 trt1 trt1 trt1 trt1\n#&gt; [16] trt1 trt1 trt1 trt1 trt1 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2\n#&gt; Levels: ctrl trt1 trt2\n\nE com isso, conseguimos utilizá-las em funções.\n\nmean(PlantGrowth$weight)\n#&gt; [1] 5.073\n\nContudo, temos de destacar que todo data frame é um tipo de lista, porém nem toda lista é um data frame. Assim, o data frame possui algumas propriedades particulares que o tornam um tipo de lista especial:\n\nTodas as colunas precisam ter a mesma dimensão, ou seja, ter o mesmo número de linhas;\nTodas as colunas precisam ser nomeadas;\nPossuir duas dimensões.\n\nEssas propriedades nos indicam que um data frame tem que receber um conjunto de dados em formato retangular (análoga a uma planilha Excel), com o mesmo número de linhas (observações) em cada coluna (variável), sendo necessário a presença de um nome específico para cada uma das colunas.\nUm exemplo da propriedade Todas as colunas precisam ter a mesma dimensão é a tentativa (falha) de converter uma lista com vetores de comprimentos diferentes em um data frame.\n\nlistas &lt;- list(\n  1:5, \n  c(\"a\", \"b\", \"c\"), \n  c(TRUE, FALSE, TRUE, FALSE)\n)\n\nas.data.frame(listas)\n#&gt; Error in (function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, : argumentos implicam em número de linhas distintos: 5, 3, 4\n\nA propriedade Todas as colunas precisam ser nomeadas não é um impeditivo para se criar um data frame, porém, não se obtém um bom resultado ao ignorá-la, uma vez que o R trata de designá-los de uma maneira pouco conveniente.\n\ndados_estudantes &lt;- list(\n  c(\"José\", \"Joao\", \"Maria\"),\n  c(\"M\", \"M\", \"F\"),\n  c(26, 19, 20)\n)\n\nas.data.frame(dados_estudantes)\n#&gt;   c..José....Joao....Maria.. c..M....M....F.. c.26..19..20.\n#&gt; 1                       José                M            26\n#&gt; 2                       Joao                M            19\n#&gt; 3                      Maria                F            20\n\nJá a propriedade Possuir duas dimensões indica que o data frame possui linhas e colunas, o que o diferencia das listas, uma vez que essas não possuem dimensão.\n\ndim(PlantGrowth)\n#&gt; [1] 30  2\n\n\ndim(as.list(PlantGrowth))\n#&gt; NULL\n\nA função dim() nos indica que o data frame PlantGrowth apresenta 30 linhas e 2 colunas. Por outro lado, ao convertermos o data frame PlantGrowth em uma lista, a mesma função nos diz que o objeto é ausente de dimensão (NULL).\nAlém disso, caso haja valores faltantes na base de dados (como, por exemplo, células vazias no Excel), esses serão representados por NA, sendo preservada a estrutura bidimensional do data frame.\nPor possuir duas dimensões, para acessarmos valores em um data frame, devemos especificar as linhas e colunas dentro de colchetes na seguinte ordem: [número da linha, número da coluna].\n\n# Elemento da 10ª linha e 1ª coluna\nPlantGrowth[10, 1]\n#&gt; [1] 5.14\n\nPodemos pegar todas as linhas de uma coluna ou todas as colunas de uma linha deixando um dos argumentos vazios.\n\n# Todas as linhas da 2ª coluna\nPlantGrowth[ ,2]\n#&gt;  [1] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl trt1 trt1 trt1 trt1 trt1\n#&gt; [16] trt1 trt1 trt1 trt1 trt1 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2\n#&gt; Levels: ctrl trt1 trt2\n\n# Todas as colunas da 2ª linhas\nPlantGrowth[2, ]\n#&gt;   weight group\n#&gt; 2   5.58  ctrl\n\nTambém conseguimos selecionar mais de uma linha e/ou coluna inserindo um vetor com as posições desejadas. No exemplo a seguir, selecionaremos as três primeiras observações da primeira coluna.\n\nPlantGrowth[c(1, 2, 3), 1]\n#&gt; [1] 4.17 5.58 5.18\n\nTambém é possível utilizar o nome de colunas para selecionar todas as suas observações.\n\nPlantGrowth[ , \"weight\"]\n#&gt;  [1] 4.17 5.58 5.18 6.11 4.50 4.61 5.17 4.53 5.33 5.14 4.81 4.17 4.41 3.59 5.87\n#&gt; [16] 3.83 6.03 4.89 4.32 4.69 6.31 5.12 5.54 5.50 5.37 5.29 4.92 6.15 5.80 5.26\n\nPlantGrowth[ , \"group\"]\n#&gt;  [1] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl trt1 trt1 trt1 trt1 trt1\n#&gt; [16] trt1 trt1 trt1 trt1 trt1 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2\n#&gt; Levels: ctrl trt1 trt2\n\nE, devido ao fato de que cada coluna do data frame é um vetor, podemos aplicar testes lógicos para filtrar linhas, assim como fizemos na Seção 3.8.\n\nPlantGrowth[PlantGrowth$weight &gt; 5.5, ]\n#&gt;    weight group\n#&gt; 2    5.58  ctrl\n#&gt; 4    6.11  ctrl\n#&gt; 15   5.87  trt1\n#&gt; 17   6.03  trt1\n#&gt; 21   6.31  trt2\n#&gt; 23   5.54  trt2\n#&gt; 28   6.15  trt2\n#&gt; 29   5.80  trt2\n\nNeste caso, a condição lógica imposta à coluna weight nos retorna todas as linhas que apresentam plantas com peso maior que 5,5.",
    "crumbs": [
      "Introdução",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Noções básicas em R</span>"
    ]
  },
  {
    "objectID": "basico.html#resumo",
    "href": "basico.html#resumo",
    "title": "3  Noções básicas em R",
    "section": "\n3.13 Resumo",
    "text": "3.13 Resumo\nCom as listas e data frames, finalizamos as noções básicas em R. Para aqueles que entraram em contato pela primeira vez com conceitos de programação, seja na linguagem que for, a teoria pode parecer complicada e maçante.\nMas a não compreensão de alguns conceitos expostos neste capítulo não será um impeditivo para continuar os estudos em ciência de dados em R. Sinta-se livre em replicar os códigos dos próximos capítulos, mesmo que não compreenda 100% do que está sendo feito em termos de programação.\nEm algumas ocasiões, você compreenderá melhor um conceito ao aplicá-lo na prática. Além disso, recomendo que você revisite este capítulo caso tenha alguma dúvida conceitual, ou senão, quando estiver mais familiarizado na programação em R.\nNos próximos capítulos, apresentaremos funções de pacotes que realizam muitas das funcionalidades apresentadas nesse capítulo, cuja lógica de programação é a mesma, porém, muito mais fáceis de serem compreendidas.\nPortanto, começaremos a aplicar ciência de dados na prática, iniciando pela importação de dados ao R.",
    "crumbs": [
      "Introdução",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Noções básicas em R</span>"
    ]
  },
  {
    "objectID": "importar.html",
    "href": "importar.html",
    "title": "4  Importação",
    "section": "",
    "text": "4.1 Introdução\nNeste capítulo, iniciaremos a primeira etapa para começarmos a aplicar ciência de dados: a importação dos dados para o R.\nFigura 4.1: A importação de dados é o primeiro passo para começarmos a trabalhar com ciência de dados.\nDevemos ter em mente que um conjunto de dados pode estar em diversos formatos, seja em planilhas, arquivos texto ou extensões de outros programas. Assim, para cada formato, haverá uma função específica de importação.\nComo citado na Seção 2.2.3, utilizar projetos no RStudio facilita a nossa vida para organizar, acessar e importar arquivos para o R. No decorrer deste capítulo, detalharemos sobre este processo a partir de um projeto. Portanto, caso ainda não tenha criado um, confira a seção.\nAo longo deste capítulo, utilizaremos um mesmo conjunto de dados em diversos formatos para que você possa acompanhar os exemplos a seguir. Para fazer o download dos arquivos clique aqui.",
    "crumbs": [
      "Preliminares",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Importação</span>"
    ]
  },
  {
    "objectID": "importar.html#caminhos",
    "href": "importar.html#caminhos",
    "title": "4  Importação",
    "section": "\n4.2 Caminhos",
    "text": "4.2 Caminhos\nAntes de importarmos um arquivo para o R, devemos saber onde ele se localiza no computador. Assim, devemos saber qual caminho indicar para que as funções de importação possam acessar os arquivos.\nTemos dois tipos de caminhos: o caminho absoluto e o caminho relativo.\nO caminho absoluto é aquele que tem início na pasta raiz do computador. Para verificá-lo, utilizamos a função getwd().\n\ngetwd()\n#&gt; [1] C:/Users/gustavojun/Documents/apostila-icdr\n\nComo exemplo, este material foi confeccionado no caminho C:/Users/gustavojun/Documents/apostila-icdr, ou seja, o diretório do projeto chamado apostila-icdr está localizado na pasta Documents, referente ao usuário gustavojun.\nCaso você tenha rodado a função getwd(), deve ter percebido que nossos caminhos absolutos são diferentes.\nPor outro lado, o caminho relativo tem como origem o diretório de trabalho do projeto em uso. Dessa forma, não precisamos passar o caminho absoluto para importarmos um arquivo.\nComo exemplo, ilustraremos a diferença entre os dois tipos de caminhos com o arquivo estudantes.xlsx presente na pasta dados do diretório do projeto.\n\nCaminho absoluto: C:/Users/gustavojun/Documents/apostila-icdr/dados/estudantes.xlsx;\nCaminho relativo: dados/estudantes.xlsx.\n\nDessa forma, além de facilitar e tornar o código mais legível, o caminho relativo permite um código reprodutível à qualquer pessoa e em qualquer computador, uma vez que o meu caminho absoluto é, muito provavelmente, diferente do seu e de outros usuário.\nPortanto, utilizar projetos no RStudio nos possibilita usar os caminhos relativos - independentemente do caminho absoluto, facilitando a importação de dados e tornando o código reprodutível. Nos exemplos a seguir, utilizaremos apenas os caminhos relativos para importar arquivos.",
    "crumbs": [
      "Preliminares",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Importação</span>"
    ]
  },
  {
    "objectID": "importar.html#planilhas-excel",
    "href": "importar.html#planilhas-excel",
    "title": "4  Importação",
    "section": "\n4.3 Planilhas Excel",
    "text": "4.3 Planilhas Excel\nEm muitos casos, um conjunto de dados está disponível em planilhas Excel, sejam de terceiros ou construídos pelo próprio cientista de dados. Para tanto, o pacote readxl possui funções para trabalhar com este tipo de arquivo.\nO readxl faz parte do tidyverse, portanto, uma vez instalado o pacote tidyverse, precisamos apenas carregá-lo.\n\nlibrary(readxl)\n\n\n4.3.1 Importação de planilha Excel\nA principal função do readxl é a read_excel(), que lê e importa arquivos Excel, seja no formato .xls ou .xlsx, identificando, automaticamente, qual a extensão do arquivo.\n\nestudantes &lt;- read_excel(path = \"dados/estudantes.xlsx\")\n\nDentro da função read_excel(), informamos no argumento path = o caminho relativo até o arquivo. No exemplo, o arquivo Excel estudantes.xlsx está localizado na pasta dados do diretório do projeto em uso.\n\nestudantes\n#&gt; # A tibble: 6 × 5\n#&gt;   NOME     Sobrenome SEXO      IDADE curso_graduação\n#&gt;   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;          \n#&gt; 1 Ricardo  Silva     Masculino 23    Biologia       \n#&gt; 2 Maria    Pereira   Feminino  ?     Agronomia      \n#&gt; 3 Pedro    Costa     Masculino 21    Agronomia      \n#&gt; 4 Joana    Silva     Feminino  19    Biologia       \n#&gt; 5 Leticia  Gomes     Feminino  24    Agronomia      \n#&gt; 6 Jonathan Macedo    Masculino 25    Biologia\n\nA função read_excel() importa os dados no formato de tibble, que nada mais é do que uma versão aperfeiçoada dos data frames. No Capítulo 5 veremos mais detalhes sobre as tibbles. Neste momento, considere a tibble uma análoga do data frame tradicional.\nAlém disso, nos é informado as dimensões do banco de dados (6 linhas e 5 colunas), o nome das variáveis e as suas respectivas classes.\nAo analisar a planilha importada, notamos algumas inconsistências nos dados. Para isso, a função read_excel() apresenta alguns argumentos que nos auxiliam na sua organização prévia à importação. A seguir, listaremos algumas das possíveis funcionalidades.\n1. Nome das variáveis: o argumento col_names = permite alterar os nomes das variáveis ou, no caso de conjuntos de dados que não possuem variáveis nomeadas, criá-los. Para isso, passamos um vetor com os novos nomes.\n\nread_excel(\n  path = \"dados/estudantes.xlsx\",\n  col_names = c(\"nome\", \"sobrenome\", \"sexo\", \"idade\", \"curso\")\n)\n#&gt; # A tibble: 7 × 5\n#&gt;   nome     sobrenome sexo      idade curso          \n#&gt;   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;          \n#&gt; 1 NOME     Sobrenome SEXO      IDADE curso_graduação\n#&gt; 2 Ricardo  Silva     Masculino 23    Biologia       \n#&gt; 3 Maria    Pereira   Feminino  ?     Agronomia      \n#&gt; 4 Pedro    Costa     Masculino 21    Agronomia      \n#&gt; 5 Joana    Silva     Feminino  19    Biologia       \n#&gt; 6 Leticia  Gomes     Feminino  24    Agronomia      \n#&gt; 7 Jonathan Macedo    Masculino 25    Biologia\n\nPerceba que os nomes foram alterados, porém os antigos permaneceram como observações da primeira linha. Para isso, utilizamos o argumento skip =, que pula linhas do começo da planilha.\n\nread_excel(\n  path = \"dados/estudantes.xlsx\",\n  col_names = c(\"nome\", \"sobrenome\", \"sexo\", \"idade\", \"curso\"),\n  skip = 1\n)\n#&gt; # A tibble: 6 × 5\n#&gt;   nome     sobrenome sexo      idade curso    \n#&gt;   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;    \n#&gt; 1 Ricardo  Silva     Masculino 23    Biologia \n#&gt; 2 Maria    Pereira   Feminino  ?     Agronomia\n#&gt; 3 Pedro    Costa     Masculino 21    Agronomia\n#&gt; 4 Joana    Silva     Feminino  19    Biologia \n#&gt; 5 Leticia  Gomes     Feminino  24    Agronomia\n#&gt; 6 Jonathan Macedo    Masculino 25    Biologia\n\n2. Valores ausentes (NA): na variável idade, temos uma observação cuja informação não está disponível, ou seja, um valor NA (Seção 3.9). Contudo, essa informação está representada pelo caractere ?. A presença deste caractere faz com que a variável idade (de classe numérica) seja classificada como um vetor do tipo caractere (&lt;chr&gt;) devido ao comportamento de coersão (vide Seção 3.6).\nPara substitui-lo, utilizamos o argumento na =, declarando qual caractere desejamos substituir por NA.\n\nread_excel(\n  path = \"dados/estudantes.xlsx\",\n  col_names = c(\"nome\", \"sobrenome\", \"sexo\", \"idade\", \"curso\"),\n  skip = 1,\n  na = \"?\"\n)\n#&gt; # A tibble: 6 × 5\n#&gt;   nome     sobrenome sexo      idade curso    \n#&gt;   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;    \n#&gt; 1 Ricardo  Silva     Masculino    23 Biologia \n#&gt; 2 Maria    Pereira   Feminino     NA Agronomia\n#&gt; 3 Pedro    Costa     Masculino    21 Agronomia\n#&gt; 4 Joana    Silva     Feminino     19 Biologia \n#&gt; 5 Leticia  Gomes     Feminino     24 Agronomia\n#&gt; 6 Jonathan Macedo    Masculino    25 Biologia\n\nAo substituir o caractere ? por NA, a classe da variável \"idade\" passa a ser numérica (&lt;dbl&gt;) automaticamente.\n3. Classe das variáveis: também poderíamos resolver a questão anterior trocando a classe da variável. Para isso, utilizamos o argumento col_types =, declarando um vetor com as classes desejadas para todas as variáveis.\nEste argumento nos permite atribuir quatro tipos de classes:\n\n\"text\": converte para a classe do tipo caractere;\n\"numeric\": converte em valores numéricos;\n\"date\": converte em datas;\n\"skip\": pula colunas, excluindo-as da importação.\n\n\nestudantes_modificado &lt;- read_excel(\n  path = \"dados/estudantes.xlsx\",\n  col_names = c(\"nome\", \"sobrenome\", \"sexo\", \"idade\", \"curso\"),\n  skip = 1,\n  col_types = c(\"text\", \"text\", \"text\", \"numeric\", \"text\")\n)\n\nestudantes_modificado\n#&gt; # A tibble: 6 × 5\n#&gt;   nome     sobrenome sexo      idade curso    \n#&gt;   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;    \n#&gt; 1 Ricardo  Silva     Masculino    23 Biologia \n#&gt; 2 Maria    Pereira   Feminino     NA Agronomia\n#&gt; 3 Pedro    Costa     Masculino    21 Agronomia\n#&gt; 4 Joana    Silva     Feminino     19 Biologia \n#&gt; 5 Leticia  Gomes     Feminino     24 Agronomia\n#&gt; 6 Jonathan Macedo    Masculino    25 Biologia\n\nAo converter a classe da variável idade para numérica, atribuiu-se o NA para todos os valores não numéricos (no caso, o caractere ?).\nPor fim, salvamos as alterações finais no objeto chamado estudantes_modificado.\nO exemplo anterior ilustrou um processo bem comum na rotina de análise de dados. Muitas planilhas as quais nos deparamos apresentam algumas (ou muitas) inconsistências para a importação ao R e, consequentemente, para sua análise.\nO R apresenta ferramentas capazes de lidar com diversos tipos de problemas em importação dos dados. Para isso, temos que identificar os problemas e fazer os ajustes necessários até chegar na formatação de dados ideal para analisá-los. No Capítulo 5 abordaremos com mais detalhes a lógica da organização de dados, além de ferramentas complementares às apresentadas até agora.\n\n4.3.2 Importação de diversas planilhas\nEm alguns casos, um arquivo Excel pode conter diversas planilhas. Para verificar quais planilhas estão presentes, utilizamos a função excel_sheets(), também do pacote readxl.\n\nexcel_sheets(path = \"dados/estudantes.xlsx\")\n#&gt; [1] \"Geral\"     \"Notas\"     \"Resultado\"\n\nO mesmo arquivo utilizado anteriormente (estudantes.xlsx) apresenta três planilhas: \"Geral\", \"Notas\" e \"Resultado\".\nPor padrão, a função importa a primeira planilha presente no arquivo. Dessa forma, nos exemplos anteriores, trabalhamos com a planilha \"Geral\".\nPara selecionar as demais planilhas, devemos utilizar o argumento sheet = dentro da função read_excel() e informar seu nome entre aspas.\n\nread_excel(path = \"dados/estudantes.xlsx\", sheet = \"Geral\")\n#&gt; # A tibble: 6 × 5\n#&gt;   NOME     Sobrenome SEXO      IDADE curso_graduação\n#&gt;   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;          \n#&gt; 1 Ricardo  Silva     Masculino 23    Biologia       \n#&gt; 2 Maria    Pereira   Feminino  ?     Agronomia      \n#&gt; 3 Pedro    Costa     Masculino 21    Agronomia      \n#&gt; 4 Joana    Silva     Feminino  19    Biologia       \n#&gt; 5 Leticia  Gomes     Feminino  24    Agronomia      \n#&gt; 6 Jonathan Macedo    Masculino 25    Biologia\n\n\nread_excel(path = \"dados/estudantes.xlsx\", sheet = \"Notas\")\n#&gt; # A tibble: 6 × 4\n#&gt;   nome     sobrenome prova1 prova2\n#&gt;   &lt;chr&gt;    &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1 Ricardo  Silva        8      7  \n#&gt; 2 Maria    Pereira      2      7.5\n#&gt; 3 Pedro    Costa        7.8    7  \n#&gt; 4 Joana    Silva        6      6.7\n#&gt; 5 Leticia  Gomes        9.5   10  \n#&gt; 6 Jonathan Macedo       9      8\n\n\nread_excel(path = \"dados/estudantes.xlsx\", sheet = \"Resultado\")\n#&gt; # A tibble: 12 × 4\n#&gt;    `Resultado final da disciplina estatística geral`      ...2      ...3   ...4 \n#&gt;    &lt;chr&gt;                                                  &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;\n#&gt;  1 &lt;NA&gt;                                                   &lt;NA&gt;      &lt;NA&gt;   &lt;NA&gt; \n#&gt;  2 nome                                                   sobrenome nota_… resu…\n#&gt;  3 Ricardo                                                Silva     7.5    Apro…\n#&gt;  4 Maria                                                  Pereira   4.75   Recu…\n#&gt;  5 Pedro                                                  Costa     7.4    Apro…\n#&gt;  6 Joana                                                  Silva     6.35   Apro…\n#&gt;  7 Leticia                                                Gomes     9.75   Apro…\n#&gt;  8 Jonathan                                               Macedo    8.5    Apro…\n#&gt;  9 &lt;NA&gt;                                                   &lt;NA&gt;      &lt;NA&gt;   &lt;NA&gt; \n#&gt; 10 Observação:                                            &lt;NA&gt;      &lt;NA&gt;   &lt;NA&gt; \n#&gt; 11 O resultado final é a média aritmética das duas provas &lt;NA&gt;      &lt;NA&gt;   &lt;NA&gt; \n#&gt; 12 Alunos com média inferior a 5 ficam de recuperação     &lt;NA&gt;      &lt;NA&gt;   &lt;NA&gt;\n\nVocê deve ter notado que a planilha \"Resultado\" foi importada de maneira estranha. Isso se deve a um caso de formatação de incorreta dos dados. Vamos analisar como esta planilha se apresenta no Excel.\n\n\n\n\n\n\n\n\nA planilha \"Resultado\" apresenta comentários que não fazem parte do conjunto de dados, o que interferiu no momento em que a importamos para o R.\nPara contornar este problema, podemos utilizar os argumentos skip = para pular linhas do começo da planilha e o n_max =, para selecionar o número máximo de linhas.\n\nread_excel(\n  path = \"dados/estudantes.xlsx\", sheet = \"Resultado\",\n  skip = 2, \n  n_max = 7\n)\n#&gt; # A tibble: 6 × 4\n#&gt;   nome     sobrenome nota_final resultado  \n#&gt;   &lt;chr&gt;    &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;      \n#&gt; 1 Ricardo  Silva           7.5  Aprovado   \n#&gt; 2 Maria    Pereira         4.75 Recuperação\n#&gt; 3 Pedro    Costa           7.4  Aprovado   \n#&gt; 4 Joana    Silva           6.35 Aprovado   \n#&gt; 5 Leticia  Gomes           9.75 Aprovado   \n#&gt; 6 Jonathan Macedo          8.5  Aprovado\n\nPrimeiramente, com o argumento skip = 2, pulamos as duas primeiras linhas da planilha. Em seguida, agora sem contar as duas linhas puladas, selecionamos as primeiras sete linhas com o n_max = 7.\nTambém podemos utilizar o argumento range = para selecionar um intervalo de células do Excel.\n\nestudantes_resultado &lt;- read_excel(\n  path = \"dados/estudantes.xlsx\", sheet = \"Resultado\",\n  range = \"A3:D9\"\n)\n\nestudantes_resultado\n#&gt; # A tibble: 6 × 4\n#&gt;   nome     sobrenome nota_final resultado  \n#&gt;   &lt;chr&gt;    &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;      \n#&gt; 1 Ricardo  Silva           7.5  Aprovado   \n#&gt; 2 Maria    Pereira         4.75 Recuperação\n#&gt; 3 Pedro    Costa           7.4  Aprovado   \n#&gt; 4 Joana    Silva           6.35 Aprovado   \n#&gt; 5 Leticia  Gomes           9.75 Aprovado   \n#&gt; 6 Jonathan Macedo          8.5  Aprovado\n\nPor fim, guardamos as alterações finais da planilha \"Resultado\" no objeto chamado estudantes_resultado.\nAo analisar as três planilhas, nota-se que poderíamos juntá-las em uma única, pois apresentam informações que se relacionam entre si. No ?sec-join, veremos como juntá-las em um único data frame.\n\n4.3.3 Salvar planilhas Excel\nApós importar e ajustar os dados no R, podemos salvar as alterações em um novo arquivo Excel no formato .xlsx. Para isso, utilizamos o pacote openxlsx.\nEste pacote não faz parte do tidyverse, portanto, antes de carregar, precisamos instalá-lo.\n\ninstall.packages(\"openxlsx\")\n\n\nlibrary(openxlsx)\n\nPara salvar os dados em um arquivo Excel, utilizamos a função write.xlsx().\n\nwrite.xlsx(x = estudantes_resultado, file = \"dados/estudantes_resultado.xlsx\")\n\nNo argumento x = declaramos o nome do objeto que desejamos salvar e no file =, o caminho onde se deseja criar o arquivo e seu nome.\nNo exemplo, salvamos o objeto estudantes_resultado no arquivo chamado estudantes_resultado.xlsx, criado na pasta dados do diretório do projeto.\nPara salvar mais de um objeto em diferentes planilhas de um mesmo arquivo Excel, criamos uma lista (list()) com os nomes das planilhas, indicando com o operador = qual objeto desejamos salvar.\nNo exemplo a seguir, criaremos um novo arquivo com as planilhas corrigidas anteriormente. Apenas a planilha \"Notas\" não precisou de alterações, bastando importar e salvá-la em um objeto para podermos criarmos o novo arquivo.\n\nestudantes_notas &lt;- read_excel(path = \"dados/estudantes.xlsx\", sheet = \"Notas\")\n\n\nplanilhas &lt;- list(\n  \"Geral\" = estudantes_modificado, \n  \"Notas\" = estudantes_notas,\n  \"Resultado\" = estudantes_resultado\n)\n\n\nwrite.xlsx(x = planilhas, file = \"dados/estudantes_corrigido.xlsx\")\n\nDessa forma, salvamos os objetos estudantes_modificado, estudantes_notas e estudantes_resultado em um novo arquivo chamado estudantes_corrigido.xlsx, mantendo os nomes originais das planilhas, \"Geral\", \"Notas\" e \"Resultado\".\nVale destacar que nunca devemos sobrescrever (substituir) o arquivo ou as planilhas originais pelos novos, pois podemos perder informações importantes, além de impossibilitar a reprodutibilidade do código, caso seja preciso realizar outras modificações a partir do arquivo original. Dessa forma, sempre crie um novo arquivo e com outro nome.\nPara ver o resultado final das planilhas com as correções, podemos verificar no próprio arquivo Excel estudantes_corrigido.xlsx ou importá-las para o R.\n\nread_excel(path = \"dados/estudantes_corrigido.xlsx\", sheet = \"Geral\")\n#&gt; # A tibble: 6 × 5\n#&gt;   nome     sobrenome sexo      idade curso    \n#&gt;   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;    \n#&gt; 1 Ricardo  Silva     Masculino    23 Biologia \n#&gt; 2 Maria    Pereira   Feminino     NA Agronomia\n#&gt; 3 Pedro    Costa     Masculino    21 Agronomia\n#&gt; 4 Joana    Silva     Feminino     19 Biologia \n#&gt; 5 Leticia  Gomes     Feminino     24 Agronomia\n#&gt; 6 Jonathan Macedo    Masculino    25 Biologia\n\nread_excel(path = \"dados/estudantes_corrigido.xlsx\", sheet = \"Notas\")\n#&gt; # A tibble: 6 × 4\n#&gt;   nome     sobrenome prova1 prova2\n#&gt;   &lt;chr&gt;    &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1 Ricardo  Silva        8      7  \n#&gt; 2 Maria    Pereira      2      7.5\n#&gt; 3 Pedro    Costa        7.8    7  \n#&gt; 4 Joana    Silva        6      6.7\n#&gt; 5 Leticia  Gomes        9.5   10  \n#&gt; 6 Jonathan Macedo       9      8\n\nread_excel(path = \"dados/estudantes_corrigido.xlsx\", sheet = \"Resultado\")\n#&gt; # A tibble: 6 × 4\n#&gt;   nome     sobrenome nota_final resultado  \n#&gt;   &lt;chr&gt;    &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;      \n#&gt; 1 Ricardo  Silva           7.5  Aprovado   \n#&gt; 2 Maria    Pereira         4.75 Recuperação\n#&gt; 3 Pedro    Costa           7.4  Aprovado   \n#&gt; 4 Joana    Silva           6.35 Aprovado   \n#&gt; 5 Leticia  Gomes           9.75 Aprovado   \n#&gt; 6 Jonathan Macedo          8.5  Aprovado\n\nNesta seção, trabalhamos com planilhas Excel alocadas em nosso computador. Contudo, vale destacar que também é possível importar planilhas online diretamente do R. O pacote googlesheets4, que faz parte do tidyverse, permite acessar as planilhas do Google Sheets. Você pode conhecer mais sobre este pacote acessando sua documentação em https://googlesheets4.tidyverse.org/.",
    "crumbs": [
      "Preliminares",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Importação</span>"
    ]
  },
  {
    "objectID": "importar.html#arquivos-texto",
    "href": "importar.html#arquivos-texto",
    "title": "4  Importação",
    "section": "\n4.4 Arquivos texto",
    "text": "4.4 Arquivos texto\nOs arquivos texto são aqueles em que as variáveis das observações são separadas por algum delimitador. Comumente, possuem extensão nos formatos .csv ou .txt.\nO delimitador pode ser qualquer operador, como vírgulas, ponto-e-vírgulas, espaços, tabulação (Tab) ou um operador genérico.\nDe acordo com o delimitador, utilizaremos uma função ou argumentos específicos para importar este tipo de arquivo. Para isso, o pacote readr, que também faz parte do tidyverse, traz as principais ferramentas necessárias.\n\nlibrary(readr)\n\n\n4.4.1 Importação de arquivos texto\nAs funções de importação de arquivos texto a partir do readr possuem a sintaxe read_(). A Tabela 4.1 traz as principais funções de acordo com o delimitador, operador do delimitador e formato do arquivo.\n\n\nTabela 4.1: Principais funções de importação de arquivos texto do pacote readr.\n\n\n\nFunção\nDelimitador\nOperador\nArquivo\n\n\n\nread_csv()\nVírgula\n\",\"\n.csv\n\n\nread_csv2()\nPonto-e-vírgula\n\";\"\n.csv\n\n\nread_tsv()\nTabulação\n\"\\t\"\n\n.txt e .csv\n\n\n\nread_delim()\nDelimitador genérico\ndelim =\n\n.txt e .csv\n\n\n\nread_table()\nEspaço\n\" \"\n\n.txt e .csv\n\n\n\n\n\n\n\nNo caso da função read_delim(), devemos utilizar o argumento delim = para indicar qual caractere é o delimitador.\nComo exemplo, importaremos um arquivo .csv (estudantes.csv), utilizando a função read_csv(), cujo delimitador é a vírgula.\n\n\n\n\n\n\n\n\n\nread_csv(file = \"dados/estudantes.csv\")\n#&gt; # A tibble: 6 × 5\n#&gt;   NOME     Sobrenome SEXO      IDADE curso_graduação\n#&gt;   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;          \n#&gt; 1 Ricardo  Silva     Masculino 23    Biologia       \n#&gt; 2 Maria    Pereira   Feminino  ?     Agronomia      \n#&gt; 3 Pedro    Costa     Masculino 21    Agronomia      \n#&gt; 4 Joana    Silva     Feminino  19    Biologia       \n#&gt; 5 Leticia  Gomes     Feminino  24    Agronomia      \n#&gt; 6 Jonathan Macedo    Masculino 25    Biologia\n\nDentro da função read_csv(), declaramos o argumento file = com o caminho relativo até o arquivo (análogo ao path = da função readxl::read_excel()). Novamente, os dados são importados como tibbles (Capítulo 5).\nAlém disso, nos é informado as dimensões do conjunto de dados (6 linhas e 5 colunas), o nome das variáveis e as suas respectivas classes.\nCaso seu arquivo .csv seja delimitado por ponto-e-vírgula, basta proceder da mesma maneira, porém utilizando a função read_csv2().\nNo caso de arquivos .txt, utilizamos a função read_delim(), sendo necessário indicar qual caractere é utilizado como delimitador.\nNo exemplo a seguir, importaremos um arquivo .txt, separado por tabulação. Para isso, com o argumento delim =, informamos qual o delimitador a ser considerado (no caso, o \"\\t\" para a tabulação).\n\n\n\n\n\n\n\n\n\nread_delim(file = \"dados/estudantes.txt\", delim = \"\\t\")\n#&gt; # A tibble: 6 × 5\n#&gt;   NOME     Sobrenome SEXO      IDADE curso_graduação\n#&gt;   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;          \n#&gt; 1 Ricardo  Silva     Masculino 23    Biologia       \n#&gt; 2 Maria    Pereira   Feminino  ?     Agronomia      \n#&gt; 3 Pedro    Costa     Masculino 21    Agronomia      \n#&gt; 4 Joana    Silva     Feminino  19    Biologia       \n#&gt; 5 Leticia  Gomes     Feminino  24    Agronomia      \n#&gt; 6 Jonathan Macedo    Masculino 25    Biologia\n\nTambém podemos importar o arquivo anterior a partir da função read_tsv(), uma vez que o delimitador é a tabulação. Assim, não precisamos utilizar o argumento delim =.\n\nread_tsv(file = \"dados/estudantes.txt\")\n#&gt; # A tibble: 6 × 5\n#&gt;   NOME     Sobrenome SEXO      IDADE curso_graduação\n#&gt;   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;          \n#&gt; 1 Ricardo  Silva     Masculino 23    Biologia       \n#&gt; 2 Maria    Pereira   Feminino  ?     Agronomia      \n#&gt; 3 Pedro    Costa     Masculino 21    Agronomia      \n#&gt; 4 Joana    Silva     Feminino  19    Biologia       \n#&gt; 5 Leticia  Gomes     Feminino  24    Agronomia      \n#&gt; 6 Jonathan Macedo    Masculino 25    Biologia\n\nDe maneira geral, as funções de importação de arquivos texto funcionam da mesma forma, alterando apenas o nome da função, o delimitador e o tipo de arquivo a ser considerado.\nAs funções do pacote readr também apresentam argumentos específicos para organizar os dados antes de serem importados, muitos deles idênticos aos do pacote readxl (Seção 4.3.1). A seguir, ilustraremos tais argumentos com a função read_csv().\n\nread_csv(\n  file = \"dados/estudantes.csv\",\n  col_names = c(\"nome\", \"sobrenome\", \"sexo\", \"idade\", \"curso\"),\n  skip = 1,\n  na = \"?\"\n)\n#&gt; # A tibble: 6 × 5\n#&gt;   nome     sobrenome sexo      idade curso    \n#&gt;   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;    \n#&gt; 1 Ricardo  Silva     Masculino    23 Biologia \n#&gt; 2 Maria    Pereira   Feminino     NA Agronomia\n#&gt; 3 Pedro    Costa     Masculino    21 Agronomia\n#&gt; 4 Joana    Silva     Feminino     19 Biologia \n#&gt; 5 Leticia  Gomes     Feminino     24 Agronomia\n#&gt; 6 Jonathan Macedo    Masculino    25 Biologia\n\nContudo, há uma diferença significativa no argumento que altera a classe das colunas. O pacote readr adota uma estrutura mais flexível para o col_types =, permitindo especificar apenas as colunas cuja classe desejamos modificar. Na Seção 4.3.1, ao utilizar a função readxl::read_excel(), era necessário declarar um vetor ordenado com as classes de todas as variáveis, inclusive daquelas que não precisavam de alteração. Isso pode ser inconveniente em conjuntos de dados com muitas variáveis, mas poucas que requerem modificação.\nPara isso, em col_types = cols() indicamos o nome da variável a ser alterada, seguida do operador = e a classe a ser atribuída (nome_variável = col_()).\n\nread_csv(\n  file = \"dados/estudantes.csv\",\n  col_names = c(\"nome\", \"sobrenome\", \"sexo\", \"idade\", \"curso\"),\n  skip = 1,\n  col_types = cols(idade = col_double())\n)\n#&gt; # A tibble: 6 × 5\n#&gt;   nome     sobrenome sexo      idade curso    \n#&gt;   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;    \n#&gt; 1 Ricardo  Silva     Masculino    23 Biologia \n#&gt; 2 Maria    Pereira   Feminino     NA Agronomia\n#&gt; 3 Pedro    Costa     Masculino    21 Agronomia\n#&gt; 4 Joana    Silva     Feminino     19 Biologia \n#&gt; 5 Leticia  Gomes     Feminino     24 Agronomia\n#&gt; 6 Jonathan Macedo    Masculino    25 Biologia\n\nComo classes disponíveis, temos uma maior variedade neste pacote:\n\ncol_integer() e col_double() converte em valores numéricos inteiros e reais, respectivamente;\ncol_character() converte para a classe do tipo caractere;\ncol_logical() converte em valores lógicos;\ncol_factor() converte para a classe do tipo fator;\ncol_date() col_time() e col_datetime() converte em datas, tempo e datas-tempo, respectivamente;\ncol_skip() pula colunas, excluindo-as da importação.\n\n4.4.2 Salvar arquivos texto\nPara salvar dados do R em arquivos texto, utilizamos um conjunto de funções write_() do pacote readr. A Tabela 4.2 traz estas funções, junto às especificações.\n\n\nTabela 4.2: Principais funções write_() do pacote readr.\n\n\n\n\n\n\n\n\n\nFunção\nArgumentos\nDelimitador\nArquivo\n\n\n\nwrite_csv()\n\nx = , file =\n\nVírgula\n.csv\n\n\nwrite_csv2()\n\nx = , file =\n\nPonto-e-vírgula\n.csv\n\n\nwrite_delim()\n\nx = , file = , delim =\n\nDiversos\n\n.txt e .csv\n\n\n\n\n\n\n\nEstas funções são compostas pelos argumentos x = e file =, referentes ao objeto a ser salvo e ao caminho onde se deseja criar o arquivo, respectivamente. Com a função write_delim(), devemos especificar no argumento delim = qual o delimitador a ser considerado.\nNos exemplos a seguir, salvaremos dados nos formatos .csv e .txt. Utilizaremos um conjunto de dados nativo do R, o mtcars.\n\nhead(mtcars)\n#&gt;                    mpg cyl disp  hp drat    wt  qsec vs am gear carb\n#&gt; Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\n#&gt; Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\n#&gt; Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n#&gt; Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\n#&gt; Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\n#&gt; Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\n# Arquivo .csv separado por vírgula\nwrite_csv(x = mtcars, file = \"dados/mtcars.csv\")\n\n\n# Arquivo .csv separado por ponto-e-vírgula\nwrite_csv2(x = mtcars, file = \"dados/mtcars.csv\")\n\n\n# Arquivo .txt, separado por tabulação\nwrite_delim(x = mtcars, file = \"dados/mtcars.txt\", delim = \"\\t\")",
    "crumbs": [
      "Preliminares",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Importação</span>"
    ]
  },
  {
    "objectID": "importar.html#atalho-import-dataset",
    "href": "importar.html#atalho-import-dataset",
    "title": "4  Importação",
    "section": "\n4.5 Atalho Import Dataset\n",
    "text": "4.5 Atalho Import Dataset\n\nO RStudio traz um atalho muito útil para importarmos dados ao R. Trata-se do Import Dataset, presente na janela Environment.\n\n\n\n\n\n\n\nFigura 4.2: Com o atalho Import Dataset, podemos realizar a importação de dados de diversas extensões, de forma intuitiva e prática.\n\n\n\n\nO Import Dataset nos permite importar arquivos de diversas extensões, como ilustra a Figura 4.2. A seguir, listaremos as opções.\n\nFrom Text (base) e From Text (readr) realizam a importação de arquivos texto. A primeira utiliza as funções base do R, enquanto a outra, as do pacote readr;\nFrom Excel importa planilhas Excel nos formatos .xls ou .xlsx, utilizando o pacote readxl;\nFrom SPSS, From SAS e From Stata realizam a importação de arquivos dos programas SPSS, SAS e Stata, utilizando o pacote haven que também faz parte do tidyverse. Neste material, não entraremos em detalhes sobre estes tipos de arquivos, porém, destaca-se que a sintaxe de funções é praticamente a mesma do demonstrado neste material. Mais informações sobre o pacote haven estão disponíveis em https://haven.tidyverse.org/.\n\nAo selecionar uma das opções, será aberta uma nova janela onde podemos colocar diversas especificações. Exemplificaremos com a importação de arquivo Excel.\nPrimeiramente, clicando em Browse…, devemos selecionar o arquivo a ser importado.\n\n\n\n\n\n\n\n\nSelecionado o arquivo, são apresentadas prévias dos dados e do código de importação.\n\n\n\n\n\n\n\n\nTambém podemos realizar algumas alterações nos dados antes de importá-los. A janela Import Options traz os possíveis argumentos da função de importação. Além disso, clicando no nome das variáveis, podemos alterar as suas respectivas classes. Ao realizar as alterações, perceba que a prévia do código também é atualizada.\n\n\n\n\n\n\n\n\nPara importar os dados, clicamos em Import. Também podemos copiar o código clicando no ícone do canto superior direito em Code Preview e colocá-lo no script.\n\n\n\n\n\n\n\n\nUtilizar o atalho Import Dataset facilita a tarefa de importação de dados, pois é uma ferramenta visual que nos traz as prévias das ações realizadas antes de importarmos os dados.\nOs conceitos vistos ao longo do capítulo são importantes para conhecermos as opções de argumentos, ter noção sobre as diferenças entre os tipos de arquivos, além de compreender toda a lógica envolvida. Dessa maneira, o Import Dataset se apresenta como um facilitador do aprendizado de importação de dados para o R.",
    "crumbs": [
      "Preliminares",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Importação</span>"
    ]
  },
  {
    "objectID": "importar.html#arquivos-.rds",
    "href": "importar.html#arquivos-.rds",
    "title": "4  Importação",
    "section": "\n4.6 Arquivos .rds\n",
    "text": "4.6 Arquivos .rds\n\nO R possui uma extensão própria de arquivo para armazenar qualquer tipo de objeto do R. Trata-se dos arquivos .rds ou .RDS.\nPara salvar um objeto no formato .rds, utilizamos a função write_rds() do pacote readr. Como exemplo, salvaremos o arquivo estudantes.csv neste formato.\n\nestudantes &lt;- read_csv(file = \"dados/estudantes.csv\")\n\nwrite_rds(x = estudantes, file = \"dados/estudantes.rds\", compress = \"gz\")\n\nPara importar o novo arquivo criado, utilizamos a função read_rds(), também do pacote readr.\n\nread_rds(file = \"dados/estudantes.rds\")\n#&gt; # A tibble: 6 × 5\n#&gt;   NOME     Sobrenome SEXO      IDADE curso_graduação\n#&gt;   &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;          \n#&gt; 1 Ricardo  Silva     Masculino 23    Biologia       \n#&gt; 2 Maria    Pereira   Feminino  ?     Agronomia      \n#&gt; 3 Pedro    Costa     Masculino 21    Agronomia      \n#&gt; 4 Joana    Silva     Feminino  19    Biologia       \n#&gt; 5 Leticia  Gomes     Feminino  24    Agronomia      \n#&gt; 6 Jonathan Macedo    Masculino 25    Biologia\n\nA vantagem de utilizar a extensão .rds é a possibilidade de compactar o arquivo e deixá-lo mais “leve” (ocupa menor espaço de armazenamento), o que torna a importação dos dados mais rápida, principalmente quando utilizamos arquivos grandes. Realizamos a compactação com o argumento compress = na função write_rds().\nAlém disso, por se tratar de um arquivo próprio do R, é totalmente compatível com qualquer ação realizada dentro do software, preservando a estrutura dos dados quando importamos.\nEm alguns casos, quando salvamos um objeto em um arquivo texto ou Excel, podem ocorrer algumas alterações quando os importamos de volta, como alterar a classe especificada para as colunas. Salvar em um arquivo .rds evita este tipo de problema.\nContudo, só podemos utilizar este tipo de arquivo no R. Caso queira utilizar dados construídos no R em outro programa, devemos utilizar outra extensão de arquivo, como os arquivos .parquet do pacote arrow.",
    "crumbs": [
      "Preliminares",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Importação</span>"
    ]
  },
  {
    "objectID": "importar.html#bancos-de-dados",
    "href": "importar.html#bancos-de-dados",
    "title": "4  Importação",
    "section": "\n4.7 Bancos de dados",
    "text": "4.7 Bancos de dados\nA seguir, listaremos alguns sites que fornecem uma grande variedade de base de dados públicas. Confira alguma que apresente dados de seu interesse para que possa aplicar, futuramente, os conceitos aprendidos neste material.\n\nFAOSTAT: https://www.fao.org/faostat/en/#data;\nIBGE: https://sidra.ibge.gov.br/home/;\nDataBank: https://databank.worldbank.org/databases;\nKaggle: https://www.kaggle.com/datasets;\nDados do Agro: https://dados.agr.br/fonte-de-dados/.",
    "crumbs": [
      "Preliminares",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Importação</span>"
    ]
  },
  {
    "objectID": "importar.html#resumo",
    "href": "importar.html#resumo",
    "title": "4  Importação",
    "section": "\n4.8 Resumo",
    "text": "4.8 Resumo\nComo visto, a importação de dados para o R não é uma tarefa difícil. Devemos nos atentar ao formato do arquivo, a fim de utilizar a função de importação correta. Em alguns casos, nos depararemos com arquivos cuja configuração de dados é incompatível com a importação ao R. Para isso, as funções de importação apresentam argumentos que reparam a maioria dos problemas. Por fim, também vimos funções que salvam os dados do R para diversos formatos de arquivos.\nNo próximo capítulo, trataremos sobre a etapa de organizar. Apresentaremos as tibbles, um tipo especial de data frame, além de explorarmos as funcionalidades presentes no pacote tidyr, a fim de obtermos uma base de dados organizada e fácil de se trabalhar.",
    "crumbs": [
      "Preliminares",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Importação</span>"
    ]
  },
  {
    "objectID": "arrumar.html",
    "href": "arrumar.html",
    "title": "5  Organização",
    "section": "",
    "text": "5.1 Introdução\nNeste capítulo, trataremos sobre a organização dos dados, seguindo o conceito conhecido como tidy data (dados arrumados), cujo objetivo é ajustar os dados em uma estrutura consistente e padronizada.\nNormalmente, costuma ser trabalhoso o processo de organizar os dados, mas, com o auxílio das ferramentas do tidyverse, conseguimos obter bons resultados que, em longo prazo, nos permite ter mais tempo e facilidade para executar as etapas seguintes.\nComo o próprio nome do pacote sugere, o tidyverse é baseado nos princípios de uma tidy data. Por isso, seus pacotes foram desenvolvidos para funcionarem seguindo tal princípio e serem complementares entre si.\nNo Capítulo 4, demos início ao processo de organização, seguido da importação dos dados ao R no formato de tibble. Neste capítulo, abordaremos com mais detalhes sobre o pacote tibble, além de apresentar outras ferramentas de organização dos dados, presentes no pacote tidyr.\nFigura 5.1: A etapa de arrumar, ou organizar, os dados visa obter uma estrutura consistente e padronizada de dados, a fim de nos auxiliar nas demais etapas da ciência de dados.\nTanto o pacote tibble, como o tidyr fazem parte do tidyverse. Sendo assim, vamos carregá-los.\nlibrary(tibble)\nlibrary(tidyr)\nOs exemplos a seguir utilizam um mesmo conjunto de dados em diferentes formatações. Para fazer o download dos dados, clique aqui.",
    "crumbs": [
      "Preliminares",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Organização</span>"
    ]
  },
  {
    "objectID": "arrumar.html#tibble",
    "href": "arrumar.html#tibble",
    "title": "5  Organização",
    "section": "\n5.2 Tibble",
    "text": "5.2 Tibble\nNo Capítulo 4 vimos que os pacotes readr e readxl apresentam funções que importam os dados ao R no formato de tibble e não em um data frame tradicional.\nIsso se deve ao fato que ambos os pacotes seguem o padrão tidyverse, bem como a tibble, oriunda do pacote de mesmo nome (tibble). Dessa forma, os pacotes que seguem a lógica do tidyverse utilizam a tibble como o data frame padrão e não a sua versão tradicional1.\nDe maneira geral, a tibble apresenta as mesmas propriedades de seu análogo original, apresentando algumas melhorias e ajustes que facilitam o nosso trabalho. Dessa forma, os conceitos que vimos na Seção 3.10 e Seção 3.12 são válidos para a tibble.\nApesar da tibble também ser um data frame, neste material, utilizaremos o termo data frame apenas para nos referirmos à versão tradicional.\n\n5.2.1 Converter em Tibble\nPara converter data frames em tibble, utilizamos a função as_tibble(). Como exemplo, transformaremos o conjunto de dados nativo do R iris para o formato tibble.\n\nclass(iris)\n#&gt; [1] \"data.frame\"\n\n\niris_tibble &lt;- as_tibble(iris)\niris_tibble\n#&gt; # A tibble: 150 × 5\n#&gt;    Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#&gt;           &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  \n#&gt;  1          5.1         3.5          1.4         0.2 setosa \n#&gt;  2          4.9         3            1.4         0.2 setosa \n#&gt;  3          4.7         3.2          1.3         0.2 setosa \n#&gt;  4          4.6         3.1          1.5         0.2 setosa \n#&gt;  5          5           3.6          1.4         0.2 setosa \n#&gt;  6          5.4         3.9          1.7         0.4 setosa \n#&gt;  7          4.6         3.4          1.4         0.3 setosa \n#&gt;  8          5           3.4          1.5         0.2 setosa \n#&gt;  9          4.4         2.9          1.4         0.2 setosa \n#&gt; 10          4.9         3.1          1.5         0.1 setosa \n#&gt; # ℹ 140 more rows\n\nclass(iris_tibble)\n#&gt; [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\nPor padrão, a tibble mostra as dimensões da tabela (linhas x colunas) e a classe das variáveis entre &lt;&gt;, logo abaixo de seu nome.\nAlém disso, apenas as dez primeiras linhas são apresentadas e, caso o número de colunas não couber na largura da tela, essas são ocultadas da apresentação. Isso evita que a saída no console fique sobrecarregada de informações desordenadas, principalmente quando trabalhamos com um conjunto de dados extenso.\nCaso seja preciso ter uma visão geral dos dados, podemos utilizar a função glimpse().\n\nglimpse(iris_tibble)\n#&gt; Rows: 150\n#&gt; Columns: 5\n#&gt; $ Sepal.Length &lt;dbl&gt; 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5.4, 4.…\n#&gt; $ Sepal.Width  &lt;dbl&gt; 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7, 3.…\n#&gt; $ Petal.Length &lt;dbl&gt; 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.…\n#&gt; $ Petal.Width  &lt;dbl&gt; 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0.2, 0.…\n#&gt; $ Species      &lt;fct&gt; setosa, setosa, setosa, setosa, setosa, setosa, setosa, s…\n\nOu ainda, a função View() (vide Seção 3.10).\n\n5.2.2 Criando Tibble\nTambém podemos criar uma tibble dentro do R com a função tibble().\n\ntibble(\n  nomes = c(\"José\", \"João\", \"Maria\", \"Ana\"),\n  sexo = c(\"M\", \"M\", \"F\", \"F\"),\n  idade = 21:24,\n  idade_ao_quadrado = idade ^ 2,\n  filhos = 0\n)\n#&gt; # A tibble: 4 × 5\n#&gt;   nomes sexo  idade idade_ao_quadrado filhos\n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;int&gt;             &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1 José  M        21               441      0\n#&gt; 2 João  M        22               484      0\n#&gt; 3 Maria F        23               529      0\n#&gt; 4 Ana   F        24               576      0\n\nA construção de uma tibble segue a mesma lógica apresentada na Seção 3.10 quando criamos um data frame com a função data.frame(). Primeiro, designamos os nomes das variáveis e, posteriormente, o vetor com seus valores.\nNo exemplo acima, veja que foi possível criar a coluna idade_ao_quadrado em função de outra coluna, a idade. Na coluna filhos, passamos um vetor de tamanho 1, ocorrendo o processo de reciclagem (vide Seção 3.6), ou seja, foi atribuído o valor 0 para todas as demais observações até que se igualasse o número de linhas da tibble.\nÉ possível colocar nomes de colunas com caracteres de sintaxe inválida (vide Seção 3.3), desde que os nomes estejam entre acentos graves (``).\nNo caso dos data frames, teríamos dificuldades em trabalhar com esse tipo de sintaxe, pois os nomes seriam convertidos para um formato que se enquadre à sintaxe válida, portanto, ocorreria uma alteração dos nomes designados originalmente.\nA seguir, criaremos um exemplo de tibble (puramente a título de ilustração) com nomes que contêm espaços, começam com números e possuem caracteres especiais.\n\ntibble(\n  `nomes dos estudantes` = c(\"João\", \"José\", \"Sara\"),\n  `2sexo` = c(\"M\", \"M\", \"F\"),\n  `:)idade` = 21:23,\n  `idade²` = `:)idade` ^ 2,\n  `nº filhos` = 0\n)\n#&gt; # A tibble: 3 × 5\n#&gt;   `nomes dos estudantes` `2sexo` `:)idade` `idade²` `nº filhos`\n#&gt;   &lt;chr&gt;                  &lt;chr&gt;       &lt;int&gt;    &lt;dbl&gt;       &lt;dbl&gt;\n#&gt; 1 João                   M              21      441           0\n#&gt; 2 José                   M              22      484           0\n#&gt; 3 Sara                   F              23      529           0\n\nPor consequência, quando trabalharmos com as variáveis nomeadas dessa forma, precisaremos colocá-las sempre entre acentos graves, como foi o caso da construção da coluna idade², em que tivemos que colocar a coluna :)idade entre acentos graves para que conseguíssemos elevar seus valores ao quadrado.\nAinda que a tibble permita trabalhar com esse tipo de sintaxe, recomenda-se evitá-las, a fim de evitar o uso dos acentos graves a todo momento que formos referenciar uma coluna, tornando o trabalho mais fácil.\nPor último, podemos criar tibble com a função tribble(). A tribble() é construída de maneira transposta ao formato convencional. Na primeira entrada, colocamos os nomes das variáveis começando com ~, separadas por vírgulas. Em seguida, colocamos os valores de cada observação. Esta opção é uma forma mais visual e intuitiva para construir pequenas tibble.\n\ntribble(\n  ~nome, ~idade, ~sexo,\n  \"João\",  21  , \"M\",\n  \"José\",  22  , \"M\",\n  \"Sara\",  23  , \"F\"\n)\n#&gt; # A tibble: 3 × 3\n#&gt;   nome  idade sexo \n#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;\n#&gt; 1 João     21 M    \n#&gt; 2 José     22 M    \n#&gt; 3 Sara     23 F",
    "crumbs": [
      "Preliminares",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Organização</span>"
    ]
  },
  {
    "objectID": "arrumar.html#sec-tidy-data",
    "href": "arrumar.html#sec-tidy-data",
    "title": "5  Organização",
    "section": "\n5.3 Dados arrumados",
    "text": "5.3 Dados arrumados\nUm mesmo conjunto de dados pode ser disposto de diversas maneiras. Os exemplos a seguir mostram três formas de organização. Os dados são referentes a produção (em toneladas) e a área colhida (em hectares) de milho, no Brasil, China e Índia, nos anos de 2000 e 2019.\n\nlibrary(readr)\n\nread_csv(file = \"dados/tidy1.csv\")\n#&gt; # A tibble: 6 × 4\n#&gt;   pais     ano colheita  producao\n#&gt;   &lt;chr&gt;  &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Brasil  2000 11890376  32321000\n#&gt; 2 Brasil  2019 17518054 101138617\n#&gt; 3 China   2000 23086228 106178315\n#&gt; 4 China   2019 41309740 260957662\n#&gt; 5 India   2000  6611300  12043200\n#&gt; 6 India   2019  9027130  27715100\n\nread_csv(file = \"dados/tidy2.csv\")\n#&gt; # A tibble: 12 × 4\n#&gt;    pais     ano tipo         valor\n#&gt;    &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt;\n#&gt;  1 Brasil  2000 colheita  11890376\n#&gt;  2 Brasil  2019 colheita  17518054\n#&gt;  3 Brasil  2000 producao  32321000\n#&gt;  4 Brasil  2019 producao 101138617\n#&gt;  5 China   2000 colheita  23086228\n#&gt;  6 China   2019 colheita  41309740\n#&gt;  7 China   2000 producao 106178315\n#&gt;  8 China   2019 producao 260957662\n#&gt;  9 India   2000 colheita   6611300\n#&gt; 10 India   2019 colheita   9027130\n#&gt; 11 India   2000 producao  12043200\n#&gt; 12 India   2019 producao  27715100\n\nread_csv(file = \"dados/tidy3.csv\")\n#&gt; # A tibble: 6 × 3\n#&gt;   pais     ano produtividade     \n#&gt;   &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;             \n#&gt; 1 Brasil  2000 32321000/11890376 \n#&gt; 2 Brasil  2019 101138617/17518054\n#&gt; 3 China   2000 106178315/23086228\n#&gt; 4 China   2019 260957662/41309740\n#&gt; 5 India   2000 12043200/6611300  \n#&gt; 6 India   2019 27715100/9027130\n\nTodos os exemplos são maneiras distintas de representar um mesmo conjunto de dados. Contudo, apenas uma delas é uma tidy data (ou base de dados arrumada).\nUma tidy data deve seguir três propriedades:\n\nCada variável possui sua própria coluna;\nCada observação possui sua própria linha;\nCada célula contém somente um único valor.\n\nA Figura 5.2 ilustra, visualmente, as propriedades.\n\n\n\n\n\n\n\nFigura 5.2: Seguindo os princípios da tidy data, cada variável possui uma coluna, cada observação está em uma linha e cada célula contém somente um valor.\n\n\n\n\nAo designar uma variável à uma única coluna, podemos trabalhar com as informações a partir de vetores individualizados. Portanto, os conceitos vistos na Seção 3.6, referente aos vetores, são aplicáveis a cada uma das colunas de uma base de dados organizada. E é a partir dessa lógica que os pacotes do tidyverse trabalham.\nDentre os três exemplos ilustrados anteriormente, apenas o primeiro caso ilustra uma tidy data.\n\nread_csv(file = \"dados/tidy1.csv\")\n#&gt; # A tibble: 6 × 4\n#&gt;   pais     ano colheita  producao\n#&gt;   &lt;chr&gt;  &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Brasil  2000 11890376  32321000\n#&gt; 2 Brasil  2019 17518054 101138617\n#&gt; 3 China   2000 23086228 106178315\n#&gt; 4 China   2019 41309740 260957662\n#&gt; 5 India   2000  6611300  12043200\n#&gt; 6 India   2019  9027130  27715100\n\nDessa forma, sempre que se deparar com um novo conjunto de dados, observe primeiro quais elementos são variáveis e quais são observações, e se uma célula contém um ou mais valores.\nNos próximos capítulos, veremos como utilizar uma tidy data para realizar transformações e gráficos. Mas antes, trataremos sobre os dados desarrumados2.",
    "crumbs": [
      "Preliminares",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Organização</span>"
    ]
  },
  {
    "objectID": "arrumar.html#sec-pivot",
    "href": "arrumar.html#sec-pivot",
    "title": "5  Organização",
    "section": "\n5.4 Pivotagem",
    "text": "5.4 Pivotagem\nUma maneira de organizar os dados desarrumados é realizar a pivotagem. Este método converte as observações que estão como nome de colunas para linhas ou variáveis que estão em linhas para nomes de colunas.\nPara isso, utilizamos duas funções do pacote tidyr: pivot_longer() e pivot_wider().\n\n5.4.1 Alongando os dados\nA função pivot_longer() converte as observações que estão como nome das colunas, para linhas. Com isso, a função torna a base de dados mais longa, ou seja, reduz o número de colunas e aumenta o número de linhas.\nAplicaremos sua função no arquivo tidy-producao.csv.\n\nproducao &lt;- read_csv(file = \"dados/tidy-producao.csv\")\n\nproducao\n#&gt; # A tibble: 3 × 3\n#&gt;   pais      `2000`    `2019`\n#&gt;   &lt;chr&gt;      &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Brasil  32321000 101138617\n#&gt; 2 China  106178315 260957662\n#&gt; 3 India   12043200  27715100\n\nVeja que as observações referentes aos anos de 2000 e 2019 estão como nome das colunas, cada uma com os respectivos valores de produção de milho.\nPara isso, devemos criar duas novas colunas, uma para alocar os anos e outra para os valores de produção de milho.\n\nproducao_alongada &lt;- pivot_longer(\n  data = producao,\n  cols = c(`2000`, `2019`),\n  names_to = \"ano\", \n  values_to = \"producao\"\n)\n\nproducao_alongada\n#&gt; # A tibble: 6 × 3\n#&gt;   pais   ano    producao\n#&gt;   &lt;chr&gt;  &lt;chr&gt;     &lt;dbl&gt;\n#&gt; 1 Brasil 2000   32321000\n#&gt; 2 Brasil 2019  101138617\n#&gt; 3 China  2000  106178315\n#&gt; 4 China  2019  260957662\n#&gt; 5 India  2000   12043200\n#&gt; 6 India  2019   27715100\n\nA função pivot_longer() apresenta os seguintes argumentos:\n\ndata = para indicar qual objeto desejamos pivotar;\ncols = para selecionar as colunas que desejamos pivotar, ou seja, as colunas que não são variáveis (2000 e 2019);\nnames_to = dizemos para qual coluna os nomes selecionados em cols = devem ir. No caso, 2000 e 2019 são redirecionadas para a nova coluna de nome \"ano\";\nvalues_to = dizemos para qual coluna os valores das colunas selecionadas em cols = devem ir. Portanto, os valores das colunas 2000 e 2019 são redirecionados para a nova coluna \"producao\".\n\nPerceba que os valores se mantém associados às antigas colunas 2000 e 2019, agora como valores de uma observação.\nPodemos fazer o mesmo com os dados referentes à área colhida, presente no arquivo tidy-colheita.csv.\n\ncolheita &lt;- read_csv(file = \"dados/tidy-colheita.csv\")\n\ncolheita\n#&gt; # A tibble: 3 × 3\n#&gt;   pais     `2000`   `2019`\n#&gt;   &lt;chr&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n#&gt; 1 Brasil 11890376 17518054\n#&gt; 2 China  23086228 41309740\n#&gt; 3 India   6611300  9027130\n\nPara isso, devemos alterar somente o atributo do argumento values_to = para \"colheita\", além do nome do objeto a ser pivotado (data = colheita).\n\ncolheita_alongada &lt;- pivot_longer(\n  data = colheita,\n  cols = c(`2000`, `2019`),\n  names_to = \"ano\", \n  values_to = \"colheita\"\n)\n\ncolheita_alongada\n#&gt; # A tibble: 6 × 3\n#&gt;   pais   ano   colheita\n#&gt;   &lt;chr&gt;  &lt;chr&gt;    &lt;dbl&gt;\n#&gt; 1 Brasil 2000  11890376\n#&gt; 2 Brasil 2019  17518054\n#&gt; 3 China  2000  23086228\n#&gt; 4 China  2019  41309740\n#&gt; 5 India  2000   6611300\n#&gt; 6 India  2019   9027130\n\nA Figura 5.3 ilustra o funcionamento da função pivot_longer().\n\n\n\n\n\n\n\nFigura 5.3: As colunas pivotadas são convertidas em valores de uma nova coluna. Consequentemente, seus valores também são alocados em uma nova coluna. Perceba que o conjunto de dados passa a ficar mais longo.\n\n\n\n\nPara juntar ambas as tabelas, utilizamos a função dplyr::full_join(), a qual veremos com mais detalhes no Capítulo 8.\n\ndplyr::full_join(producao_alongada, colheita_alongada)\n#&gt; # A tibble: 6 × 4\n#&gt;   pais   ano    producao colheita\n#&gt;   &lt;chr&gt;  &lt;chr&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n#&gt; 1 Brasil 2000   32321000 11890376\n#&gt; 2 Brasil 2019  101138617 17518054\n#&gt; 3 China  2000  106178315 23086228\n#&gt; 4 China  2019  260957662 41309740\n#&gt; 5 India  2000   12043200  6611300\n#&gt; 6 India  2019   27715100  9027130\n\n\n5.4.2 Alargando os dados\nA função pivot_wider() é a oposta da pivot_longer(). Ela é usada para converter as variáveis que estão nas linhas, para o nome das colunas. Dessa forma, podemos dizer que a função deixa a base de dados mais larga, portanto, aumenta o número de colunas e diminui o número de linhas.\nComo exemplo, utilizaremos o arquivo tidy2.csv.\n\nproducao_colheita &lt;- read_csv(file = \"dados/tidy2.csv\")\n\nproducao_colheita\n#&gt; # A tibble: 12 × 4\n#&gt;    pais     ano tipo         valor\n#&gt;    &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt;\n#&gt;  1 Brasil  2000 colheita  11890376\n#&gt;  2 Brasil  2019 colheita  17518054\n#&gt;  3 Brasil  2000 producao  32321000\n#&gt;  4 Brasil  2019 producao 101138617\n#&gt;  5 China   2000 colheita  23086228\n#&gt;  6 China   2019 colheita  41309740\n#&gt;  7 China   2000 producao 106178315\n#&gt;  8 China   2019 producao 260957662\n#&gt;  9 India   2000 colheita   6611300\n#&gt; 10 India   2019 colheita   9027130\n#&gt; 11 India   2000 producao  12043200\n#&gt; 12 India   2019 producao  27715100\n\nNeste caso, as variáveis colheita e producao estão como valores de observações. Portanto, devemos transformá-las em nomes de colunas, recebendo os respectivos valores associados à coluna valor.\n\nproducao_colheita_alargada &lt;- pivot_wider(\n  data = producao_colheita,\n  names_from = tipo,\n  values_from = valor\n)\n\nproducao_colheita_alargada\n#&gt; # A tibble: 6 × 4\n#&gt;   pais     ano colheita  producao\n#&gt;   &lt;chr&gt;  &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Brasil  2000 11890376  32321000\n#&gt; 2 Brasil  2019 17518054 101138617\n#&gt; 3 China   2000 23086228 106178315\n#&gt; 4 China   2019 41309740 260957662\n#&gt; 5 India   2000  6611300  12043200\n#&gt; 6 India   2019  9027130  27715100\n\nA função pivot_wider() apresenta os seguinte argumentos:\n\ndata = para indicar qual objeto desejamos pivotar;\nnames_from = dizemos em qual coluna estão as variáveis que desejamos converter para nome de colunas. No exemplo, convertemos producao e colheita da coluna tipo;\nvalues_from = indica em qual coluna estão localizados os valores das novas colunas criadas.\n\nA Figura 5.4 ilustra o funcionamento da função pivot_wider().\n\n\n\n\n\n\n\nFigura 5.4: Com a pivot_wider(), convertemos variáveis presentes como observações de uma coluna para nomes de colunas. Dessa forma, o conjunto de dados passa a ficar mais largo.\n\n\n\n\nAs funções de pivotagem apresentam outros diversos argumentos. Para saber mais sobre elas, confira a página https://tidyr.tidyverse.org/articles/pivot.html.",
    "crumbs": [
      "Preliminares",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Organização</span>"
    ]
  },
  {
    "objectID": "arrumar.html#separar-e-unir",
    "href": "arrumar.html#separar-e-unir",
    "title": "5  Organização",
    "section": "\n5.5 Separar e Unir",
    "text": "5.5 Separar e Unir\nQuando uma célula apresenta mais de um valor, devemos separá-los para termos uma tidy data. Para isso, utilizamos a função separate() do pacote tidyr. Utilizaremos os dados do arquivo tidy3.csv para ilustrar seu uso.\n\nprod &lt;- read_csv(file = \"dados/tidy3.csv\")\n\nprod\n#&gt; # A tibble: 6 × 3\n#&gt;   pais     ano produtividade     \n#&gt;   &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;             \n#&gt; 1 Brasil  2000 32321000/11890376 \n#&gt; 2 Brasil  2019 101138617/17518054\n#&gt; 3 China   2000 106178315/23086228\n#&gt; 4 China   2019 260957662/41309740\n#&gt; 5 India   2000 12043200/6611300  \n#&gt; 6 India   2019 27715100/9027130\n\nA produtividade de uma lavoura é dada pela razão entre a produção e a área colhida. Portanto, a variável produtividade tem os valores de produção e colheita representados na mesma célula.\nUma vez que produção e colheita são variáveis, devemos colocá-las em colunas.\n\nseparate(\n  data = prod,\n  col = produtividade,\n  into = c(\"producao\", \"colheita\"),\n  sep = \"/\"\n)\n#&gt; # A tibble: 6 × 4\n#&gt;   pais     ano producao  colheita\n#&gt;   &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;   \n#&gt; 1 Brasil  2000 32321000  11890376\n#&gt; 2 Brasil  2019 101138617 17518054\n#&gt; 3 China   2000 106178315 23086228\n#&gt; 4 China   2019 260957662 41309740\n#&gt; 5 India   2000 12043200  6611300 \n#&gt; 6 India   2019 27715100  9027130\n\nNa função separate(), utilizamos os seguintes argumentos:\n\ndata = para indicar o objeto a ser separado;\ncol = indicamos qual coluna será desmembrada, no caso, a produtividade;\ninto = dizemos o nome das novas colunas que direcionaremos os valores da coluna separada, ou seja, \"producao\" e \"colheita\";\nsep = indicamos qual o operador está separando os valores.\n\nPerceba que a classe das novas colunas vieram como do tipo caractere, apesar de serem numéricas. Por padrão, a função separate() sempre adotará essa classe. Para corrigirmos a classe, podemos utilizar o argumento convert = TRUE, ou seja, pedir para a função adotar uma classe mais apropriada aos valores contidos nas colunas.\n\nprod_separado &lt;- separate(\n  data = prod,\n  col = produtividade,\n  into = c(\"producao\", \"colheita\"),\n  sep = \"/\",\n  convert = TRUE\n)\n\nprod_separado\n#&gt; # A tibble: 6 × 4\n#&gt;   pais     ano  producao colheita\n#&gt;   &lt;chr&gt;  &lt;dbl&gt;     &lt;int&gt;    &lt;int&gt;\n#&gt; 1 Brasil  2000  32321000 11890376\n#&gt; 2 Brasil  2019 101138617 17518054\n#&gt; 3 China   2000 106178315 23086228\n#&gt; 4 China   2019 260957662 41309740\n#&gt; 5 India   2000  12043200  6611300\n#&gt; 6 India   2019  27715100  9027130\n\nFeito isso, temos a classe de números inteiros (&lt;int&gt;) para as colunas producao e colheita.\nTambém podemos separar valores de acordo com uma quantidade de caracteres. Para isso, informamos no argumento sep = a quantidade dos primeiros caracteres que desejamos quebrar.\nPor exemplo, para separar os valores da coluna ano em seculo e decada, podemos passar o argumento sep = 2, ou seja, o argumento selecionará os dois primeiros caracteres dos valores contidos na coluna ano e os separará dos demais, formando as novas colunas seculo e decada.\n\nseparar_ano &lt;- separate(\n  data = prod_separado,\n  col = ano,\n  into = c(\"seculo\", \"decada\"),\n  sep = 2\n)\n\nseparar_ano\n#&gt; # A tibble: 6 × 5\n#&gt;   pais   seculo decada  producao colheita\n#&gt;   &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;      &lt;int&gt;    &lt;int&gt;\n#&gt; 1 Brasil 20     00      32321000 11890376\n#&gt; 2 Brasil 20     19     101138617 17518054\n#&gt; 3 China  20     00     106178315 23086228\n#&gt; 4 China  20     19     260957662 41309740\n#&gt; 5 India  20     00      12043200  6611300\n#&gt; 6 India  20     19      27715100  9027130\n\nCaso houver um número negativo, o argumento considera o sinal de negativo como o primeiro caractere informado no argumento.\nPor outro lado, temos a função unite(), também do pacote tidyr, que combina múltiplas colunas em uma única. Como exemplo, juntaremos, novamente, as colunas seculo e decada na nova coluna novamente_ano.\n\nunite(\n  data = separar_ano,\n  col = \"novamente_ano\",\n  seculo, decada,\n  sep = \"\"\n)\n#&gt; # A tibble: 6 × 4\n#&gt;   pais   novamente_ano  producao colheita\n#&gt;   &lt;chr&gt;  &lt;chr&gt;             &lt;int&gt;    &lt;int&gt;\n#&gt; 1 Brasil 2000           32321000 11890376\n#&gt; 2 Brasil 2019          101138617 17518054\n#&gt; 3 China  2000          106178315 23086228\n#&gt; 4 China  2019          260957662 41309740\n#&gt; 5 India  2000           12043200  6611300\n#&gt; 6 India  2019           27715100  9027130\n\nNo argumento col = declaramos o nome da nova coluna, seguida das colunas a serem juntadas (seculo e decada). Por fim, sep = informa qual o separador utilizado (no caso, o operador \"\" indica a não utilização de separador). Caso não fosse informado o argumento sep =, por padrão, a função adota o underline (_) como separador.",
    "crumbs": [
      "Preliminares",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Organização</span>"
    ]
  },
  {
    "objectID": "arrumar.html#resumo",
    "href": "arrumar.html#resumo",
    "title": "5  Organização",
    "section": "\n5.6 Resumo",
    "text": "5.6 Resumo\nCaso queira conhecer mais sobre a tidy data e sua relação com o tidyverse, recomendo o documento The tidy tools manifesto, que aborda os princípios norteadores do tidyverse, além do artigo Tidy Data, que trata de maneira teórica os conceitos de dados arrumados. Ambos os materiais são de autoria de Hadley Wickham, o idealizador do pacote tidyverse.\nA seguir, agora com os dados arrumados, veremos como transformar os dados para que contenham apenas as variáveis de nosso interesse e também criar novas variáveis, a partir das existentes.",
    "crumbs": [
      "Preliminares",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Organização</span>"
    ]
  },
  {
    "objectID": "arrumar.html#footnotes",
    "href": "arrumar.html#footnotes",
    "title": "5  Organização",
    "section": "",
    "text": "Utilizar o modelo tradicional de data frame junto ao tidyverse não é um impeditivo. Porém, utilizar a tibble evita qualquer possível incompatibiliade.↩︎\nQuando nos referirmos a dados desarrumados, entenda como dados fora do padrão tidy data ou não-tidy, uma vez que o formato tidy é um dos possíveis para se trabalhar com dados, principalmente quando trabalhamos com o pacote tidyverse.↩︎",
    "crumbs": [
      "Preliminares",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Organização</span>"
    ]
  },
  {
    "objectID": "transformar.html",
    "href": "transformar.html",
    "title": "6  Transformação",
    "section": "",
    "text": "Com os dados organizados, avançamos para a etapa de transformação. Essa fase abrange diversas operações e, por isso, está dividida em 6 parte conforme o tema. Dependendo do tipo de dado presente em cada variável, utilizamos diferentes pacotes do tidyverse, especializados em aspectos específicos da transformação. A seguir estão listados os temas, com os respectivos pacotes, que trataremos adiante.\n\nFunções essenciais: o pacote dplyr apresenta as principais funções de transformação dos dados. Apresenta funções que nos permite realizar operações entre colunas, calcular medidas-resumo, filtrar linhas, criar e selecionar novas colunas, dentre outras. Dominando essas funções, conseguimos resolver a maioria dos assuntos relacionados à etapa de transformação dos dados.\nDados relacionais: apresenta as ferramentas para unir dois ou mais data frames. Essas funções também são parte do pacote dplyr.\nNúmeros: aprofundaremos alguns conceitos relacionados a vetores numéricos.\nData e Tempo: tratam de dados cujas variáveis são do tipo data e tempo. Para isso, utilizaremos as funcionalidades do pacote lubridate.\nFatores: apresentaremos o pacote forcats para tratar de dados do tipo fator, tema introduzido na Seção 3.7.\nTexto: com o pacote stringr veremos como realizar manipulações de textos a partir de expressões regulares.\nValores ausentes: apresentaremos algumas soluções para tratar de valores ausentes.\n\n\n\n\n\n\n\n\nFigura 6.1: A etapa de transformar visa gerar medidas de interesse a partir dos dados brutos. Para cada classe de variáveis, temos um conjunto de ferramentas específicas que, utilizadas em conjunto, geram excelentes resultados.\n\n\n\n\nNa maioria dos casos, as funcionalidades de transformação dos dados são utilizadas em conjunto com diversas outras. Para integrá-las, o R apresenta um operador muito útil: o pipe. No Capítulo 7, apresentaremos este importante operador.\nRecomendo aos iniciantes em R que comece os estudos desta etapa pelo Capítulo 7, que aborda as funções básicas e essenciais de transformação, a fim de consolidar tais conceitos. Posteriormente, o leitor se sentirá mais capacitado em explorar os demais capítulos desta etapa conforme a necessidade e interesse.",
    "crumbs": [
      "Manipulações",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Transformação</span>"
    ]
  },
  {
    "objectID": "dplyr.html",
    "href": "dplyr.html",
    "title": "7  Funções essenciais",
    "section": "",
    "text": "7.1 Introdução\nNeste capítulo, exploraremos as principais funções de manipulação de dados disponíveis no pacote dplyr.\nO dplyr é um dos principais pacotes do tidyverse. Ele oferece um conjunto de ferramentas intuitivas e robustas para a manipulação de dados de forma eficiente. A seguir, apresentaremos as principais funções do pacote, que nos permitem resolver a maioria dos problemas relacionados à etapa de transformação dos dados.\nlibrary(dplyr)\nPara os exemplos, utilizaremos um conjunto de dados da FAOSTAT. Os dados estão disponíveis para download clicando aqui.\nMas antes de adentrar ao pacote dplyr, vamos conhecer o operador pipe.",
    "crumbs": [
      "Manipulações",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Funções essenciais</span>"
    ]
  },
  {
    "objectID": "dplyr.html#sec-pipe",
    "href": "dplyr.html#sec-pipe",
    "title": "7  Funções essenciais",
    "section": "\n7.2 Operador pipe\n",
    "text": "7.2 Operador pipe\n\nNa maioria dos casos, utilizaremos mais de uma função para manipular os nossos dados. Com isso, entra em cena o pipe, cujo operador é |&gt;.\nA principal função do pipe é conectar linhas de códigos que se relacionam, executando-as em sequência e de uma só vez. Essa estrutura de código é chamada de pipeline.\nPara ilustrá-lo, faremos uma mesma operação com e sem o pipe, calculando a média final das notas de um aluno, arredondada em uma casa decimal.\n\nnotas &lt;- c(8.88, 6.84, 7.51)\n\n# Sem o pipe\nround(mean(notas), 1)\n#&gt; [1] 7.7\n\n# Com o pipe\nnotas |&gt; mean() |&gt; round(1)\n#&gt; [1] 7.7\n\nCom o pipe, colocamos as funções de acordo com a ordem em que desejamos realizar as operações. No exemplo, primeiro declaramos o objeto que contém os valores a serem utilizados. Em seguida, calculamos a média das notas. E por fim, arrendondamos em uma casa decimal o valor obtido no cálculo da média.\nDessa maneira, ao utilizar o pipe, evitamos de escrever funções dentro de funções, obtendo um código mais legível, claro e compacto, principalmente quando trabalhamos com diversas funções. Além disso, facilita a manutenção do código, caso seja preciso realizar alterações ou consertar possíveis problemas.\nPodemos utilizar o atalho do teclado Ctrl + Shift + M (Cmd + Shift + M) para adicionar o pipe ao código. Para isso, devemos ativá-lo clicando na aba Tools do menu superior, seguido de Global Options.... Ao abrir a janela, em Code, habilite a opção indicada na Figura 7.1.\n\n\n\n\n\n\n\nFigura 7.1: Para inserir o pipe a partir do atalho, habilite a opção “Use native pipe operator”.\n\n\n\n\nOs usuários mais antigos do R devem se lembrar que utilizávamos o operador %&gt;% para o pipe. Este operador está presente no pacote magrittr, outro componente do tidyverse.\nApesar de ambos os operadores atuarem de modo semelhante para os casos mais simples, o |&gt; funciona sem carregar o tidyverse, pois faz parte do pacote base do R, tornando-o mais simples e independente de qualquer pacote. Esta é a principal vantagem desse operador em relação ao do pacote magrittr.\nPara entender mais sobre as mudanças entre os operadores, recomendo o seguinte texto: https://www.tidyverse.org/blog/2023/04/base-vs-magrittr-pipe/.",
    "crumbs": [
      "Manipulações",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Funções essenciais</span>"
    ]
  },
  {
    "objectID": "dplyr.html#colunas",
    "href": "dplyr.html#colunas",
    "title": "7  Funções essenciais",
    "section": "\n7.3 Colunas",
    "text": "7.3 Colunas\nExistem quatro principais funções relacionadas a manipulação de colunas (ou variáveis): select(), rename(), relocate() e mutate(). A seguir, trataremos de cada uma delas.\n\n7.3.1 Selecionar\nA primeira função que apresentaremos é a select(), que seleciona as variáveis de um data frame. Primeiramente, vamos importar e analisar os dados do arquivo prod_graos.csv.\n\ngraos &lt;- readr::read_csv(\"dados/prod-graos.csv\")\ngraos\n#&gt; # A tibble: 2,842 × 12\n#&gt;    domain_code domain    area_code_fao area  item_code_fao item  year_code  year\n#&gt;    &lt;chr&gt;       &lt;chr&gt;             &lt;dbl&gt; &lt;chr&gt;         &lt;dbl&gt; &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt;\n#&gt;  1 QCL         Crops an…             9 Arge…            56 Maize      1961  1961\n#&gt;  2 QCL         Crops an…             9 Arge…            56 Maize      1962  1962\n#&gt;  3 QCL         Crops an…             9 Arge…            56 Maize      1963  1963\n#&gt;  4 QCL         Crops an…             9 Arge…            56 Maize      1964  1964\n#&gt;  5 QCL         Crops an…             9 Arge…            56 Maize      1965  1965\n#&gt;  6 QCL         Crops an…             9 Arge…            56 Maize      1966  1966\n#&gt;  7 QCL         Crops an…             9 Arge…            56 Maize      1967  1967\n#&gt;  8 QCL         Crops an…             9 Arge…            56 Maize      1968  1968\n#&gt;  9 QCL         Crops an…             9 Arge…            56 Maize      1969  1969\n#&gt; 10 QCL         Crops an…             9 Arge…            56 Maize      1970  1970\n#&gt; # ℹ 2,832 more rows\n#&gt; # ℹ 4 more variables: flag &lt;chr&gt;, flag_description &lt;chr&gt;, area_harvested &lt;dbl&gt;,\n#&gt; #   production &lt;dbl&gt;\n\nglimpse(graos)\n#&gt; Rows: 2,842\n#&gt; Columns: 12\n#&gt; $ domain_code      &lt;chr&gt; \"QCL\", \"QCL\", \"QCL\", \"QCL\", \"QCL\", \"QCL\", \"QCL\", \"QCL…\n#&gt; $ domain           &lt;chr&gt; \"Crops and livestock products\", \"Crops and livestock …\n#&gt; $ area_code_fao    &lt;dbl&gt; 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,…\n#&gt; $ area             &lt;chr&gt; \"Argentina\", \"Argentina\", \"Argentina\", \"Argentina\", \"…\n#&gt; $ item_code_fao    &lt;dbl&gt; 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 5…\n#&gt; $ item             &lt;chr&gt; \"Maize\", \"Maize\", \"Maize\", \"Maize\", \"Maize\", \"Maize\",…\n#&gt; $ year_code        &lt;dbl&gt; 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969,…\n#&gt; $ year             &lt;dbl&gt; 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969,…\n#&gt; $ flag             &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n#&gt; $ flag_description &lt;chr&gt; \"Official data\", \"Official data\", \"Official data\", \"O…\n#&gt; $ area_harvested   &lt;dbl&gt; 2744400, 2756670, 2645400, 2970500, 3062300, 3274500,…\n#&gt; $ production       &lt;dbl&gt; 4850000, 5220000, 4360000, 5350000, 5140000, 7040000,…\n\nO conjunto de dados traz a produção e área colhida de milho, soja, trigo e arroz nos países da América do Sul entre 1961 e 2019. Com a função glimpse(), constatamos que o data frame apresenta 2.842 observações e 12 variáveis. Como podemos observar, muitas das variáveis são códigos de identificação utilizados pelo sistema da FAO, os quais, neste momento, não nos interessam para a realização das análises.\nAs variáveis de interesse que iremos trabalhar são:\n\narea: traz o nome dos 13 países da América do Sul;\nitem: tipo de cultura - milho (maize), arroz (Rice, paddy), soja (Soybeans) e trigo (Wheat);\nyear: ano da observação;\narea_harvested: traz os valores de área colhida em hectares;\nproduction: traz os valores de produção em toneladas.\n\nPara selecionar as colunas de interesse, utilizamos a função select().\n\nselect(.data = graos, area, item, year, area_harvested, production)\n#&gt; # A tibble: 2,842 × 5\n#&gt;    area      item   year area_harvested production\n#&gt;    &lt;chr&gt;     &lt;chr&gt; &lt;dbl&gt;          &lt;dbl&gt;      &lt;dbl&gt;\n#&gt;  1 Argentina Maize  1961        2744400    4850000\n#&gt;  2 Argentina Maize  1962        2756670    5220000\n#&gt;  3 Argentina Maize  1963        2645400    4360000\n#&gt;  4 Argentina Maize  1964        2970500    5350000\n#&gt;  5 Argentina Maize  1965        3062300    5140000\n#&gt;  6 Argentina Maize  1966        3274500    7040000\n#&gt;  7 Argentina Maize  1967        3450500    8510000\n#&gt;  8 Argentina Maize  1968        3377700    6560000\n#&gt;  9 Argentina Maize  1969        3556000    6860000\n#&gt; 10 Argentina Maize  1970        4017330    9360000\n#&gt; # ℹ 2,832 more rows\n\nComo primeiro argumento, indicamos o objeto a ser manipulado e, em seguida, as colunas a serem selecionadas.\nUtilizando o operador pipe, prosseguimos da seguinte maneira.\n\ngraos |&gt; select(area, item, year, area_harvested, production)\n#&gt; # A tibble: 2,842 × 5\n#&gt;    area      item   year area_harvested production\n#&gt;    &lt;chr&gt;     &lt;chr&gt; &lt;dbl&gt;          &lt;dbl&gt;      &lt;dbl&gt;\n#&gt;  1 Argentina Maize  1961        2744400    4850000\n#&gt;  2 Argentina Maize  1962        2756670    5220000\n#&gt;  3 Argentina Maize  1963        2645400    4360000\n#&gt;  4 Argentina Maize  1964        2970500    5350000\n#&gt;  5 Argentina Maize  1965        3062300    5140000\n#&gt;  6 Argentina Maize  1966        3274500    7040000\n#&gt;  7 Argentina Maize  1967        3450500    8510000\n#&gt;  8 Argentina Maize  1968        3377700    6560000\n#&gt;  9 Argentina Maize  1969        3556000    6860000\n#&gt; 10 Argentina Maize  1970        4017330    9360000\n#&gt; # ℹ 2,832 more rows\n\nPrimeiro, declaramos qual o conjunto de dados iremos utilizar, seguido da função select() com as colunas que desejamos selecionar.\nPodemos selecionar várias colunas consecutivas com o operador :. Basta informar os nomes ou as posições da primeira e da última coluna que se deseja selecionar.\n\ngraos |&gt; select(area:year)\n#&gt; # A tibble: 2,842 × 5\n#&gt;    area      item_code_fao item  year_code  year\n#&gt;    &lt;chr&gt;             &lt;dbl&gt; &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt;\n#&gt;  1 Argentina            56 Maize      1961  1961\n#&gt;  2 Argentina            56 Maize      1962  1962\n#&gt;  3 Argentina            56 Maize      1963  1963\n#&gt;  4 Argentina            56 Maize      1964  1964\n#&gt;  5 Argentina            56 Maize      1965  1965\n#&gt;  6 Argentina            56 Maize      1966  1966\n#&gt;  7 Argentina            56 Maize      1967  1967\n#&gt;  8 Argentina            56 Maize      1968  1968\n#&gt;  9 Argentina            56 Maize      1969  1969\n#&gt; 10 Argentina            56 Maize      1970  1970\n#&gt; # ℹ 2,832 more rows\n\ngraos |&gt; select(4:8)\n#&gt; # A tibble: 2,842 × 5\n#&gt;    area      item_code_fao item  year_code  year\n#&gt;    &lt;chr&gt;             &lt;dbl&gt; &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt;\n#&gt;  1 Argentina            56 Maize      1961  1961\n#&gt;  2 Argentina            56 Maize      1962  1962\n#&gt;  3 Argentina            56 Maize      1963  1963\n#&gt;  4 Argentina            56 Maize      1964  1964\n#&gt;  5 Argentina            56 Maize      1965  1965\n#&gt;  6 Argentina            56 Maize      1966  1966\n#&gt;  7 Argentina            56 Maize      1967  1967\n#&gt;  8 Argentina            56 Maize      1968  1968\n#&gt;  9 Argentina            56 Maize      1969  1969\n#&gt; 10 Argentina            56 Maize      1970  1970\n#&gt; # ℹ 2,832 more rows\n\nEm conjunto com a select(), podemos utilizar outras funções que nos auxiliam na seleção de colunas.\n\n\nwhere(): seleciona as colunas que possuem determinada classe.\n\n\ngraos |&gt; select(where(is.numeric))\n#&gt; # A tibble: 2,842 × 6\n#&gt;    area_code_fao item_code_fao year_code  year area_harvested production\n#&gt;            &lt;dbl&gt;         &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;          &lt;dbl&gt;      &lt;dbl&gt;\n#&gt;  1             9            56      1961  1961        2744400    4850000\n#&gt;  2             9            56      1962  1962        2756670    5220000\n#&gt;  3             9            56      1963  1963        2645400    4360000\n#&gt;  4             9            56      1964  1964        2970500    5350000\n#&gt;  5             9            56      1965  1965        3062300    5140000\n#&gt;  6             9            56      1966  1966        3274500    7040000\n#&gt;  7             9            56      1967  1967        3450500    8510000\n#&gt;  8             9            56      1968  1968        3377700    6560000\n#&gt;  9             9            56      1969  1969        3556000    6860000\n#&gt; 10             9            56      1970  1970        4017330    9360000\n#&gt; # ℹ 2,832 more rows\n\n\n\nstarts_with(): seleciona colunas que começam com um texto padrão.\n\n\ngraos |&gt; select(starts_with(\"year\"))\n#&gt; # A tibble: 2,842 × 2\n#&gt;    year_code  year\n#&gt;        &lt;dbl&gt; &lt;dbl&gt;\n#&gt;  1      1961  1961\n#&gt;  2      1962  1962\n#&gt;  3      1963  1963\n#&gt;  4      1964  1964\n#&gt;  5      1965  1965\n#&gt;  6      1966  1966\n#&gt;  7      1967  1967\n#&gt;  8      1968  1968\n#&gt;  9      1969  1969\n#&gt; 10      1970  1970\n#&gt; # ℹ 2,832 more rows\n\n\n\nends_with(): seleciona colunas que terminam com um texto padrão.\n\n\ngraos |&gt; select(ends_with(\"code\"))\n#&gt; # A tibble: 2,842 × 2\n#&gt;    domain_code year_code\n#&gt;    &lt;chr&gt;           &lt;dbl&gt;\n#&gt;  1 QCL              1961\n#&gt;  2 QCL              1962\n#&gt;  3 QCL              1963\n#&gt;  4 QCL              1964\n#&gt;  5 QCL              1965\n#&gt;  6 QCL              1966\n#&gt;  7 QCL              1967\n#&gt;  8 QCL              1968\n#&gt;  9 QCL              1969\n#&gt; 10 QCL              1970\n#&gt; # ℹ 2,832 more rows\n\n\n\ncontains(): seleciona colunas que possuem um texto padrão.\n\n\ngraos |&gt; select(contains(\"code\"))\n#&gt; # A tibble: 2,842 × 4\n#&gt;    domain_code area_code_fao item_code_fao year_code\n#&gt;    &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;     &lt;dbl&gt;\n#&gt;  1 QCL                     9            56      1961\n#&gt;  2 QCL                     9            56      1962\n#&gt;  3 QCL                     9            56      1963\n#&gt;  4 QCL                     9            56      1964\n#&gt;  5 QCL                     9            56      1965\n#&gt;  6 QCL                     9            56      1966\n#&gt;  7 QCL                     9            56      1967\n#&gt;  8 QCL                     9            56      1968\n#&gt;  9 QCL                     9            56      1969\n#&gt; 10 QCL                     9            56      1970\n#&gt; # ℹ 2,832 more rows\n\nTambém podemos retirar colunas inserindo o operador - antes do nome da variável ou das funções auxiliares.\n\ngraos |&gt; select(-contains(\"code\"), -contains(\"flag\"), -domain)\n#&gt; # A tibble: 2,842 × 5\n#&gt;    area      item   year area_harvested production\n#&gt;    &lt;chr&gt;     &lt;chr&gt; &lt;dbl&gt;          &lt;dbl&gt;      &lt;dbl&gt;\n#&gt;  1 Argentina Maize  1961        2744400    4850000\n#&gt;  2 Argentina Maize  1962        2756670    5220000\n#&gt;  3 Argentina Maize  1963        2645400    4360000\n#&gt;  4 Argentina Maize  1964        2970500    5350000\n#&gt;  5 Argentina Maize  1965        3062300    5140000\n#&gt;  6 Argentina Maize  1966        3274500    7040000\n#&gt;  7 Argentina Maize  1967        3450500    8510000\n#&gt;  8 Argentina Maize  1968        3377700    6560000\n#&gt;  9 Argentina Maize  1969        3556000    6860000\n#&gt; 10 Argentina Maize  1970        4017330    9360000\n#&gt; # ℹ 2,832 more rows\n\nCom a função select(), também podemos renomear as variáveis selecionadas. Como primeiro argumento, inserimos o novo nome, seguido do sinal de = e o nome original da variável.\n\ngraos |&gt; \n  select(\n    pais = area,\n    cultura = item, \n    ano = year, \n    colheita = area_harvested, \n    producao = production\n  )\n#&gt; # A tibble: 2,842 × 5\n#&gt;    pais      cultura   ano colheita producao\n#&gt;    &lt;chr&gt;     &lt;chr&gt;   &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n#&gt;  1 Argentina Maize    1961  2744400  4850000\n#&gt;  2 Argentina Maize    1962  2756670  5220000\n#&gt;  3 Argentina Maize    1963  2645400  4360000\n#&gt;  4 Argentina Maize    1964  2970500  5350000\n#&gt;  5 Argentina Maize    1965  3062300  5140000\n#&gt;  6 Argentina Maize    1966  3274500  7040000\n#&gt;  7 Argentina Maize    1967  3450500  8510000\n#&gt;  8 Argentina Maize    1968  3377700  6560000\n#&gt;  9 Argentina Maize    1969  3556000  6860000\n#&gt; 10 Argentina Maize    1970  4017330  9360000\n#&gt; # ℹ 2,832 more rows\n\n\n7.3.2 Renomear\nPara apenas renomear alguma variável, sem realizar a seleção dessas, utilizamos a função rename().\n\ngraos |&gt; \n  rename(\n    pais = area,\n    cultura = item, \n    ano = year, \n    colheita = area_harvested, \n    producao = production\n  ) |&gt; \n  glimpse()\n#&gt; Rows: 2,842\n#&gt; Columns: 12\n#&gt; $ domain_code      &lt;chr&gt; \"QCL\", \"QCL\", \"QCL\", \"QCL\", \"QCL\", \"QCL\", \"QCL\", \"QCL…\n#&gt; $ domain           &lt;chr&gt; \"Crops and livestock products\", \"Crops and livestock …\n#&gt; $ area_code_fao    &lt;dbl&gt; 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,…\n#&gt; $ pais             &lt;chr&gt; \"Argentina\", \"Argentina\", \"Argentina\", \"Argentina\", \"…\n#&gt; $ item_code_fao    &lt;dbl&gt; 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 5…\n#&gt; $ cultura          &lt;chr&gt; \"Maize\", \"Maize\", \"Maize\", \"Maize\", \"Maize\", \"Maize\",…\n#&gt; $ year_code        &lt;dbl&gt; 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969,…\n#&gt; $ ano              &lt;dbl&gt; 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969,…\n#&gt; $ flag             &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n#&gt; $ flag_description &lt;chr&gt; \"Official data\", \"Official data\", \"Official data\", \"O…\n#&gt; $ colheita         &lt;dbl&gt; 2744400, 2756670, 2645400, 2970500, 3062300, 3274500,…\n#&gt; $ producao         &lt;dbl&gt; 4850000, 5220000, 4360000, 5350000, 5140000, 7040000,…\n\nPodemos utilizar as funções select() e rename() de forma integrada.\n\ngraos_selecionado &lt;- graos |&gt; \n  select(area, item, year, area_harvested, production) |&gt; \n  rename(\n    pais = area,\n    cultura = item, \n    ano = year, \n    colheita = area_harvested, \n    producao = production\n  )\n\ngraos_selecionado\n#&gt; # A tibble: 2,842 × 5\n#&gt;    pais      cultura   ano colheita producao\n#&gt;    &lt;chr&gt;     &lt;chr&gt;   &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n#&gt;  1 Argentina Maize    1961  2744400  4850000\n#&gt;  2 Argentina Maize    1962  2756670  5220000\n#&gt;  3 Argentina Maize    1963  2645400  4360000\n#&gt;  4 Argentina Maize    1964  2970500  5350000\n#&gt;  5 Argentina Maize    1965  3062300  5140000\n#&gt;  6 Argentina Maize    1966  3274500  7040000\n#&gt;  7 Argentina Maize    1967  3450500  8510000\n#&gt;  8 Argentina Maize    1968  3377700  6560000\n#&gt;  9 Argentina Maize    1969  3556000  6860000\n#&gt; 10 Argentina Maize    1970  4017330  9360000\n#&gt; # ℹ 2,832 more rows\n\nNote que salvamos as alterações realizadas no objeto graos_selecionado. A seguir, utilizaremos este objeto para os demais exemplos.\n\n7.3.3 Realocar\nUtilizamos a função relocate() para mover as colunas de lugar.\n\ngraos_selecionado |&gt; relocate(ano, pais, cultura, producao, colheita)\n#&gt; # A tibble: 2,842 × 5\n#&gt;      ano pais      cultura producao colheita\n#&gt;    &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;      &lt;dbl&gt;    &lt;dbl&gt;\n#&gt;  1  1961 Argentina Maize    4850000  2744400\n#&gt;  2  1962 Argentina Maize    5220000  2756670\n#&gt;  3  1963 Argentina Maize    4360000  2645400\n#&gt;  4  1964 Argentina Maize    5350000  2970500\n#&gt;  5  1965 Argentina Maize    5140000  3062300\n#&gt;  6  1966 Argentina Maize    7040000  3274500\n#&gt;  7  1967 Argentina Maize    8510000  3450500\n#&gt;  8  1968 Argentina Maize    6560000  3377700\n#&gt;  9  1969 Argentina Maize    6860000  3556000\n#&gt; 10  1970 Argentina Maize    9360000  4017330\n#&gt; # ℹ 2,832 more rows\n\nÉ possível selecionar apenas algumas colunas (não necessariamente todas as variáveis do conjunto de dados) para serem arranjadas. Por padrão, as variáveis escolhidas são realocadas para o início do conjunto de dados.\n\ngraos_selecionado |&gt; relocate(ano, pais)\n#&gt; # A tibble: 2,842 × 5\n#&gt;      ano pais      cultura colheita producao\n#&gt;    &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;      &lt;dbl&gt;    &lt;dbl&gt;\n#&gt;  1  1961 Argentina Maize    2744400  4850000\n#&gt;  2  1962 Argentina Maize    2756670  5220000\n#&gt;  3  1963 Argentina Maize    2645400  4360000\n#&gt;  4  1964 Argentina Maize    2970500  5350000\n#&gt;  5  1965 Argentina Maize    3062300  5140000\n#&gt;  6  1966 Argentina Maize    3274500  7040000\n#&gt;  7  1967 Argentina Maize    3450500  8510000\n#&gt;  8  1968 Argentina Maize    3377700  6560000\n#&gt;  9  1969 Argentina Maize    3556000  6860000\n#&gt; 10  1970 Argentina Maize    4017330  9360000\n#&gt; # ℹ 2,832 more rows\n\nPodemos especificar para onde as colunas serão movidas com os argumentos .before = e .after = (antes ou depois de determinada coluna, respectivamente).\n\ngraos_selecionado |&gt; relocate(ano, cultura, .before = pais)\n#&gt; # A tibble: 2,842 × 5\n#&gt;      ano cultura pais      colheita producao\n#&gt;    &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;\n#&gt;  1  1961 Maize   Argentina  2744400  4850000\n#&gt;  2  1962 Maize   Argentina  2756670  5220000\n#&gt;  3  1963 Maize   Argentina  2645400  4360000\n#&gt;  4  1964 Maize   Argentina  2970500  5350000\n#&gt;  5  1965 Maize   Argentina  3062300  5140000\n#&gt;  6  1966 Maize   Argentina  3274500  7040000\n#&gt;  7  1967 Maize   Argentina  3450500  8510000\n#&gt;  8  1968 Maize   Argentina  3377700  6560000\n#&gt;  9  1969 Maize   Argentina  3556000  6860000\n#&gt; 10  1970 Maize   Argentina  4017330  9360000\n#&gt; # ℹ 2,832 more rows\n\ngraos_selecionado |&gt; relocate(ano, cultura, .after = pais)\n#&gt; # A tibble: 2,842 × 5\n#&gt;    pais        ano cultura colheita producao\n#&gt;    &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;    &lt;dbl&gt;\n#&gt;  1 Argentina  1961 Maize    2744400  4850000\n#&gt;  2 Argentina  1962 Maize    2756670  5220000\n#&gt;  3 Argentina  1963 Maize    2645400  4360000\n#&gt;  4 Argentina  1964 Maize    2970500  5350000\n#&gt;  5 Argentina  1965 Maize    3062300  5140000\n#&gt;  6 Argentina  1966 Maize    3274500  7040000\n#&gt;  7 Argentina  1967 Maize    3450500  8510000\n#&gt;  8 Argentina  1968 Maize    3377700  6560000\n#&gt;  9 Argentina  1969 Maize    3556000  6860000\n#&gt; 10 Argentina  1970 Maize    4017330  9360000\n#&gt; # ℹ 2,832 more rows\n\n\n7.3.4 Modificar e criar\nPara modificar ou criar novas variáveis, utilizamos a função mutate().\n\ngraos_selecionado |&gt; mutate(producao = producao * 1000)\n#&gt; # A tibble: 2,842 × 5\n#&gt;    pais      cultura   ano colheita   producao\n#&gt;    &lt;chr&gt;     &lt;chr&gt;   &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;\n#&gt;  1 Argentina Maize    1961  2744400 4850000000\n#&gt;  2 Argentina Maize    1962  2756670 5220000000\n#&gt;  3 Argentina Maize    1963  2645400 4360000000\n#&gt;  4 Argentina Maize    1964  2970500 5350000000\n#&gt;  5 Argentina Maize    1965  3062300 5140000000\n#&gt;  6 Argentina Maize    1966  3274500 7040000000\n#&gt;  7 Argentina Maize    1967  3450500 8510000000\n#&gt;  8 Argentina Maize    1968  3377700 6560000000\n#&gt;  9 Argentina Maize    1969  3556000 6860000000\n#&gt; 10 Argentina Maize    1970  4017330 9360000000\n#&gt; # ℹ 2,832 more rows\n\nNo exemplo anterior, transformamos os valores da coluna producao, em toneladas, para quilogramas. Contudo, também podemos manter a coluna original e criar uma nova. Basta designar um novo nome à nova variável.\n\ngraos_selecionado |&gt; mutate(producao_kg = producao * 1000)\n#&gt; # A tibble: 2,842 × 6\n#&gt;    pais      cultura   ano colheita producao producao_kg\n#&gt;    &lt;chr&gt;     &lt;chr&gt;   &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;       &lt;dbl&gt;\n#&gt;  1 Argentina Maize    1961  2744400  4850000  4850000000\n#&gt;  2 Argentina Maize    1962  2756670  5220000  5220000000\n#&gt;  3 Argentina Maize    1963  2645400  4360000  4360000000\n#&gt;  4 Argentina Maize    1964  2970500  5350000  5350000000\n#&gt;  5 Argentina Maize    1965  3062300  5140000  5140000000\n#&gt;  6 Argentina Maize    1966  3274500  7040000  7040000000\n#&gt;  7 Argentina Maize    1967  3450500  8510000  8510000000\n#&gt;  8 Argentina Maize    1968  3377700  6560000  6560000000\n#&gt;  9 Argentina Maize    1969  3556000  6860000  6860000000\n#&gt; 10 Argentina Maize    1970  4017330  9360000  9360000000\n#&gt; # ℹ 2,832 more rows",
    "crumbs": [
      "Manipulações",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Funções essenciais</span>"
    ]
  },
  {
    "objectID": "dplyr.html#linhas",
    "href": "dplyr.html#linhas",
    "title": "7  Funções essenciais",
    "section": "\n7.4 Linhas",
    "text": "7.4 Linhas\nPara realizar manipulações de linhas (ou observações) de um conjunto de dados, utilizamos três principais funções: filter(), arrange() e distinct(). Discutiremos sobre cada uma a seguir.\n\n7.4.1 Filtrar\nNa Seção 3.8, tratamos sobre a lógica por trás da operação de filtragem. Nesta seção, apresentaremos a função filter(), que permite filtrar valores específicos em um conjunto de dados de forma simples e eficiente, utilizando operações lógicas para refinar a busca e extrair apenas as observações desejadas.\n\ngraos_selecionado |&gt; filter(pais == \"Chile\")\n#&gt; # A tibble: 233 × 5\n#&gt;    pais  cultura   ano colheita producao\n#&gt;    &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n#&gt;  1 Chile Maize    1961    83330   162810\n#&gt;  2 Chile Maize    1962    84560   180760\n#&gt;  3 Chile Maize    1963    84350   176020\n#&gt;  4 Chile Maize    1964    88160   241520\n#&gt;  5 Chile Maize    1965    87644   260000\n#&gt;  6 Chile Maize    1966    80700   285327\n#&gt;  7 Chile Maize    1967    92200   362200\n#&gt;  8 Chile Maize    1968    88540   320810\n#&gt;  9 Chile Maize    1969    58440   153792\n#&gt; 10 Chile Maize    1970    73860   239052\n#&gt; # ℹ 223 more rows\n\nNo exemplo anterior, filtramos apenas as observações referentes ao país Chile, contidas na coluna pais. Para isso, aplicamos a condição lógica ==, solicitando que sejam retornadas apenas as linhas em que o valor da coluna pais seja exatamente igual a Chile.\nAs demais condições lógicas apresentadas na Tabela 3.2 são aplicáveis na função filter().\nTambém podemos combinar diferentes condições lógicas sobre diferentes variáveis.\n\ngraos_selecionado |&gt; \n  filter(\n    pais %in% c(\"Brazil\", \"Argentina\", \"Chile\"),\n    ano == 2010\n  )\n#&gt; # A tibble: 12 × 5\n#&gt;    pais      cultura       ano colheita producao\n#&gt;    &lt;chr&gt;     &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n#&gt;  1 Argentina Maize        2010  2904035 22663095\n#&gt;  2 Argentina Rice, paddy  2010   215670  1243259\n#&gt;  3 Argentina Soybeans     2010 18130800 52675464\n#&gt;  4 Argentina Wheat        2010  3325457  9016373\n#&gt;  5 Brazil    Maize        2010 12678875 55364271\n#&gt;  6 Brazil    Rice, paddy  2010  2722459 11235986\n#&gt;  7 Brazil    Soybeans     2010 23327296 68756343\n#&gt;  8 Brazil    Wheat        2010  2181567  6171250\n#&gt;  9 Chile     Maize        2010   122547  1357921\n#&gt; 10 Chile     Rice, paddy  2010    24527    94673\n#&gt; 11 Chile     Soybeans     2010       NA       NA\n#&gt; 12 Chile     Wheat        2010   264304  1523921\n\nNo código anterior, com o operador %in%, filtramos apenas as observações em que a coluna pais contém um dos três valores: \"Brazil\", \"Argentina\" ou \"Chile\" e, de forma simultânea, também filtramos apenas as observações em que a coluna ano tem o valor 2010. Essa operação é equivalente a fazer o seguinte comando.\n\ngraos_selecionado |&gt; \n  filter(pais %in% c(\"Brazil\", \"Argentina\", \"Chile\") & ano == 2010)\n#&gt; # A tibble: 12 × 5\n#&gt;    pais      cultura       ano colheita producao\n#&gt;    &lt;chr&gt;     &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n#&gt;  1 Argentina Maize        2010  2904035 22663095\n#&gt;  2 Argentina Rice, paddy  2010   215670  1243259\n#&gt;  3 Argentina Soybeans     2010 18130800 52675464\n#&gt;  4 Argentina Wheat        2010  3325457  9016373\n#&gt;  5 Brazil    Maize        2010 12678875 55364271\n#&gt;  6 Brazil    Rice, paddy  2010  2722459 11235986\n#&gt;  7 Brazil    Soybeans     2010 23327296 68756343\n#&gt;  8 Brazil    Wheat        2010  2181567  6171250\n#&gt;  9 Chile     Maize        2010   122547  1357921\n#&gt; 10 Chile     Rice, paddy  2010    24527    94673\n#&gt; 11 Chile     Soybeans     2010       NA       NA\n#&gt; 12 Chile     Wheat        2010   264304  1523921\n\nCom o operador & (“E” lógico), combinamos condições que devem ser todas verdadeiras ao mesmo tempo, ou seja, uma linha só será filtrada se todas as condições apresentadas forem atendidas simultaneamente. No exemplo, filtra-se somente as linhas em que a coluna pais contém os valores \"Brazil\", \"Argentina\" ou \"Chile\" E a coluna ano é 2010.\nPor outro lado, o operador | (“OU” lógico) é usado para combinar condições onde basta que apenas uma delas seja verdadeira, ou seja, uma linha será selecionada se pelo menos uma das condições for atendida (uma condição OU a outra condição).\n\ngraos_selecionado |&gt; filter(cultura == \"Maize\" | ano == 2010)\n#&gt; # A tibble: 816 × 5\n#&gt;    pais      cultura   ano colheita producao\n#&gt;    &lt;chr&gt;     &lt;chr&gt;   &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n#&gt;  1 Argentina Maize    1961  2744400  4850000\n#&gt;  2 Argentina Maize    1962  2756670  5220000\n#&gt;  3 Argentina Maize    1963  2645400  4360000\n#&gt;  4 Argentina Maize    1964  2970500  5350000\n#&gt;  5 Argentina Maize    1965  3062300  5140000\n#&gt;  6 Argentina Maize    1966  3274500  7040000\n#&gt;  7 Argentina Maize    1967  3450500  8510000\n#&gt;  8 Argentina Maize    1968  3377700  6560000\n#&gt;  9 Argentina Maize    1969  3556000  6860000\n#&gt; 10 Argentina Maize    1970  4017330  9360000\n#&gt; # ℹ 806 more rows\n\nPor fim, podemos excluir determinadas observações com o operador !.\n\ngraos_selecionado |&gt; filter(!(ano %in% 1962:2018))\n#&gt; # A tibble: 94 × 5\n#&gt;    pais                             cultura       ano colheita producao\n#&gt;    &lt;chr&gt;                            &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n#&gt;  1 Argentina                        Maize        1961  2744400  4850000\n#&gt;  2 Argentina                        Maize        2019  7232761 56860704\n#&gt;  3 Argentina                        Rice, paddy  1961    46000   149000\n#&gt;  4 Argentina                        Rice, paddy  2019   183285  1189866\n#&gt;  5 Argentina                        Soybeans     1961      980      957\n#&gt;  6 Argentina                        Soybeans     2019 16575887 55263891\n#&gt;  7 Argentina                        Wheat        1961  4420900  5725000\n#&gt;  8 Argentina                        Wheat        2019  6050953 19459727\n#&gt;  9 Bolivia (Plurinational State of) Maize        1961   207030   258800\n#&gt; 10 Bolivia (Plurinational State of) Maize        2019   468080   987503\n#&gt; # ℹ 84 more rows\n\nNo exemplo anterior, excluímos todas as observações contidas entre os anos de 1962 e 2018.\n\n7.4.2 Ordenar\nCom a função arrange(), podemos ordenar as linhas de acordo com alguma variável.\n\ngraos_selecionado |&gt; arrange(producao)\n#&gt; # A tibble: 2,842 × 5\n#&gt;    pais          cultura    ano colheita producao\n#&gt;    &lt;chr&gt;         &lt;chr&gt;    &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n#&gt;  1 Chile         Soybeans  1990        0        0\n#&gt;  2 Chile         Soybeans  1991        0        0\n#&gt;  3 Chile         Soybeans  1992        0        0\n#&gt;  4 Chile         Soybeans  1988       NA        0\n#&gt;  5 French Guyana Maize     1990        0        0\n#&gt;  6 French Guyana Soybeans  1990        0        0\n#&gt;  7 French Guyana Soybeans  1991        0        0\n#&gt;  8 French Guyana Soybeans  1992        0        0\n#&gt;  9 Guyana        Soybeans  1990        0        0\n#&gt; 10 Guyana        Soybeans  1991        0        0\n#&gt; # ℹ 2,832 more rows\n\nPor padrão, a função arrange() ordena os valores em ordem crescente. Para ordená-las em ordem decrescente, utilizamos a função desc() dentro da função arrange().\n\ngraos_selecionado |&gt; arrange(desc(producao))\n#&gt; # A tibble: 2,842 × 5\n#&gt;    pais   cultura    ano colheita  producao\n#&gt;    &lt;chr&gt;  &lt;chr&gt;    &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt;  1 Brazil Soybeans  2018 34777936 117912450\n#&gt;  2 Brazil Soybeans  2017 33959879 114732101\n#&gt;  3 Brazil Soybeans  2019 35881447 114269392\n#&gt;  4 Brazil Maize     2019 17518054 101138617\n#&gt;  5 Brazil Maize     2017 17427206  97910658\n#&gt;  6 Brazil Soybeans  2015 32181243  97464936\n#&gt;  7 Brazil Soybeans  2016 33183119  96394820\n#&gt;  8 Brazil Soybeans  2014 30273763  86760520\n#&gt;  9 Brazil Maize     2015 15407143  85283074\n#&gt; 10 Brazil Maize     2018 16126368  82366531\n#&gt; # ℹ 2,832 more rows\n\nAlém disso, podemos ordenar as observações com base em duas ou mais variáveis, sejam elas quantitativas ou qualitativas.\n\ngraos_selecionado |&gt; arrange(pais, producao)\n#&gt; # A tibble: 2,842 × 5\n#&gt;    pais      cultura    ano colheita producao\n#&gt;    &lt;chr&gt;     &lt;chr&gt;    &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n#&gt;  1 Argentina Soybeans  1961      980      957\n#&gt;  2 Argentina Soybeans  1962     9649    11220\n#&gt;  3 Argentina Soybeans  1964    12220    14000\n#&gt;  4 Argentina Soybeans  1965    16422    17000\n#&gt;  5 Argentina Soybeans  1966    15689    18200\n#&gt;  6 Argentina Soybeans  1963    19302    18920\n#&gt;  7 Argentina Soybeans  1967    17290    20500\n#&gt;  8 Argentina Soybeans  1968    20200    22000\n#&gt;  9 Argentina Soybeans  1970    25970    26800\n#&gt; 10 Argentina Soybeans  1969    28200    31800\n#&gt; # ℹ 2,832 more rows\n\ngraos_selecionado |&gt; arrange(producao, pais)\n#&gt; # A tibble: 2,842 × 5\n#&gt;    pais          cultura    ano colheita producao\n#&gt;    &lt;chr&gt;         &lt;chr&gt;    &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n#&gt;  1 Chile         Soybeans  1990        0        0\n#&gt;  2 Chile         Soybeans  1991        0        0\n#&gt;  3 Chile         Soybeans  1992        0        0\n#&gt;  4 Chile         Soybeans  1988       NA        0\n#&gt;  5 French Guyana Maize     1990        0        0\n#&gt;  6 French Guyana Soybeans  1990        0        0\n#&gt;  7 French Guyana Soybeans  1991        0        0\n#&gt;  8 French Guyana Soybeans  1992        0        0\n#&gt;  9 Guyana        Soybeans  1990        0        0\n#&gt; 10 Guyana        Soybeans  1991        0        0\n#&gt; # ℹ 2,832 more rows\n\nPerceba que a ordem de declaração das variáveis na função arrange() altera a prioridade da ordenação. No exemplo anterior, primeiro, organizamos os nomes dos países por ordem alfabética para depois ordenar pelos valores de produção. No outro caso, começamos a ordenar os valores de produção para depois organizar, alfabeticamente, os nomes dos países, tendo assim um resultado distinto do exemplo anterior.\n\n7.4.3 Distinguir\nA função distinct() é utilizada para remover observações duplicadas. Veja o exmeplo a seguir.\n\ndados &lt;- tibble(\n  pais = c(\"Brasil\", \"Brasil\", \"Argentina\", \"Argentina\", \"Chile\"),\n  ano = c(2020, 2021, 2021, 2021, 2020),\n  producao_cevada = c(50, 60, 110, 110, 85)\n)\ndados\n#&gt; # A tibble: 5 × 3\n#&gt;   pais        ano producao_cevada\n#&gt;   &lt;chr&gt;     &lt;dbl&gt;           &lt;dbl&gt;\n#&gt; 1 Brasil     2020              50\n#&gt; 2 Brasil     2021              60\n#&gt; 3 Argentina  2021             110\n#&gt; 4 Argentina  2021             110\n#&gt; 5 Chile      2020              85\n\nNo data frame dados, há uma observação duplicada referente à produção de cevada na Argentina no ano de 2021.\n\ndados |&gt; distinct()\n#&gt; # A tibble: 4 × 3\n#&gt;   pais        ano producao_cevada\n#&gt;   &lt;chr&gt;     &lt;dbl&gt;           &lt;dbl&gt;\n#&gt; 1 Brasil     2020              50\n#&gt; 2 Brasil     2021              60\n#&gt; 3 Argentina  2021             110\n#&gt; 4 Chile      2020              85\n\nCom a função distinct(), removemos a linha duplicada. Ou seja, ela verifica todas as colunas e exclui as linhas que são idênticas em todas as colunas.\nTambém podemos aplicar a função para determinadas colunas.\n\ndados |&gt; distinct(pais)\n#&gt; # A tibble: 3 × 1\n#&gt;   pais     \n#&gt;   &lt;chr&gt;    \n#&gt; 1 Brasil   \n#&gt; 2 Argentina\n#&gt; 3 Chile\n\nEsse comando mantém apenas as observações exclusivas da coluna pais, descartando todas as outras informações associadas.\nPara manter as outras colunas ao filtrar por linhas exclusivas, podemos usar o argumento .keep_all = TRUE.\n\ndados |&gt; distinct(pais, .keep_all = TRUE)\n#&gt; # A tibble: 3 × 3\n#&gt;   pais        ano producao_cevada\n#&gt;   &lt;chr&gt;     &lt;dbl&gt;           &lt;dbl&gt;\n#&gt; 1 Brasil     2020              50\n#&gt; 2 Argentina  2021             110\n#&gt; 3 Chile      2020              85\n\nCom isso, mantém-se apenas uma linha para cada valor único na coluna pais, ignorando as demais colunas. Com isso, o R seleciona a primeira ocorrência de cada valor único de pais, e as outras colunas (como ano e producao_milho) são mantidas com os valores correspondentes à primeira linha de cada país.",
    "crumbs": [
      "Manipulações",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Funções essenciais</span>"
    ]
  },
  {
    "objectID": "dplyr.html#sec-group-summ",
    "href": "dplyr.html#sec-group-summ",
    "title": "7  Funções essenciais",
    "section": "\n7.5 Grupos",
    "text": "7.5 Grupos\nO pacote dplyr possui funções que nos permite trabalhar com grupos de variáveis. Nesta seção, abordaremos as seguintes funções: summarise(), group_by() e a família de funções slice_().\n\n7.5.1 summarise() e group_by()\n\nA função summarise() calcula medidas-resumo de variáveis quantitativas. Ela resume os dados de determinada observação exclusiva de acordo com uma medida de interesse, como a média, mediana, frequência, proporção, dentre outras.\n\ngraos_selecionado |&gt; \n  summarise(\n    media_producao = mean(producao, na.rm = TRUE),\n    media_colheita = mean(colheita, na.rm = TRUE),\n    max_producao = max(producao, na.rm = TRUE),\n    max_colheita = max(colheita, na.rm = TRUE)\n  )\n#&gt; # A tibble: 1 × 4\n#&gt;   media_producao media_colheita max_producao max_colheita\n#&gt;            &lt;dbl&gt;          &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;\n#&gt; 1       3130662.       1185376.    117912450     35881447\n\nO argumento na.rm = TRUE ignora os valores NA para o cálculo da média e produção máxima. Trataremos com mais detalhes sobre esse assunto no ?sec-val-ausentes.\nPara calcular medidas agrupadas de acordo com mais de uma variável, utilizamos a função group_by()1. No exemplo abaixo, agruparemos a variável pais para calcular a média e o valor máximo de produção (production) e de área colhida (area harvested) por país.\n\ngraos_selecionado |&gt; \n  group_by(pais) |&gt; \n  summarise(\n    media_producao = mean(producao, na.rm = TRUE),\n    media_colheita = mean(colheita, na.rm = TRUE),\n    max_producao = max(producao, na.rm = TRUE),\n    max_colheita = max(colheita, na.rm = TRUE)\n  )\n#&gt; # A tibble: 13 × 5\n#&gt;    pais                  media_producao media_colheita max_producao max_colheita\n#&gt;    &lt;chr&gt;                          &lt;dbl&gt;          &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;\n#&gt;  1 Argentina                  11069997.       3889868.     61446556     19504648\n#&gt;  2 Bolivia (Plurination…        445249.        243134.      3203992      1387973\n#&gt;  3 Brazil                     19638343.       7735115.    117912450     35881447\n#&gt;  4 Chile                        637716.        179720.      1921652       779966\n#&gt;  5 Colombia                     753641.        280305.      3292983       868867\n#&gt;  6 Ecuador                      377982.        168084.      1873525       577784\n#&gt;  7 French Guyana                  5780.          1885.        31544         9281\n#&gt;  8 Guyana                       182259.         54487.      1050000       206428\n#&gt;  9 Paraguay                    1134512.        444338.     11045971      3565000\n#&gt; 10 Peru                         625835.        190828.      3557900       514945\n#&gt; 11 Suriname                      67796.         17442.       301971        75136\n#&gt; 12 Uruguay                      479607.        184556.      3212000      1334000\n#&gt; 13 Venezuela (Bolivaria…        493956.        183419.      2638010       791545\n\nTambém podemos agrupar a partir de duas ou mais variáveis. A seguir, agruparemos as colunas pais e cultura para calcular a média e o máximo da produção e da área colhida por país e por tipo de cultura.\n\ngraos_selecionado |&gt; \n  group_by(pais, cultura) |&gt; \n  summarise(\n    media_producao = mean(producao, na.rm = TRUE),\n    media_colheita = mean(colheita, na.rm = TRUE),\n    max_producao = max(producao, na.rm = TRUE),\n    max_colheita = max(colheita, na.rm = TRUE)\n  )\n#&gt; # A tibble: 49 × 6\n#&gt; # Groups:   pais [13]\n#&gt;    pais          cultura media_producao media_colheita max_producao max_colheita\n#&gt;    &lt;chr&gt;         &lt;chr&gt;            &lt;dbl&gt;          &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;\n#&gt;  1 Argentina     Maize        14812880.       3243095.     56860704      7232761\n#&gt;  2 Argentina     Rice, …        714791.        135827.      1748075       289200\n#&gt;  3 Argentina     Soybea…      17941231.       6967484.     61446556     19504648\n#&gt;  4 Argentina     Wheat        10811085.       5213066.     19459727      7364200\n#&gt;  5 Bolivia (Plu… Maize          552919.        297456.      1260926       468080\n#&gt;  6 Bolivia (Plu… Rice, …        234899.        108135.       600044       194237\n#&gt;  7 Bolivia (Plu… Soybea…        922200.        472537.      3203992      1387973\n#&gt;  8 Bolivia (Plu… Wheat          111395.        117736.       337599       229822\n#&gt;  9 Brazil        Maize        33776948.      12033678.    101138617     17518054\n#&gt; 10 Brazil        Rice, …       9467493.       4056617.     13476994      6656480\n#&gt; # ℹ 39 more rows\n\n\n7.5.2 Funções slice_()\n\nA família de funções slice_() permite extrair observações baseada em sua posição no data frame.\n\n\nslice_head(): seleciona as n primeiras linhas.\n\n\ngraos_selecionado |&gt; slice_head(n = 2)\n#&gt; # A tibble: 2 × 5\n#&gt;   pais      cultura   ano colheita producao\n#&gt;   &lt;chr&gt;     &lt;chr&gt;   &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n#&gt; 1 Argentina Maize    1961  2744400  4850000\n#&gt; 2 Argentina Maize    1962  2756670  5220000\n\nTambém podemos utilizar proporções de linhas com o argumento prop =, cujo valor varia de 0 a 1.\n\ngraos_selecionado |&gt; slice_head(prop = 0.01)\n#&gt; # A tibble: 28 × 5\n#&gt;    pais      cultura   ano colheita producao\n#&gt;    &lt;chr&gt;     &lt;chr&gt;   &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n#&gt;  1 Argentina Maize    1961  2744400  4850000\n#&gt;  2 Argentina Maize    1962  2756670  5220000\n#&gt;  3 Argentina Maize    1963  2645400  4360000\n#&gt;  4 Argentina Maize    1964  2970500  5350000\n#&gt;  5 Argentina Maize    1965  3062300  5140000\n#&gt;  6 Argentina Maize    1966  3274500  7040000\n#&gt;  7 Argentina Maize    1967  3450500  8510000\n#&gt;  8 Argentina Maize    1968  3377700  6560000\n#&gt;  9 Argentina Maize    1969  3556000  6860000\n#&gt; 10 Argentina Maize    1970  4017330  9360000\n#&gt; # ℹ 18 more rows\n\nNo exemplo anterior, selecionamos 1% (prop = 0.01) das primeiras linhas do conjunto de dados.\n\n\nslice_tail(): seleciona as n últimas linhas.\n\n\ngraos_selecionado |&gt; slice_tail(n = 2)\n#&gt; # A tibble: 2 × 5\n#&gt;   pais                               cultura   ano colheita producao\n#&gt;   &lt;chr&gt;                              &lt;chr&gt;   &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n#&gt; 1 Venezuela (Bolivarian Republic of) Wheat    2009       NA      143\n#&gt; 2 Venezuela (Bolivarian Republic of) Wheat    2010       NA      183\n\nOu ainda, seleciona p% das últimas linhas do conjunto de dados.\n\ngraos_selecionado |&gt; slice_tail(prop = 0.01)\n#&gt; # A tibble: 28 × 5\n#&gt;    pais                               cultura   ano colheita producao\n#&gt;    &lt;chr&gt;                              &lt;chr&gt;   &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n#&gt;  1 Venezuela (Bolivarian Republic of) Wheat    2009       48       NA\n#&gt;  2 Venezuela (Bolivarian Republic of) Wheat    2010       61       NA\n#&gt;  3 Venezuela (Bolivarian Republic of) Wheat    2011       68      204\n#&gt;  4 Venezuela (Bolivarian Republic of) Wheat    2012       73      218\n#&gt;  5 Venezuela (Bolivarian Republic of) Wheat    2013       54      161\n#&gt;  6 Venezuela (Bolivarian Republic of) Wheat    2014       54      161\n#&gt;  7 Venezuela (Bolivarian Republic of) Wheat    2015       60      179\n#&gt;  8 Venezuela (Bolivarian Republic of) Wheat    2016       47      140\n#&gt;  9 Venezuela (Bolivarian Republic of) Wheat    2017      209      584\n#&gt; 10 Venezuela (Bolivarian Republic of) Wheat    2018      431     1151\n#&gt; # ℹ 18 more rows\n\n\n\nslice_min(): seleciona a linha com o menor valor de determinada variável.\n\n\ngraos_selecionado |&gt; slice_min(order_by = producao)\n#&gt; # A tibble: 11 × 5\n#&gt;    pais          cultura    ano colheita producao\n#&gt;    &lt;chr&gt;         &lt;chr&gt;    &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n#&gt;  1 Chile         Soybeans  1990        0        0\n#&gt;  2 Chile         Soybeans  1991        0        0\n#&gt;  3 Chile         Soybeans  1992        0        0\n#&gt;  4 Chile         Soybeans  1988       NA        0\n#&gt;  5 French Guyana Maize     1990        0        0\n#&gt;  6 French Guyana Soybeans  1990        0        0\n#&gt;  7 French Guyana Soybeans  1991        0        0\n#&gt;  8 French Guyana Soybeans  1992        0        0\n#&gt;  9 Guyana        Soybeans  1990        0        0\n#&gt; 10 Guyana        Soybeans  1991        0        0\n#&gt; 11 Guyana        Soybeans  1992        0        0\n\nNote que a função nos retorna todas as linhas com o menor valor de produção, no caso, o valor zero. Caso queira selecionar n linhas e não todas as linhas com menor valor de determinada variável, devemos declarar a quantidade de linhas em n = junto ao argumento with_ties = FALSE.\n\ngraos_selecionado |&gt; slice_min(order_by = producao, n = 5, with_ties = FALSE)\n#&gt; # A tibble: 5 × 5\n#&gt;   pais          cultura    ano colheita producao\n#&gt;   &lt;chr&gt;         &lt;chr&gt;    &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n#&gt; 1 Chile         Soybeans  1990        0        0\n#&gt; 2 Chile         Soybeans  1991        0        0\n#&gt; 3 Chile         Soybeans  1992        0        0\n#&gt; 4 Chile         Soybeans  1988       NA        0\n#&gt; 5 French Guyana Maize     1990        0        0\n\n\n\nslice_max(): seleciona a linha com o maior valor de determinada variável.\n\n\ngraos_selecionado |&gt; slice_max(order_by = producao)\n#&gt; # A tibble: 1 × 5\n#&gt;   pais   cultura    ano colheita  producao\n#&gt;   &lt;chr&gt;  &lt;chr&gt;    &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Brazil Soybeans  2018 34777936 117912450\n\nDe forma semelhante apresentada para a slice_min(), podemos selecionar as n linhas com maior valor de certa variável.\n\ngraos_selecionado |&gt; slice_max(order_by = producao, n = 5)\n#&gt; # A tibble: 5 × 5\n#&gt;   pais   cultura    ano colheita  producao\n#&gt;   &lt;chr&gt;  &lt;chr&gt;    &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Brazil Soybeans  2018 34777936 117912450\n#&gt; 2 Brazil Soybeans  2017 33959879 114732101\n#&gt; 3 Brazil Soybeans  2019 35881447 114269392\n#&gt; 4 Brazil Maize     2019 17518054 101138617\n#&gt; 5 Brazil Maize     2017 17427206  97910658\n\n\n\nslice_sample(): seleciona n linhas de forma aleatória.\n\n\ngraos_selecionado |&gt; slice_sample(n = 5)\n#&gt; # A tibble: 5 × 5\n#&gt;   pais                               cultura       ano colheita producao\n#&gt;   &lt;chr&gt;                              &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n#&gt; 1 Brazil                             Wheat        1997  1521545  2489070\n#&gt; 2 Brazil                             Soybeans     1973  3615058  5011614\n#&gt; 3 Colombia                           Maize        1990   836900  1213300\n#&gt; 4 Guyana                             Rice, paddy  1975   134000   292000\n#&gt; 5 Venezuela (Bolivarian Republic of) Wheat        1966     2854     1427\n\ngraos_selecionado |&gt; slice_sample(n = 5)\n#&gt; # A tibble: 5 × 5\n#&gt;   pais     cultura       ano colheita producao\n#&gt;   &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n#&gt; 1 Ecuador  Soybeans     1962       65       80\n#&gt; 2 Chile    Maize        1970    73860   239052\n#&gt; 3 Chile    Rice, paddy  1976    28590    97640\n#&gt; 4 Suriname Rice, paddy  1974    44353   162417\n#&gt; 5 Brazil   Wheat        1969  1407115  1373691\n\nPor fim, podemos selecionar uma certa quantidade de observações de acordo com determinado agrupamento de variáveis. Para isso, utilizamos a função group_by().\n\ngraos_selecionado |&gt; \n  group_by(cultura) |&gt; \n  slice_max(producao)\n#&gt; # A tibble: 4 × 5\n#&gt; # Groups:   cultura [4]\n#&gt;   pais      cultura       ano colheita  producao\n#&gt;   &lt;chr&gt;     &lt;chr&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Brazil    Maize        2019 17518054 101138617\n#&gt; 2 Brazil    Rice, paddy  2011  2752891  13476994\n#&gt; 3 Brazil    Soybeans     2018 34777936 117912450\n#&gt; 4 Argentina Wheat        2019  6050953  19459727\n\nNo exemplo anterior, selecionamos as linhas com maior produção de acordo com o tipo de cultura.",
    "crumbs": [
      "Manipulações",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Funções essenciais</span>"
    ]
  },
  {
    "objectID": "dplyr.html#resumo",
    "href": "dplyr.html#resumo",
    "title": "7  Funções essenciais",
    "section": "\n7.6 Resumo",
    "text": "7.6 Resumo\nNeste capítulo, apresentamos as principais ferramentas do pacote dplyr para a manipulação e transformação de data frames. Grande parte dos desafios dessa etapa na ciência de dados podem ser resolvidos com as funções abordadas até aqui. Dessa forma, é essencial que o leitor dedique um tempo significativo para estudá-las e compreender seu funcionamento em diferentes contextos.\nA seguir, apresentaremos funções que permitem combinar múltiplos conjuntos de dados relacionados: as famílias de funções bind_(), que unem dados de forma simples, e _join(), que realizam junções mais estruturadas com base em colunas comuns.",
    "crumbs": [
      "Manipulações",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Funções essenciais</span>"
    ]
  },
  {
    "objectID": "dplyr.html#footnotes",
    "href": "dplyr.html#footnotes",
    "title": "7  Funções essenciais",
    "section": "",
    "text": "A versão mais recente do pacote dplyr (dplyr 1.1.0) traz uma nova possibilidade para agrupar variáveis, a .by/by. Essa novidade atua de modo análogo à função group_by(), porém com uma sintaxe de código diferente. Para saber mais, acesse: https://www.tidyverse.org/blog/2023/02/dplyr-1-1-0-per-operation-grouping/.↩︎",
    "crumbs": [
      "Manipulações",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Funções essenciais</span>"
    ]
  },
  {
    "objectID": "joins.html",
    "href": "joins.html",
    "title": "8  Dados relacionais",
    "section": "",
    "text": "8.1 Introdução\nEm diversas situações, precisamos utilizar informações provenientes de diferentes bases de dados, como no caso de planilhas Excel distintas. Para isso, é necessário juntar todas as informações em um único data frame.\nO pacote dplyr oferece diversas funções que facilitam esse processo. Neste capítulo, apresentaremos as funções das famílias bind_() e _join().\nlibrary(dplyr)\nUsaremos a planilha dados-juntar.xlsx para os exemplos. Para fazer o download do arquivo, clique aqui.\nlibrary(readxl)\n\nexcel_sheets(\"dados/dados-juntar.xlsx\")\n#&gt; [1] \"dados1\" \"dados2\" \"dados3\" \"dados4\" \"dados5\"\nCom a função excel_sheets(), verificamos que a planilha contém 5 abas, todas relacionadas a um mesmo tema, que precisamos consolidar em um único data frame. Assim, devemos carregar cada aba da planilha em objetos distintos.\nd1 &lt;- read_excel(\"dados/dados-juntar.xlsx\", sheet = \"dados1\")\nd1\n#&gt; # A tibble: 2 × 4\n#&gt;   nome   sexo  idade  peso\n#&gt;   &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 Amanda F        25    63\n#&gt; 2 Maria  F        30    65\n\nd2 &lt;- read_excel(\"dados/dados-juntar.xlsx\", sheet = \"dados2\")\nd2\n#&gt; # A tibble: 2 × 4\n#&gt;   nome    sexo  idade  peso\n#&gt;   &lt;chr&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 Vitor   M        24    73\n#&gt; 2 Leticia F        23    52\n\nd3 &lt;- read_excel(\"dados/dados-juntar.xlsx\", sheet = \"dados3\")\nd3\n#&gt; # A tibble: 2 × 4\n#&gt;   sexo  nome     peso idade\n#&gt;   &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 F     Vitoria    51    21\n#&gt; 2 M     Marcos     68    18\n\nd4 &lt;- read_excel(\"dados/dados-juntar.xlsx\", sheet = \"dados4\")\nd4\n#&gt; # A tibble: 2 × 4\n#&gt;   nomes sexo  idade  peso\n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 Julio M        25    72\n#&gt; 2 Fabio M        35    81\n\nd5 &lt;- read_excel(\"dados/dados-juntar.xlsx\", sheet = \"dados5\")\nd5\n#&gt; # A tibble: 8 × 2\n#&gt;   nome      profissao  \n#&gt;   &lt;chr&gt;     &lt;chr&gt;      \n#&gt; 1 Fabio     Medico     \n#&gt; 2 Gabriel   Estudante  \n#&gt; 3 Guilherme Cozinheiro \n#&gt; 4 Jose      Biologo    \n#&gt; 5 Julio     Zootecnista\n#&gt; 6 Marcos    Professor  \n#&gt; 7 Vitor     Agronomo   \n#&gt; 8 Getulio   Musico",
    "crumbs": [
      "Manipulações",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Dados relacionais</span>"
    ]
  },
  {
    "objectID": "joins.html#funções-bind_",
    "href": "joins.html#funções-bind_",
    "title": "8  Dados relacionais",
    "section": "\n8.2 Funções bind_()\n",
    "text": "8.2 Funções bind_()\n\nAs funções do tipo bind_() são as mais simples para combinar conjuntos de dados. A função bind_rows() permite unir as observações (linhas) de dois ou mais data frames com base nas colunas. Essa abordagem é útil quando os conjuntos de dados compartilham a mesma estrutura de variáveis (colunas), mas contêm observações diferentes.\nCom essa função, podemos realizar a união dos data frames d1, d2, d3 e d4, que possuem as mesmas variáveis, porém tratando de diferentes observações.\nPrimeiramente, uniremos as bases d1 e d2. Para isso, utilizamos a função bind_rows(), declarando os data frames que desejamos combinar, separados por vírgula.\n\nd1_d2 &lt;- bind_rows(d1, d2)\nd1_d2\n#&gt; # A tibble: 4 × 4\n#&gt;   nome    sexo  idade  peso\n#&gt;   &lt;chr&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 Amanda  F        25    63\n#&gt; 2 Maria   F        30    65\n#&gt; 3 Vitor   M        24    73\n#&gt; 4 Leticia F        23    52\n\nUma vez unidos os dados de d1 e d2, juntaremos com o d3. Note que as colunas do data frame d3 apresentam uma ordem diferente em relação às de d1 e de d2. Apesar disso, a função bind_rows() consegue combinar as linhas de maneira adequada, desde que os nomes das colunas dos conjuntos de dados sejam iguais.\n\nd1_d2_d3 &lt;- bind_rows(d1_d2, d3)\nd1_d2_d3\n#&gt; # A tibble: 6 × 4\n#&gt;   nome    sexo  idade  peso\n#&gt;   &lt;chr&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 Amanda  F        25    63\n#&gt; 2 Maria   F        30    65\n#&gt; 3 Vitor   M        24    73\n#&gt; 4 Leticia F        23    52\n#&gt; 5 Vitoria F        21    51\n#&gt; 6 Marcos  M        18    68\n\nA função bind_rows() também consegue juntar mais de dois conjuntos de dados em um só comando. Basta declararmos os data frames que desejamos combinar.\n\nd1_d2_d3_d4 &lt;- bind_rows(d1, d2, d3, d4)\nd1_d2_d3_d4\n#&gt; # A tibble: 8 × 5\n#&gt;   nome    sexo  idade  peso nomes\n#&gt;   &lt;chr&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\n#&gt; 1 Amanda  F        25    63 &lt;NA&gt; \n#&gt; 2 Maria   F        30    65 &lt;NA&gt; \n#&gt; 3 Vitor   M        24    73 &lt;NA&gt; \n#&gt; 4 Leticia F        23    52 &lt;NA&gt; \n#&gt; 5 Vitoria F        21    51 &lt;NA&gt; \n#&gt; 6 Marcos  M        18    68 &lt;NA&gt; \n#&gt; 7 &lt;NA&gt;    M        25    72 Julio\n#&gt; 8 &lt;NA&gt;    M        35    81 Fabio\n\nJuntando os dados de d4 com os dados de d1, d2 e d3, percebemos que foi criada uma nova coluna. Isso ocorre pois a nomenclatura atribuída à variável nome no d4 está no plural. Sendo assim, precisamos padronizar o nome dessa variável antes de juntá-la às demais utilizando a função rename() (vide Seção 7.3.2).\n\nd4_corrigido &lt;- d4 |&gt; rename(\"nome\" = nomes)\n\nnames(d4_corrigido)\n#&gt; [1] \"nome\"  \"sexo\"  \"idade\" \"peso\"\n\n\nd1_d2_d3_d4 &lt;- bind_rows(d1, d2, d3, d4_corrigido)\nd1_d2_d3_d4\n#&gt; # A tibble: 8 × 4\n#&gt;   nome    sexo  idade  peso\n#&gt;   &lt;chr&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 Amanda  F        25    63\n#&gt; 2 Maria   F        30    65\n#&gt; 3 Vitor   M        24    73\n#&gt; 4 Leticia F        23    52\n#&gt; 5 Vitoria F        21    51\n#&gt; 6 Marcos  M        18    68\n#&gt; 7 Julio   M        25    72\n#&gt; 8 Fabio   M        35    81\n\nDessa forma, ao realizar a junção dos quatro conjuntos de dados, os nomes são alocados em uma única coluna (nome).\nDe modo análogo à bind_rows(), a função bind_cols() une colunas de dois ou mais conjuntos de dados. A seguir, juntaremos as colunas dos data frames d1_d2_d3_d4 e d5.\n\nd1_d2_d3_d4_d5 &lt;- bind_cols(d1_d2_d3_d4, d5)\nd1_d2_d3_d4_d5\n#&gt; # A tibble: 8 × 6\n#&gt;   nome...1 sexo  idade  peso nome...5  profissao  \n#&gt;   &lt;chr&gt;    &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;      \n#&gt; 1 Amanda   F        25    63 Fabio     Medico     \n#&gt; 2 Maria    F        30    65 Gabriel   Estudante  \n#&gt; 3 Vitor    M        24    73 Guilherme Cozinheiro \n#&gt; 4 Leticia  F        23    52 Jose      Biologo    \n#&gt; 5 Vitoria  F        21    51 Julio     Zootecnista\n#&gt; 6 Marcos   M        18    68 Marcos    Professor  \n#&gt; 7 Julio    M        25    72 Vitor     Agronomo   \n#&gt; 8 Fabio    M        35    81 Getulio   Musico\n\nNote que a função juntou as colunas, preservando todas as variáveis, bem como a ordem original das linhas das bases de dados. Porém, nesse caso, seria conveniente unir as colunas com base na variável em comum entre os conjuntos, no caso, a variável nome. Para isso, utilizamos um outro conjunto de funções, as do tipo _join.",
    "crumbs": [
      "Manipulações",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Dados relacionais</span>"
    ]
  },
  {
    "objectID": "joins.html#funções-_join",
    "href": "joins.html#funções-_join",
    "title": "8  Dados relacionais",
    "section": "\n8.3 Funções _join()\n",
    "text": "8.3 Funções _join()\n\nAs funções da família _join() (também conhecidas por merge) são utilizadas para combinar data frames com base em uma ou mais colunas em comum. Elas são úteis quando precisamos integrar dados complementares provenientes de diferentes fontes. A figura Figura 8.1 ilustra as possíveis operações a serem realizadas.\n\n\n\n\n\n\n\nFigura 8.1: Diagrama ilustrando os diferentes tipos de _join.\nFonte: R for Data Science, 2017.\n\n\n\n\nNo exemplo anterior, você deve ter notado que o data frame d5 possui observações em comum com o d1_d2_d3_d4, mas também, diferentes. Nesse caso, de acordo com o interesse da análise, podemos proceder de diferentes maneiras.\n\n8.3.1 inner_join()\n\nA função inner_join() retorna apenas as observações em comum entre dois conjuntos de dados, de acordo com certa variável.\n\n\n\n\n\n\n\nFigura 8.2: Esquematização da função inner_join(), que retorna as observações em comum entre os dois conjuntos de dados.\nFonte: R for Data Science, 2017.\n\n\n\n\n\nd_inner &lt;- inner_join(x = d1_d2_d3_d4, y = d5, by = \"nome\")\nd_inner\n#&gt; # A tibble: 4 × 5\n#&gt;   nome   sexo  idade  peso profissao  \n#&gt;   &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;      \n#&gt; 1 Vitor  M        24    73 Agronomo   \n#&gt; 2 Marcos M        18    68 Professor  \n#&gt; 3 Julio  M        25    72 Zootecnista\n#&gt; 4 Fabio  M        35    81 Medico\n\nNa função acima, declaramos os dois data frames a serem combinados, junto ao argumento by = \"nome\", ou seja, a variável em comum. Como resultado, a inner_join() nos retornou apenas as observações em comum entre os conjuntos de dados, em relação à coluna nome.\nCaso haja mais de uma variável em comum, basta declarar um vetor com as variáveis no argumento by = (by = c(\"var_1\", \"var_2\", ..., \"var_n\")). Atente-se ao fato que as variáveis devem estar entre aspas.\n\n8.3.2 full_join()\n\nA função full_join() nos retorna todas as observações de ambos os data frames, atribuindo o valor NA quando não houver correspondência em um deles.\n\n\n\n\n\n\n\nFigura 8.3: Esquematização da função full_join(), que retorna todas as observações de ambos os conjuntos.\nFonte: R for Data Science, 2017.\n\n\n\n\n\nd_full &lt;- full_join(x = d1_d2_d3_d4, y = d5, by = \"nome\")\nd_full\n#&gt; # A tibble: 12 × 5\n#&gt;    nome      sexo  idade  peso profissao  \n#&gt;    &lt;chr&gt;     &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;      \n#&gt;  1 Amanda    F        25    63 &lt;NA&gt;       \n#&gt;  2 Maria     F        30    65 &lt;NA&gt;       \n#&gt;  3 Vitor     M        24    73 Agronomo   \n#&gt;  4 Leticia   F        23    52 &lt;NA&gt;       \n#&gt;  5 Vitoria   F        21    51 &lt;NA&gt;       \n#&gt;  6 Marcos    M        18    68 Professor  \n#&gt;  7 Julio     M        25    72 Zootecnista\n#&gt;  8 Fabio     M        35    81 Medico     \n#&gt;  9 Gabriel   &lt;NA&gt;     NA    NA Estudante  \n#&gt; 10 Guilherme &lt;NA&gt;     NA    NA Cozinheiro \n#&gt; 11 Jose      &lt;NA&gt;     NA    NA Biologo    \n#&gt; 12 Getulio   &lt;NA&gt;     NA    NA Musico\n\n\n8.3.3 left_join() e right_join()\n\nA função left_join() mantém todas as observações do primeiro conjunto declarado (x =) e adiciona os valores em comum do segundo conjunto (y =).\nPor outro lado, a right_join() retorna todas as observações do segundo conjunto (y =) e adiciona os valores em comum do primeiro conjunto (x =).\nCaso não haja correspondência entre os conjuntos, serão atribuídos valores NA.\n\n\n\n\n\n\n\nFigura 8.4: Esquematização das funções left_join() e right_join(), que retornam todas as observações presentes no primeiro e no segundo conjunto de dados, respectivamente, além dos presentes no outro conjunto.\nFonte: R for Data Science, 2017.\n\n\n\n\n\nd_left &lt;- left_join(x = d1_d2_d3_d4, y = d5, by = \"nome\")\nd_left\n#&gt; # A tibble: 8 × 5\n#&gt;   nome    sexo  idade  peso profissao  \n#&gt;   &lt;chr&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;      \n#&gt; 1 Amanda  F        25    63 &lt;NA&gt;       \n#&gt; 2 Maria   F        30    65 &lt;NA&gt;       \n#&gt; 3 Vitor   M        24    73 Agronomo   \n#&gt; 4 Leticia F        23    52 &lt;NA&gt;       \n#&gt; 5 Vitoria F        21    51 &lt;NA&gt;       \n#&gt; 6 Marcos  M        18    68 Professor  \n#&gt; 7 Julio   M        25    72 Zootecnista\n#&gt; 8 Fabio   M        35    81 Medico\n\nd_right &lt;- right_join(x = d1_d2_d3_d4, y = d5, by = \"nome\")\nd_right\n#&gt; # A tibble: 8 × 5\n#&gt;   nome      sexo  idade  peso profissao  \n#&gt;   &lt;chr&gt;     &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;      \n#&gt; 1 Vitor     M        24    73 Agronomo   \n#&gt; 2 Marcos    M        18    68 Professor  \n#&gt; 3 Julio     M        25    72 Zootecnista\n#&gt; 4 Fabio     M        35    81 Medico     \n#&gt; 5 Gabriel   &lt;NA&gt;     NA    NA Estudante  \n#&gt; 6 Guilherme &lt;NA&gt;     NA    NA Cozinheiro \n#&gt; 7 Jose      &lt;NA&gt;     NA    NA Biologo    \n#&gt; 8 Getulio   &lt;NA&gt;     NA    NA Musico\n\n\n8.3.4 semi_join() e anti_join()\n\nO semi_join() retorna apenas as observações do primeiro conjunto (x =) que também estão presentes no segundo conjunto (y =).\n\n\n\n\n\n\n\nFigura 8.5: Esquematização da função semi_join(), que retorna todas as observações do primeiro conjunto que também estão presentes no segundo conjunto.\nFonte: R for Data Science, 2017.\n\n\n\n\n\n# Tendo como primeiro conjunto o `d1_d2_d3_d4`\nd_semi1 &lt;- semi_join(x = d1_d2_d3_d4, y = d5, by = \"nome\")\nd_semi1\n#&gt; # A tibble: 4 × 4\n#&gt;   nome   sexo  idade  peso\n#&gt;   &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 Vitor  M        24    73\n#&gt; 2 Marcos M        18    68\n#&gt; 3 Julio  M        25    72\n#&gt; 4 Fabio  M        35    81\n\n# Tendo como primeiro conjunto o `d5`\nd_semi2 &lt;- semi_join(x = d5, y = d1_d2_d3_d4, by = \"nome\")\nd_semi2\n#&gt; # A tibble: 4 × 2\n#&gt;   nome   profissao  \n#&gt;   &lt;chr&gt;  &lt;chr&gt;      \n#&gt; 1 Fabio  Medico     \n#&gt; 2 Julio  Zootecnista\n#&gt; 3 Marcos Professor  \n#&gt; 4 Vitor  Agronomo\n\nJá o anti_join() retorna apenas as observações do primeiro conjunto (x =) que não estão presentes no segundo conjunto (y =).\n\n\n\n\n\n\n\nFigura 8.6: Esquematização da função anti_join(), que retorna as observações do primeiro conjunto que não estão presentes no segundo conjunto.\nFonte: R for Data Science, 2017.\n\n\n\n\n\n# Tendo como primeiro conjunto o `d1_d2_d3_d4`\nd_anti1 &lt;- anti_join(x = d1_d2_d3_d4, y = d5, by = \"nome\")\nd_anti1\n#&gt; # A tibble: 4 × 4\n#&gt;   nome    sexo  idade  peso\n#&gt;   &lt;chr&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 Amanda  F        25    63\n#&gt; 2 Maria   F        30    65\n#&gt; 3 Leticia F        23    52\n#&gt; 4 Vitoria F        21    51\n\n# Tendo como primeiro conjunto o `d5`\nd_anti2 &lt;- anti_join(x = d5, y = d1_d2_d3_d4, by = \"nome\")\nd_anti2\n#&gt; # A tibble: 4 × 2\n#&gt;   nome      profissao \n#&gt;   &lt;chr&gt;     &lt;chr&gt;     \n#&gt; 1 Gabriel   Estudante \n#&gt; 2 Guilherme Cozinheiro\n#&gt; 3 Jose      Biologo   \n#&gt; 4 Getulio   Musico\n\nAs funções semi_join() e anti_join(), diferentemente dos demais _joins() apresentados, não adicionam colunas de y = ao x = (ou vice-versa), mas filtram as colunas de x = com base em y =.\nDessa forma, semi_join() e anti_join() são conhecidas por filtering joins, pois filtram observações de um conjunto de dados com base na correspondência (ou não) às observações do outro conjunto, atuando de modo semelhante à função filter() (vide Seção 7.4.1). Por outro lado, inner_join(), full_join(), left_join() e right_join() são mutating joins, ou seja, adicionam novas variáveis a um conjunto de dados a partir de observações correspondentes em outro, atuam de maneira semelhante à função mutate() (vide Seção 7.3.4)",
    "crumbs": [
      "Manipulações",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Dados relacionais</span>"
    ]
  },
  {
    "objectID": "joins.html#resumo",
    "href": "joins.html#resumo",
    "title": "8  Dados relacionais",
    "section": "\n8.4 Resumo",
    "text": "8.4 Resumo\nA Tabela 8.1 traz um resumo das funções apresetadas neste capítulo.\n\n\nTabela 8.1: Resumo das funções das famílias bind_() e _join().\n\n\n\n\n\n\n\nFunção\nUso\n\n\n\nbind_row()\nCombina linhas de dois ou mais conjuntos\n\n\nbind_col()\nCombina colunas de dois ou mais conjuntos\n\n\ninner_join()\nCombina linhas em comum entre conjuntos\n\n\nfull_join()\nCombina todas as linhas entre conjuntos\n\n\nleft_join()\nMantém todas as linhas do primeiro conjunto e retorna os correspondentes do segundo conjunto\n\n\nright_join()\nMantém todas as linhas do segundo conjunto e retorna os correspondentes do primeiro conjunto\n\n\nsemi_join()\nFiltra as linhas do primeiro conjunto correspondentes ao segundo conjunto\n\n\nanti_join()\nFiltra as linhas do primeiro conjunto que não são correspondentes ao segundo conjunto\n\n\n\n\n\n\nAs funções das famílias bind_() e _join() são essenciais para manipulação e integração de dados no R. Saber como utilizá-las nos auxilia no processo de análise, tornando-o mais eficiente e organizado.\nNos próximos capítulos, exploraremos técnicas mais específicas para a transformação de dados. Caso o leitor esteja iniciando seus estudos em R, recomendo que avance diretamente para o Capítulo 9, onde abordaremos a visualização de dados por meio de gráficos. À medida que ganhar mais familiaridade com a linguagem, você poderá retornar a esses capítulos para aprofundar seus conhecimentos com maior facilidade.",
    "crumbs": [
      "Manipulações",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Dados relacionais</span>"
    ]
  },
  {
    "objectID": "visualizar.html",
    "href": "visualizar.html",
    "title": "9  Gráficos",
    "section": "",
    "text": "9.1 Introdução\nNeste capítulo, trataremos sobre a visualização de dados. Esta é uma etapa importante tanto para enxergar informações relevantes em nossos dados, como para apresentar os resultados obtidos. Para isso, utilizaremos os recursos disponíveis no pacote ggplot2.\nFigura 9.1: A etapa de visualizar nos permite realizar a análise exploratória dos dados, além de gerar gráficos para a divulgação dos resultados de uma análise.\nO ggplot2 foi idealizado por Hadley Wickham, sendo documentado no trabalho intitulado A Layered Grammar of Graphics. Desde então, tornou-se um dos pacotes mais populares para a confecção de gráficos elegantes e versáteis, tendo como base a gramática de gráficos.\nO conceito de gramática de gráficos foi proposto, originalmente, no livro The Grammar of Graphics, por Leland Wilkinson em 2005. Sua lógica se assemelha à gramática linguística na qual, para formularmos uma frase inteligível, devemos seguir uma ordem coerente de palavras. De modo semelhante, para construirmos gráficos a partir do ggplot2, devemos ter em mente quais são os seus fundamentos gramaticais.\nBasicamente, a gramática de gráficos é composta por sete camadas, podendo, ou não, estar todas juntas em um só gráfico. A sua construção varia de acordo com o tipo de gráfico, além da necessidade e subjetividade do cientista de dados.\nFigura 9.2: Ilustração das sete camadas presentes na gramática de gráficos. Podemos utilizá-las em conjunto de acordo com o objetivo desejado.\nFonte: The Grammar of Graphics, 2005.\nA Figura 9.2 ilustra as camadas que compõem a lógica da gramática de gráficos, apresentando as seguintes características:\nPortanto, a essência do ggplot2 é construir um gráfico camada por camada. A seguir, veremos as aplicações desses conceitos, além de entender a lógica da gramática de gráficos. Portanto, vamos carregar o pacote ggplot2.\nlibrary(ggplot2)\nDada a ampla gama de recursos oferecidos pelo ggplot2, não será possível abranger todas as suas funções e opções neste material. No entanto, o que será apresentado permitirá ao leitor compreender a lógica por trás do pacote, proporcionando uma maior autonomia para a continuidade nos estudos.\nNos exemplos a seguir, utilizaremos alguns conjuntos de dados que podem ser acessados clicando aqui.",
    "crumbs": [
      "Visualização",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Gráficos</span>"
    ]
  },
  {
    "objectID": "visualizar.html#introdução",
    "href": "visualizar.html#introdução",
    "title": "9  Gráficos",
    "section": "",
    "text": "Dados (Data): indica o conjunto de dados utilizado para a confecção do gráfico. É importante ter noção sobre os tipos de variáveis que o compõe (quantitativas ou qualitativas), a fim de utilizá-las de maneira correta;\nEstéticas (Aesthetics): atributo em que definimos quais variáveis irão compor os eixos dos gráficos, além da distinção das observações por cor, formato e tamanho a partir de uma outra variável;\nGeometrias (Geometries): representação geométrica do gráfico, seja em pontos, linhas, barras, caixas, dentre outras;\nPainel (Facets): é a forma de exibição dos gráficos de acordo com uma variável categórica. Podemos dividir em múltiplas grades ou, simplesmente, de forma individualizada;\nEstatísticas (Statistics): são os elementos estatísticos de um conjunto de dados que compõem o gráfico, como por exemplo uma média ou uma linha de tendência;\nCoordenadas (Coordinates): onde definimos as dimensões e a ordenação das coordenadas do gráfico;\nTema (Theme): aqui definimos a estética do gráfico, como as cores, tamanhos, fonte do texto, formatações e legendas.",
    "crumbs": [
      "Visualização",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Gráficos</span>"
    ]
  },
  {
    "objectID": "visualizar.html#gráfico-de-dispersão",
    "href": "visualizar.html#gráfico-de-dispersão",
    "title": "9  Gráficos",
    "section": "\n9.2 Gráfico de Dispersão",
    "text": "9.2 Gráfico de Dispersão\nComeçaremos a explorar os recursos do ggplot2 com o gráfico de dispersão, ou gráfico de ponto. Esse tipo de gráfico é muito útil para verificar a tendência entre duas variáveis numéricas que podem assumir uma ampla gama de valores (variáveis quantitativas contínuas).\nPara tanto, utilizaremos os dados do arquivo alunos.csv.\n\ndados_alunos &lt;- readr::read_csv(\"dados/alunos.csv\")\n\ndados_alunos\n#&gt; # A tibble: 64 × 7\n#&gt;    sexo  idade altura  peso horas_estudo media_ponderada futuro   \n#&gt;    &lt;chr&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;        &lt;dbl&gt;           &lt;dbl&gt; &lt;chr&gt;    \n#&gt;  1 M        23   1.75    80            2             7.5 academico\n#&gt;  2 F        19   1.67    65            2             8.3 mercado  \n#&gt;  3 M        19   1.7     90            3             6.9 mercado  \n#&gt;  4 M        22   1.73    87            3             7.1 academico\n#&gt;  5 M        19   1.83    71            2             6.5 mercado  \n#&gt;  6 M        19   1.8     80            3             8.6 mercado  \n#&gt;  7 M        20   1.9     90            2             7.8 academico\n#&gt;  8 F        20   1.6     55            1             8   mercado  \n#&gt;  9 F        24   1.62    55            2             8.2 academico\n#&gt; 10 F        18   1.64    60            2             7.3 mercado  \n#&gt; # ℹ 54 more rows\n\nO conjunto de dados possui sete variáveis sobre alunos: sexo, idade, altura (em metros), peso (em kg), horas de estudo (por dia), média ponderada no curso e perspectiva futura após a graduação. Cada linha representa uma observação referente a um aluno, tendo no total, 64 observações (ou alunos). Com isso, podemos constatar que os dados estão no formato tidy data (vide Capítulo 5).\nNeste primeiro momento, utilizaremos as variáveis altura e peso para construir o gráfico de dispersão.\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso)\n) +\n  geom_point()\n\n\n\n\n\n\n\nPara construir qualquer gráfico com o pacote ggplot2, começamos com a função ggplot(). Em seguida, a função apresenta as seguintes camadas:\n\ndata =: recebe um objeto que contém o conjunto de dados a ser utilizado para construir o gráfico. No caso, utilizamos o dados_alunos;\nmapping = aes(): define os atributos, bem como as variáveis que irão compor o gráfico. Com a função aes(), atribuímos as variáveis altura e peso aos eixos x e y, respectivamente;\ngeom_point(): determina o tipo de geometria adotado no gráfico. No caso, utilizamos a geometria de pontos, que resulta em um gráfico de dispersão.\n\nDentro da função ggplot(), declaramos as camadas referente aos dados e a estética. Em seguida, com a geom_point(), definimos a geometria do gráfico. Note que ambas as funções são unidas pelo sinal de +.\nPortanto, um gráfico do ggplot2 sempre terá a função ggplot() combinada com uma função de sintaxe geom_(), ligas pelo sinal +.\nOutra forma de escrever o código anterior, é não declarando explicitamente os argumentos data = e mapping =, porém mantendo a ordem original dos atributos: primeiro os dados, depois a aes().\n\nggplot(dados_alunos, aes(x = altura, y = peso)) +\n  geom_point()\n\n\n\n\n\n\n\nIsso permite deixar o código mais enxuto, sendo importante, principalmente, quando utilizamos muitas linhas de código para fazer um único gráfico.\nNos primeiros exemplos deste material, utilizaremos os argumentos de forma explícita, para que você enxergue com mais clareza a estrutura e as funcionalidades do código. Posteriormente, utilizaremos implicitamente estes argumentos.\n\n9.2.1 Gramática de gráficos\nPara se ter uma noção de como foi gerado o gráfico anterior e entender melhor a lógica da gramática de gráficos, construiremos o código anterior por partes.\n\nggplot(data = dados_alunos)\n\n\n\n\n\n\n\nAo definir somente o argumento data = dados_alunos na função ggplot(), nos é retornado um gráfico vazio, pois apenas indicamos qual o conjunto de dados que utilizaremos, sem fornecer informações referentes à estrutura do gráfico.\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso)\n)\n\n\n\n\n\n\n\nAgora, indicando as variáveis mapeadas nos eixos x e y, temos um gráfico com as coordenadas definidas, porém, sem ter os dados projetados, pois ainda não definimos qual o tipo de geometria será adotado.\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso)\n) +\n  geom_point()\n\n\n\n\n\n\n\nAssim, ao definir a geometria de pontos geom_point(), os dados são inseridos no gráfico.\nDessa forma, para os que estão começando a utilizar e entender o ggplot2, recomendo executar os comandos camada por camada, pois auxiliará na compreensão da montagem dos gráficos.\n\n9.2.2 Cores\nPodemos incluir outros elementos ao gráfico anterior, como por exemplo, distinguir os pontos por cor, de acordo com uma variável do conjunto de dados.\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, color = sexo)\n) +\n  geom_point()\n\n\n\n\n\n\n\nPara isso, utilizamos o argumento color = dentro da aes(). No exemplo, diferenciamos por cor o sexo dos alunos.\nPara atribuir uma única cor a todos os pontos, independente de uma variável, utilizamos o mesmo argumento dentro da geom_point().\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso)\n) +\n  geom_point(color = \"blue\")\n\n\n\n\n\n\n\nVocê deve ter percebido que um mesmo argumento pode ser utilizado de diferentes maneiras. Nos exemplos anteriores, utilizamos o argumento color = dentro da função aes(), mas também na geom_point() sem a aes().\nUtilizamos a aes() quando o argumento recebe uma variável do conjunto de dados, como foi o caso da color = sexo. Por outro lado, quando o argumento recebe um atributo contido em uma determinada escala, colocamos na função geom_() sem a aes().\nPor exemplo, caso definirmos um atributo ao argumento color = dentro da função aes(), temos o seguinte resultado.\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, color = \"blue\")\n) +\n  geom_point()\n\n\n\n\n\n\n\nO comando aes(color = \"blue\") (cor = “azul”) nos retornou pontos de coloração vermelha, e não azul. Isto aconteceu pois a função aes() espera receber uma variável do conjunto de dados. Dessa forma, o valor \"blue\" é tratado como uma nova variável pertencente a todas as observações. Assim, os pontos são todos coloridos de vermelho (padrão do ggplot2) associada à nova categoria blue.\nPortanto, sempre devemos nos atentar a esses detalhes para construirmos os gráficos de acordo com os nossos objetivos e as particularidades dos argumentos e funções.\nTrataremos com mais detalhes sobre as cores na Seção 9.5.1.\n\n9.2.3 Formatos\nPodemos atribuir um novo formato aos pontos utilizando o argumento shape =.\nPara alterar a forma de todos os pontos, independente de qualquer variável, colocamos o argumento dentro da função geom_point().\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, color = sexo)\n) +\n  geom_point(shape = 0)\n\n\n\n\n\n\n\nCada tipo de formato é representado por um número, cujas legendas estão representadas na Figura 9.3.\n\n\n\n\n\n\n\nFigura 9.3: Legendas dos tipos de formatos de pontos, indicados no argumento shape =.\n\n\n\n\nDa mesma forma que distinguimos os pontos por cor baseado em uma variável, podemos diferenciá-los pelo formato. Agora, utilizaremos o argumento shape = dentro da aes(), pois se trata de uma variável do nosso conjunto de dados.\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, shape = sexo)\n) +\n  geom_point()\n\n\n\n\n\n\n\nPara alterar o formato dos pontos, utilizamos a função scale_shape_manual() junto ao argumento values =, que recebe um vetor com os números dos formatos que se deseja atribuir.\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, shape = sexo)\n) +\n  geom_point() +\n  scale_shape_manual(values = c(13, 24))\n\n\n\n\n\n\n\nPerceba que inserimos a função logo abaixo da geom_point(), ligada pelo sinal de +, pois se trata de uma nova camada que altera o tema do gráfico.\nAlém disso, a sequência dos números no vetor segue a ordem das variáveis, ou seja, o formato 13 é referente ao sexo feminino (F) e o formato 24, ao sexo masculino (M).\n\n9.2.4 Tamanho\nPara alterar o tamanho dos pontos, utilizamos o argumento size =.\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, color = sexo)\n) +\n  geom_point(size = 5)\n\n\n\n\n\n\n\nCaso o argumento size = não seja especificado, por padrão, o valor adotado é igual a 1. Assim, podemos gerar ponto maiores designando valores superiores a 1, ou senão, pontos menores, atribuindo valores inferiores a 1.\nOutra possibilidade é diferenciar as idades dos alunos pelo tamanho dos pontos. Para isso, o argumento size = receberá a variável idade, dentro a função aes().\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, color = sexo, size = idade)\n) +\n  geom_point()\n\n\n\n\n\n\n\nPara alterar a escala de tamanho dos pontos, podemos utilizar a função scale_size(), onde colocamos no argumento range = um vetor com a amplitude de tamanhos, do menor para o maior.\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, color = sexo, size = idade)\n) +\n  geom_point() +\n  scale_size(range = c(1,10))\n\n\n\n\n\n\n\n\n9.2.5 Transparência\nPara modificar a transparência dos pontos, utilizamos o argumento alpha =.\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, color = sexo)\n) +\n  geom_point(size = 4, alpha = 0.5)\n\n\n\n\n\n\n\nEste argumento segue uma escala de 0 a 1, sendo 0 o valor com máxima transparência (ou seja, os pontos desaparecem do gráfico).\nCom o argumento shape =, também podemos diferenciar as observações pela transparência dos pontos, baseada em uma variável. Utilizaremos a variável idade para diferenciá-las.\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, color = sexo, alpha = idade)\n) +\n  geom_point(size = 4)\n\n\n\n\n\n\n\nUma opção para alterar a escala de transparência é a função scale_alpha(). Junto ao argumento range =, colocamos uma amplitude de valores, de 0 a 1, do menor para o maior.\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, color = sexo, alpha = idade)\n) +\n  geom_point(size = 4) + \n  scale_alpha(range = c(0.4, 1))\n\n\n\n\n\n\n\n\n9.2.6 Painel (Facets)\nOs paineis (facets) replicam os gráficos, separando-os em grades de acordo com uma variável categórica do conjunto de dados. Para ficar mais claro, vamos exemplificá-los com a função facet_wrap().\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, color = sexo)\n) +\n  geom_point() +\n  facet_wrap(~sexo)\n\n\n\n\n\n\n\nNa função, utilizamos o operador ~ para dizer que a variável sexo será utilizada como um fator para quebrar o gráfico em duas grades (~sexo). Dessa maneira, cada grade recebe somente os dados referentes aos respectivos sexos.\nPodemos alterar a disposição das grades no gráfico. Para isso, utilizamos o argumento nrow = ou ncol =, dentro da função facet_wrap(), para indicar a quantidade de linhas ou colunas a serem adotadas, respectivamente.\n# Gráfico à esquerda\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, color = sexo)\n) +\n  geom_point() +\n  facet_wrap(~sexo, nrow = 2)\n\n# Gráfico à direita\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, color = sexo)\n) +\n  geom_point() +\n  facet_wrap(~sexo, ncol = 2)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo gráfico à esquerda, definimos a disposição das grades em duas linhas (nrow = 2). Enquanto isso, no gráfico à direita, definimos a apresentação em duas colunas (ncol = 2).\nAinda, podemos associar duas variáveis categóricas ao painel. Como exemplo, adicionaremos a variável futuro à fórmula (futuro~sexo).\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, color = sexo)\n) +\n  geom_point() +\n  facet_wrap(futuro~sexo, ncol = 2)\n\n\n\n\n\n\n\nOutra maneira de utilizar os paineis é com a função facet_grid(). Ela apresenta o mesmo raciocínio da facet_wrap().\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, color = sexo)\n) +\n  geom_point() +\n  facet_grid(sexo~futuro)\n\n\n\n\n\n\n\nCom a função facet_grid(), delimitamos uma variável às colunas e outra variável às linhas, sendo uma opção mais adequada quando utilizamos mais de uma variável categórica para separar os dados em grades.\nPor padrão, os paineis compartilham a mesma escala de coordenadas. Para ajustar as escalas conforme os dados presentes em cada grade, utilizamos o argumento scales =. Para tornar todas as escalas ajustadas aos dados, tanto no eixo x, como no eixo y, utilizamos o parâmetro \"free\". Para ajustar somente um dos eixos, utilizamos o \"free_x\" ou o \"free_y\".\n# Gráfico à esquerda\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, color = sexo)\n) +\n  geom_point() +\n  facet_grid(sexo~futuro, scales = \"free_y\")\n\n# Gráfico à direita\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, color = sexo)\n) +\n  geom_point() +\n  facet_grid(sexo~futuro, scales = \"free_x\")\n\n# Gráfico abaixo\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, color = sexo)\n) +\n  geom_point() +\n  facet_grid(sexo~futuro, scales = \"free\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.2.7 Linhas de referência\nPodemos adicionar linhas de referência aos nossos gráficos.\nPara criar linhas horizontais, utilizamos a função geom_hline(). Como argumento, devemos usar a yintercept =, que indica em qual ponto do eixo y será traçada a linha.\nComo exemplo, será construído um gráfico de dispersão entre as horas de estudo e a média ponderada dos estudantes. A linha de referência horizontal será a média (mean()) da média ponderada dos alunos.\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = horas_estudo, y = media_ponderada)\n) +\n  geom_point() +\n  geom_hline(\n    mapping = aes(yintercept = mean(media_ponderada)),\n    color = \"red\"\n  )\n\n\n\n\n\n\n\nPerceba que o argumento yintercept = foi colocado dentro da aes(), referente à função geom_hline(), pois utilizamos uma variável do nosso conjunto de dados para construir a linha.\nJá as linhas verticais de referência são análogas às linhas horizontais. Para isso, utilizamos a função geom_vline(), que recebe o argumento xintercept = para indicar em qual ponto do eixo x será traçada a linha.\nAgora, a linha de referência vertical será a média das horas de estudo.\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = horas_estudo, y = media_ponderada)\n) +\n  geom_point() +\n  geom_vline(\n    mapping = aes(xintercept = mean(horas_estudo)),\n    color = \"red\"\n  )\n\n\n\n\n\n\n\nNa Seção 9.5 abordaremos com mais detalhes sobre os gráficos de linhas.\n\n9.2.8 Linhas de regressão\nPodemos incluir linhas de regressão ajustadas aos dados com a função geom_smooth().\nUtilizaremos as variáveis altura e peso do nosso conjunto de dados para exemplificá-la.\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso)\n) +\n  geom_point() +\n  geom_smooth()\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\nPor padrão, a geom_smooth() aplica o modelo loess (sigla de locally estimated scatterplot smoothing) aos dados. Para alterar o método, utilizamos o argumento method = na função geom_smooth(). No exemplo a seguir, definiremos o método \"lm\" (linear model), ou seja, um modelo linear.\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso)\n) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n#&gt; `geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nPerceba que a linha de tendência apresenta uma região sombreada em seu entorno. Essa região é o intervalo de confiança que, por padrão, adota 95% de confiança (0,95). Para alterar o nível do intervalo de confiança, utilizamos o argumento level =. A seguir, assumiremos 70% de nível de confiança (0.70).\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso)\n) +\n  geom_point() +\n  geom_smooth(method = \"lm\", level = 0.70)\n\n\n\n\n\n\n\nPara ocultar o intervalo de confiança do gráfico, utilizamos o argumento se = FALSE.\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso)\n) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE)\n\n\n\n\n\n\n\nTambém podemos fazer linhas de regressão para diferentes grupos, como por exemplo, construir uma linha de acordo com o sexo. Para isso, definimos a variável sexo no argumento color = dentro da função aes()\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, color = sexo)\n) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE)\n\n\n\n\n\n\n\nPara distinguir o sexo dos alunos por cor, porém fazer uma única linha de tendência para todas as observações, temos que definir tal atributo na camada desejada, ou seja, dentro de uma das geom_().\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso)\n) +\n  geom_point(mapping = aes(color = sexo)) +\n  geom_smooth(method = \"lm\", se = FALSE)\n\n\n\n\n\n\n\nNeste caso, deslocamos a color = sexo da função ggplot() para a geom_point(), pois queremos distinguir somente os pontos por cor e não a linha de tendência.\nDessa forma, quando utilizamos dois tipos de geometria, os atributos contidos na ggplot() serão em comum à ambas as funções de geometria. No exemplo, tanto a geom_point(), como a geom_smooth() adotam o argumento aes(x = altura, y = peso) para mapear os eixos.\nPor outro lado, ao deslocar a color = sexo, exclusivamente, para dentro da geom_point(), definimos este atributo somente para esta geometria.\nPara conhecer outros argumentos disponíveis na função geom_smooth(), acesse o link https://ggplot2.tidyverse.org/reference/geom_smooth.html. E para maiores detalhes sobre o assunto aplicado ao ggplot2, confira o capítulo 5, seções 5.6 a 5.9, do livro R Graphics Cookbook.\n\n9.2.9 Títulos e rótulos\nPara colocarmos títulos e rótulos nos gráficos, utilizaremos como exemplo as variáveis altura e peso do nosso conjunto de dados, diferenciando o sexo por cor e a idade pela transparência.\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, color = sexo, alpha = idade)\n) +\n  geom_point(size = 4)\n\n\n\n\n\n\n\nPara inserir os títulos e rótulos, utilizamos a função labs(). Como argumentos, indicamos quais atributos desejamos (re)nomear. Atente-se ao fato de que as nomeações devem estar entre aspas.\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, color = sexo, alpha = idade)\n) +\n  geom_point(size = 4) +\n  labs(\n    x = \"Altura (m)\",\n    y = \"Peso (kg)\",\n    color = \"Gênero\",\n    alpha = \"Idade (anos)\",\n    title = \"Gráfico de dispersão\",\n    subtitle = \"Altura x Peso\",\n    caption = \"Fonte: Disciplina Estatística Aplicada - ESALQ.\"\n  )\n\n\n\n\n\n\n\nPodemos adicionar mais alguns ajustes, como centralizar o título e subtítulo, ajustar a fonte à esquerda e colocar as legendas abaixo do gráfico.\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, color = sexo, alpha = idade)\n) +\n  geom_point(size = 4) +\n  labs(\n    x = \"Altura (m)\",\n    y = \"Peso (kg)\",\n    color = \"Gênero\",\n    alpha = \"Idade (anos)\",\n    title = \"Gráfico de dispersão\",\n    subtitle = \"Altura x Peso\",\n    caption = \"Fonte: Disciplina Estatística Aplicada (2022).\"\n  ) +\n  theme(\n    plot.title = element_text(hjust = 0.5),\n    plot.subtitle = element_text(hjust = 0.5),\n    plot.caption = element_text(hjust = 0),\n    legend.position = \"bottom\"\n  )\n\n\n\n\n\n\n\nPara isso, conjuntamente à função theme(), utilizamos a element_text() para ajustar o posicionamento horizontal do título (plot.title =) e do subtítulo (plot.subtitle =), além da fonte (plot.caption =). O argumento hjust = apresenta uma escala de 0 a 1, sendo 0 o posicionamento mais à esquerda do gráfico. Assim, para centralizarmos os textos, definimos o ajuste na metade da escala (hjust = 0.5).\nAinda dentro da função theme(), utilizamos o argumento legend.position = \"bottom\" para colocar as legendas abaixo do gráfico. Para colocá-las acima, utilizamos o parâmetro \"top\" e para colocar à esquerda, o parâmetro \"left\". Para ocultar todas as legendas, utilizamos o \"none\".\nCaso queira ocultar somente uma das legendas, utilizamos a função guides(), informando a variável cuja legenda se deseja ocultar.\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, color = sexo, alpha = idade)\n) +\n  geom_point(size = 4) +\n  labs(\n    x = \"Altura (m)\",\n    y = \"Peso (kg)\",\n    color = \"Gênero\",\n    alpha = \"Idade (anos)\",\n    title = \"Gráfico de dispersão\",\n    subtitle = \"Altura x Peso\",\n    caption = \"Fonte: Disciplina Estatística Aplicada - ESALQ.\"\n  ) +\n  theme(\n    plot.title = element_text(hjust = 0.5),\n    plot.subtitle = element_text(hjust = 0.5),\n    plot.caption = element_text(hjust = 0),\n    legend.position = \"bottom\"\n  ) +\n  guides(alpha = \"none\")\n\n\n\n\n\n\n\nNesse exemplo, ocultamos apenas a legenda do argumento alpha =, atribuindo o valor \"none\".\n\n9.2.10 Temas\nExiste a possibilidade de escolhermos outros temas para confeccionar nossos gráficos. Podemos criar temas a partir do zero ou senão utilizar temas pré-definidos com função de sintaxe theme_(). A seguir, demonstraremos alguns dos temas pré-configurados.\n# Gráfico à esquerda superior\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, color = sexo, alpha = idade)\n) +\n  geom_point(size = 4) +\n  theme_bw()\n\n# Gráfico à direita superior\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, color = sexo, alpha = idade)\n) +\n  geom_point(size = 4) +\n  theme_classic()\n\n# Gráfico à esquerda inferior\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, color = sexo, alpha = idade)\n) +\n  geom_point(size = 4) +\n  theme_dark()\n\n# Gráfico à diretira inferior\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, color = sexo, alpha = idade)\n) +\n  geom_point(size = 4) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nO pacote ggthemes é uma opção para ter acesso a outros temas pré-definidos, além de recursos adicionais para os gráficos do ggplot2. Para conhecer o pacote, faça sua instalação e acesse sua documentação.\nPara saber mais sobre títulos, rótulos e aparência geral dos gráficos, confira os capítulos 9 e 10 do livro R Graphics Cookbook.\n\n9.2.11 Salvar gráficos\nAo elaborar um gráfico no R, podemos exportá-lo, salvando em formato de imagem ou pdf. Para isso, utilizamos a função ggsave(). A função salvará o último gráfico gerado.\n\nggplot(\n  data = dados_alunos,\n  mapping = aes(x = altura, y = peso, color = sexo, alpha = idade)\n) +\n  geom_point(size = 4) +\n  theme_classic()\n\nggsave(filename = \"imagens/grafico-alunos.png\")",
    "crumbs": [
      "Visualização",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Gráficos</span>"
    ]
  },
  {
    "objectID": "visualizar.html#gráfico-de-barras",
    "href": "visualizar.html#gráfico-de-barras",
    "title": "9  Gráficos",
    "section": "\n9.3 Gráfico de Barras",
    "text": "9.3 Gráfico de Barras\nPara construir gráficos de barras, utilizamos a função geom_col(). Ao eixo x, definimos uma variável categórica, enquanto ao eixo y, uma variável quantitativa.\nPara a elaboração dos exemplos, utilizaremos dados do arquivo milho_trigo.csv. O conjunto de dados apresenta valores da produtividade média anual, em toneladas por hectare, das culturas do milho e trigo, respectivos ao Brasil, China, Índia e Estado Unidos entre os anos de 1961 e 2019.\n\nproducao &lt;- readr::read_csv(\"dados/milho-trigo.csv\")\n\nproducao\n#&gt; # A tibble: 4 × 3\n#&gt;   pais   milho trigo\n#&gt;   &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 Brasil  2.6   1.52\n#&gt; 2 China   3.94  3.07\n#&gt; 3 India   1.62  2.08\n#&gt; 4 EUA     7.38  2.48\n\nA utilização da geom_col() é muito semelhante à geom_point(). Dentro da função ggplot(), definimos o conjunto de dados a ser utilizado, as variáveis que ocuparão as coordenadas x e y, além da geometria do gráfico.\n# Gráfico à esquerda\nggplot(producao, aes(x = pais, y = trigo)) +\n  geom_col() + \n  labs(title = \"Trigo\")\n\n# Gráfico à direita\nggplot(producao, aes(x = pais, y = milho)) +\n  geom_col() + \n  labs(title = \"Milho\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.3.1 Cores\nPodemos colorir os gráficos de barras de duas formas. A primeira é com o argumento color =, que colore as bordas das colunas. A outra é com o argumento fill =, que preenche o interior da barra com cores.\n# Gráfico à esquerda\nggplot(producao, aes(x = pais, y = trigo)) +\n  geom_col(color = \"red\") + \n  labs(title = \"Trigo\")\n\n# Gráfico à direita\nggplot(data = producao, mapping = aes(x = pais, y = milho)) +\n  geom_col(fill = \"red\") + \n  labs(title = \"Milho\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPara colorir as bordas e o interior da barra, utilizamos ambos os argumentos em conjunto.\n# Gráfico à esquerda\nggplot(producao, aes(x = pais, y = trigo)) +\n  geom_col(color = \"black\", fill = \"red\") + \n  labs(title = \"Trigo\")\n\n# Gráfico à direita\nggplot(producao, aes(x = pais, y = milho)) +\n  geom_col(color = \"red\", fill = \"black\") + \n  labs(title = \"Milho\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTrataremos com mais detalhes sobre as cores na Seção 9.5.1.\n\n9.3.2 Larguras e espessuras\nPara alterar a largura das barras, utilizamos o argumento width =, que adota uma escala de 0 a 1, onde 1 representa a largura máxima sem espaçamento entre as barras. Já para modificar a espessura das bordas, recorremos ao argumento linewidth =.\n# Gráfico à esquerda\nggplot(producao, aes(x = pais, y = trigo)) +\n  geom_col(fill = \"blue\", width = 0.3) + \n  labs(title = \"Trigo\")\n\n# Gráfico à direita\nggplot(producao, aes(x = pais, y = milho)) +\n  geom_col(color = \"red\", linewidth = 2) + \n  labs(title = \"Milho\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.3.3 Ordenamento\nNos gráficos de barras em que as variáveis categóricas não seguem uma ordem específica (variáveis qualitativas nominais), podemos reorganizá-las com base em seus valores. Como exemplo, ordenaremos os países de acordo com a produção de milho e trigo.\n# Gráfico à esquerda\nproducao |&gt; \n  dplyr::mutate(pais = forcats::fct_reorder(pais, trigo)) |&gt; \n  ggplot(aes(x = pais, y = trigo)) +\n  geom_col() + \n  labs(title = \"Trigo\")\n\n# Gráfico à direita\nproducao |&gt; \n  dplyr::mutate(pais = forcats::fct_reorder(pais, -milho)) |&gt; \n  ggplot(aes(x = pais, y = milho)) +\n  geom_col() + \n  labs(title = \"Milho\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPara tanto, foi utilizada a função forcats::fct_reorder() (vide ?sec-forcats). Nela, declaramos como primeiro argumento a variável a ser reordenada, no caso, os países. Em seguida, definimos o critério de ordenação, utilizando a produção média de trigo para o gráfico à esquerda e de milho para o da direita. Por padrão, a função ordena os dados em ordem crescente. Para ordenar decrescentemente, incluímos um sinal de - antes do critério.\nNos exemplos anteriores, vimos como integrar a função ggplot() em uma pipeline (Seção 7.2). É importante notar que, ao definir o objeto contendo o conjunto de dados no início, não foi necessário colocá-lo dentro da ggplot(). Isso destaca a flexibilidade da sintaxe tidyverse e como podemos criar visualizações de dados de maneira versátil e eficiente.\n\n9.3.4 Coordenadas\nO sistema de coordenadas padrão do ggplot2 é o cartesiano, onde os eixo x e y atuam de maneira independente para determinar a localização de cada ponto. De maneira simples, podemos inverter os eixos x e y utilizando a função coord_flip(), assim, dispomos as barras no sentido horizontal.\n# Gráfico à esquerda\nggplot(producao, aes(x = pais, y = trigo)) +\n  geom_col() + \n  labs(title = \"Trigo\") +\n  coord_flip()\n\n# Gráfico à direita\nggplot(producao, aes(x = pais, y = milho)) +\n  geom_col() + \n  labs(title = \"Milho\") +\n  coord_flip()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.3.5 Legendas\nPodemos adicionar legendas às nossas colunas adicionando uma nova camada com a função geom_text(). No exemplo a seguir, adicionaremos os valores de produção como legenda junto às colunas.\n# Gráfico à esquerda\nggplot(producao, aes(x = pais, y = trigo)) +\n  geom_col() + \n  geom_text(aes(label = trigo), color = \"white\", vjust = 1.5) +\n  labs(title = \"Trigo\")\n\n# Gráfico à direita\nggplot(producao, aes(x = pais, y = milho)) +\n  geom_col() + \n  geom_text(aes(label = milho), color = \"white\", vjust = 1.5) +\n  labs(title = \"Milho\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUtilizando o argumento label =, atribuímos os valores médios de produção para as variáveis milho e trigo como legendas das colunas. Enquanto isso, o vjust = é empregado para ajustar a posição vertical das legendas, tomando como referência o topo de cada barra, de maneira independente em relação às demais.\nNesse caso, faça os ajustes testando valores. Também é possível atribuir valores negativos, fazendo com que a legenda fique acima da barra.\n\n9.3.6 Duas variáveis categóricas\nNos exemplos anteriores, ilustramos as produções de milho e trigo em gráficos separados. Contudo, temos a opção de juntá-las em um único. Para isso, utilizaremos duas variáveis categóricas para construir o gráfico, atribuindo os países ao eixo x e as culturas do milho e trigo às cores das barras.\n\nproducao\n#&gt; # A tibble: 4 × 3\n#&gt;   pais   milho trigo\n#&gt;   &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 Brasil  2.6   1.52\n#&gt; 2 China   3.94  3.07\n#&gt; 3 India   1.62  2.08\n#&gt; 4 EUA     7.38  2.48\n\nAo analisar a disposição dos dados, nota-se que devemos realizar algumas alterações para que seja possível atribuir as culturas às cores das barras. No caso, devemos colocá-las como observações de uma nova coluna, bem como seus valores.\nPara tanto, utilizaremos a função tidyr::pivot_longer() (vide Seção 5.4) para realizar essa operação.\n\nproducao_longer &lt;- producao |&gt; \n  tidyr::pivot_longer(\n    cols = c(milho, trigo), \n    names_to = \"cultura\",\n    values_to = \"producao_media\"\n  )\n\nproducao_longer\n#&gt; # A tibble: 8 × 3\n#&gt;   pais   cultura producao_media\n#&gt;   &lt;chr&gt;  &lt;chr&gt;            &lt;dbl&gt;\n#&gt; 1 Brasil milho             2.6 \n#&gt; 2 Brasil trigo             1.52\n#&gt; 3 China  milho             3.94\n#&gt; 4 China  trigo             3.07\n#&gt; 5 India  milho             1.62\n#&gt; 6 India  trigo             2.08\n#&gt; 7 EUA    milho             7.38\n#&gt; 8 EUA    trigo             2.48\n\nAgora, milho e trigo passaram a ser observações da variável cultura, e seus respectivos valores, da coluna producao_media.\n\nproducao_longer |&gt; \n  ggplot(aes(x = pais, y = producao_media, fill = cultura)) +\n  geom_col()\n\n\n\n\n\n\n\nDessa forma, mantemos a variável qualitativa pais no eixo x, mas agora, os valores de produção média no eixo y e a variável categórica cultura colorindo as barras de acordo com a cultura.\nEste é um caso em que precisamos abdicar do formato tidy data (Seção 5.3) para adequar os dados conforme nossos objetivos.\n\n9.3.6.1 Posição das barras\nCaso queira alterar a disposição das barras, podemos utilizar o argumento position = e especificar a posição desejada.\n# Gráfico à esquerda\nproducao_longer |&gt; \n  ggplot(aes(x = pais, y = producao_media, fill = cultura)) +\n  geom_col(position = \"stack\")\n\n# Gráfico ao centro\nproducao_longer |&gt; \n  ggplot(aes(x = pais, y = producao_media, fill = cultura)) +\n  geom_col(position = \"dodge\")\n\n# Gráfico à direita\nproducao_longer |&gt; \n  ggplot(aes(x = pais, y = producao_media, fill = cultura)) +\n  geom_col(position = \"fill\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComo opções de disposição das barras temos:\n\n\"stack\": ilustrada pelo gráfico à esquerda. É a opção padrão do argumento position =. Essa disposição de barras representa os valores absolutos de produção média das culturas em apenas uma barra por país;\n\"dodge\": ilustrada pelo gráfico ao centro. Posição que aprepresenta os valores absolutos das culturas de um mesmo país em colunas separadas;\n\"fill\": ilustrada pelo gráfico à direita. Constrói barras proporcionais, com escala de 0 a 1, preenchendo-as com os valores relativos das produções de milho e trigo, de acordo com o país.\n\n9.3.6.2 Legendas\nDa mesma maneira como fizemos na Seção 9.3.5, adicionamos legendas às colunas com a função geom_text().\n# Gráfico à esquerda\nproducao_longer |&gt; \n  ggplot(aes(x = pais, y = producao_media, fill = cultura)) +\n  geom_col(position = \"stack\") + \n  geom_text(\n    mapping = aes(label = producao_media),\n    color = \"white\",\n    position = position_stack(0.9),\n    vjust = 1.5\n  )\n\n# Gráfico ao centro\nproducao_longer |&gt; \n  ggplot(aes(x = pais, y = producao_media, fill = cultura)) +\n  geom_col(position = \"dodge\") +\n  geom_text(\n    mapping = aes(label = producao_media),\n    color = \"white\",\n    position = position_dodge(0.9),\n    vjust = 1.5\n  )\n\n# Gráfico à direita\nproducao_longer |&gt; \n  ggplot(aes(x = pais, y = producao_media, fill = cultura)) +\n  geom_col(position = \"fill\") +\n  geom_text(\n    mapping = aes(label = producao_media),\n    color = \"white\",\n    position = position_fill(0.9),\n    vjust = 1.5\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDependendo do tipo de disposição escolhido para a barra, utilizaremos uma função de sintaxe position_() no argumento position =. Essa função é utilizada para ajustar o posicionamento das legendas em cada setores da barra, levando em consideração o tipo de disposição, seja a stack (position_stack()), dodge (position_dodge()) ou fill (position_fill()).\nNo caso da position = \"fill\", que ilustra as frequências relativas, os valores das legendas são os absolutos. Para convertê-los em proporções, agruparemos os dados utilizando a group_by() com base nos países. Em seguida, com a função mutate(), criaremos a coluna producao_relativa que apresenta os valores relativos entre as culturas em cada país.\n\nproducao_prop &lt;- producao_longer |&gt; \n  dplyr::group_by(pais) |&gt;\n  dplyr::mutate(producao_relativa = (producao_media / sum(producao_media)))\n\nproducao_prop\n#&gt; # A tibble: 8 × 4\n#&gt; # Groups:   pais [4]\n#&gt;   pais   cultura producao_media producao_relativa\n#&gt;   &lt;chr&gt;  &lt;chr&gt;            &lt;dbl&gt;             &lt;dbl&gt;\n#&gt; 1 Brasil milho             2.6              0.631\n#&gt; 2 Brasil trigo             1.52             0.369\n#&gt; 3 China  milho             3.94             0.562\n#&gt; 4 China  trigo             3.07             0.438\n#&gt; 5 India  milho             1.62             0.438\n#&gt; 6 India  trigo             2.08             0.562\n#&gt; 7 EUA    milho             7.38             0.748\n#&gt; 8 EUA    trigo             2.48             0.252\n\nDessa forma, no lugar da variável producao_media, utilizaremos a producao_relativa, presente no objeto chamado producao_prop.\n\nggplot(\n  producao_prop, \n  aes(x = pais, y = producao_relativa, fill = cultura)\n) +\n  geom_col(position = \"fill\") +\n  geom_text(\n    mapping = aes(label = producao_relativa |&gt; round(2)),\n    color = \"white\",\n    position = position_fill(0.9),\n    vjust = 1.5\n  )\n\n\n\n\n\n\n\nNote que, para arredondar os valores de produção relativa em duas casas decimais, utilizamos a função round() junto à um pipe, dentro de uma função do gráfico. Portanto, os conceitos vistos no Seção 7.2 também são aplicáveis em funções do ggplot2.\n\n9.3.7 Contagens\nTambém podemos fazer gráficos de barras com a função geom_bar(). Ela constrói os gráficos a partir da contagem de valores presentes em uma variável categórica. Como exemplo, utilizaremos a base de dados diamonds, presente no prórprio pacote ggplot2.\n\ndiamonds\n#&gt; # A tibble: 53,940 × 10\n#&gt;    carat cut       color clarity depth table price     x     y     z\n#&gt;    &lt;dbl&gt; &lt;ord&gt;     &lt;ord&gt; &lt;ord&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt;  1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n#&gt;  2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n#&gt;  3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n#&gt;  4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n#&gt;  5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n#&gt;  6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n#&gt;  7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n#&gt;  8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n#&gt;  9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n#&gt; 10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n#&gt; # ℹ 53,930 more rows\n\nEsse conjunto de dados possui 53.940 observações e 10 variáveis sobre características de uma amostra de diamantes. Dessas variáveis, utilizaremos apenas a cut, que informa a qualidade de corte dos diamantes, sendo categorizadas em Fair, Good, Very Good, Premium e Ideal.\nA seguir, faremos um gráfico de barras que conta a quantidade de diamantes que se encaixam em cada uma dessas categorias.\n\nggplot(diamonds, aes(x = cut)) +\n  geom_bar()\n\n\n\n\n\n\n\nPerceba que foi preciso informar apenas a variável categórica cut ao eixo x, sendo o y construido, automaticamente, a partir da contagem dos diamantes que se encaixam nas respectivas categorias.\nPara alterar os valores do eixo y de contagens para proporção, utilizamos a função after_stat(prop) no argumento y = e o argumento group = 1 para manter todas as barras pertencentes ao mesmo grupo, garantindo que o cálculo da proporção seja feito corretamente.\n\nggplot(diamonds, aes(x = cut, y = after_stat(prop), group = 1)) +\n  geom_bar()",
    "crumbs": [
      "Visualização",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Gráficos</span>"
    ]
  },
  {
    "objectID": "visualizar.html#gráfico-de-setores-pizza",
    "href": "visualizar.html#gráfico-de-setores-pizza",
    "title": "9  Gráficos",
    "section": "\n9.4 Gráfico de Setores (Pizza)",
    "text": "9.4 Gráfico de Setores (Pizza)\nMais conhecido como gráfico de pizza, o gráfico de setores é muito popular e simples de ser compreendido. Apesar disso, sua utilização deve ser cautelosa, a fim de não sobrecarregar em informação ou utilizá-lo de maneira inadequada. Normalmente, um gráfico de pizza visa representar a frequência relativa de valores, de acordo com uma variável categórica.\nPara construí-lo, utilizamos o artifício da função coord_polar(), que altera a coordenada do gráfico de barras. A seguir, veremos um exemplo com dados hipotéticos sobre o nível de escolaridade de indivíduos.\n\nnivel_escolar &lt;- tibble::tibble(\n  escolaridade = c(\"Fundamental\", \"Médio\", \"Superior\"),\n  quantidade = c(150, 200, 60),\n  porcentagem = (quantidade / sum(quantidade) * 100) |&gt; round(2)\n)\n\nnivel_escolar\n#&gt; # A tibble: 3 × 3\n#&gt;   escolaridade quantidade porcentagem\n#&gt;   &lt;chr&gt;             &lt;dbl&gt;       &lt;dbl&gt;\n#&gt; 1 Fundamental         150        36.6\n#&gt; 2 Médio               200        48.8\n#&gt; 3 Superior             60        14.6\n\nAssim, demonstraremos o passo-a-passo para construir o gráfico de setores.\n1. Construir o gráfico de barras: devemos deixar vazio o eixo x (x = \"\"), definir os valores percentuais no eixo y (y = porcentagem) e preencher a barra com a variável categórica (fill = escolaridade). Feito isso, atribuímos a geometria de barras (geom_col()), colorindo suas bordas com a cor preta (color = \"black\"), a fim de delimitar os segmentos do gráfico.\n\nggplot(nivel_escolar, aes(x = \"\", y = porcentagem, fill = escolaridade)) +\n  geom_col(color = \"black\")\n\n\n\n\n\n\n\n2. Legendas: utilizamos a geom_text() para definir a legenda das porcentagens dentro de cada setor da barra. Definimos como rótulo (label =) a variável porcentagem, sendo que a função paste(porcentagem, \"%\") insere o símbolo de % logo após os valores percentuais. Por último, o argumento vjust = 0.5 ajusta a posição das legendas.\n\nggplot(nivel_escolar, aes(x = \"\", y = porcentagem, fill = escolaridade)) +\n  geom_col(color = \"black\") +\n  geom_text(\n    aes(label = porcentagem |&gt; paste(\"%\")),\n    position = position_stack(vjust = 0.5)\n  )\n\n\n\n\n\n\n\n3. Coordenadas: nesse ponto, utilizamos a função coord_polar() para tornar nosso gráfico redondo. O argumento theta = \"y\" indica que o eixo y deve ser adotado como referência para a alteração da coordenada e o start = indica por qual valor o gráfico deve começar (teste outro valores para ver a diferença).\n\nggplot(nivel_escolar, aes(x = \"\", y = porcentagem, fill = escolaridade)) +\n  geom_col(color = \"black\") +\n  geom_text(\n    aes(label = porcentagem |&gt; paste(\"%\")),\n    position = position_stack(vjust = 0.5)\n  ) +\n  coord_polar(theta = \"y\", start = 0)\n\n\n\n\n\n\n\n4. Retirar elementos: neste ponto, já temos um gráfico de setores, porém poluído devido a presença das escalas, nome dos eixos e cor de fundo inadequada. Para alterar o fundo cinza para um branco, escolhemos o tema theme_minimal(). Em seguida, na função theme(), atribuímos a alguns argumentos o element_blank(), ou seja, função que retira os elementos de cena. Assim, com o axis.title = retiramos os nomes dos eixos, com o axis.text =, excluímos o restante de texto presente no gráfico e com o panel.grid, omitimos o restante das linhas gráficas.\n\nggplot(nivel_escolar, aes(x = \"\", y = porcentagem, fill = escolaridade)) +\n  geom_col(color = \"black\") +\n  geom_text(\n    aes(label = porcentagem |&gt; paste(\"%\")),\n    position = position_stack(vjust = 0.5)\n  ) +\n  coord_polar(theta = \"y\", start = 0) +\n  theme_minimal() +\n  theme(\n    axis.title = element_blank(),\n    axis.text = element_blank(),\n    panel.grid = element_blank()\n  )\n\n\n\n\n\n\n\nDessa forma, obtemos o gráfico de pizza mais simple possível a partir do ggplot2.",
    "crumbs": [
      "Visualização",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Gráficos</span>"
    ]
  },
  {
    "objectID": "visualizar.html#sec-gline",
    "href": "visualizar.html#sec-gline",
    "title": "9  Gráficos",
    "section": "\n9.5 Gráfico de Linhas",
    "text": "9.5 Gráfico de Linhas\nOs gráficos de linhas são, comumente, utilizados para representar séries temporais, ou seja, a progressão de valores ao longo do tempo.\nPara exemplificações, utilizaremos os dados do arquivo produtividade_milho.csv. Nele estão presentes valores de produtividade da cultura do milho (em toneladas por hectare) no Brasil, China, Índia e Estado Unidos entre os anos de 1961 e 2019.\n\nprod_milho &lt;- readr::read_csv(\"dados/produtividade_milho.csv\")\n\nprod_milho\n#&gt; # A tibble: 236 × 3\n#&gt;    pais     ano produtiv\n#&gt;    &lt;chr&gt;  &lt;dbl&gt;    &lt;dbl&gt;\n#&gt;  1 Brasil  1961     1.31\n#&gt;  2 Brasil  1962     1.30\n#&gt;  3 Brasil  1963     1.31\n#&gt;  4 Brasil  1964     1.16\n#&gt;  5 Brasil  1965     1.38\n#&gt;  6 Brasil  1966     1.31\n#&gt;  7 Brasil  1967     1.38\n#&gt;  8 Brasil  1968     1.34\n#&gt;  9 Brasil  1969     1.31\n#&gt; 10 Brasil  1970     1.44\n#&gt; # ℹ 226 more rows\n\nPara construir o gráfico de linhas, utilizamos a função geom_line(). Como primeiro exemplo, usaremos somente os dados de produtividade de milho no Brasil. Para isso, utilizaremos a função dplyr::filter() (vide Seção 7.4.1).\n\nprod_milho |&gt; \n  dplyr::filter(pais == \"Brasil\") |&gt; \n  ggplot(aes(x = ano, y = produtiv)) +\n  geom_line(linewidth = 2)\n\n\n\n\n\n\n\nNote que para alterar a espessura das linhas, usamos o argumento linewidth =.\nPara adicionar variáveis categóricas ao gráfico de linhas, podemos prosseguir de diversas maneiras. A seguir, traremos algumas opções.\n\n9.5.1 Cores\nDa mesma forma como foi realizado para os demais tipos de geometria, utilizamos o argumento color = para diferenciar variáveis categóricas por cor.\n\nggplot(prod_milho, aes(x = ano, y = produtiv, color = pais)) +\n  geom_line(size = 1.3)\n\n\n\n\n\n\n\nTemos a opção de alterar os tipos e escalas de cores utilizando as funções de sintaxe scale_color_(). O mesmo é válido quando utilizamos o argumento fill =, porém com a sintaxe scale_fill_().\nPara alterá-las manualmente, utilizamos a função scale_color_manual(), tendo como argumento o values =, que recebe um vetor com o nome das cores.\n\nggplot(prod_milho, aes(x = ano, y = produtiv, color = pais)) +\n  geom_line(size = 1.3) +\n  scale_color_manual(values = c(\"chocolate\", \"cyan3\", \"bisque4\", \"chartreuse4\"))\n\n\n\n\n\n\n\nTambém temos a opção de utilizar códigos hexadecimais para atribuir cores.\n\nggplot(prod_milho, aes(x = ano, y = produtiv, color = pais)) +\n  geom_line(size = 1.3) +\n  scale_color_manual(values = c(\"#E81B23\", \"#00AEF3\", \"#A9B508\", \"#0A863B\"))\n\n\n\n\n\n\n\nO código hexadecimal é composto por seis letras maiúsculas ou números precedidos de um #. Cada par numérico sequencial representa a intensidade da cor vermelha, verde e azul, respectivamente. A combinação dessas três cores em diferentes intensidades resulta na cor desejada.\nConfira o site RGB Color Codes Chart para construir um código hexadecimal, além de consultar a tabela com os nomes de cores.\nPor fim, outra forma de alterar a coloração é partir de paletas de cores pré-definidas. Para isso, utilizamos a função scale_color_brewer(), tendo como argumento a palette =.\n\nggplot(prod_milho, aes(x = ano, y = produtiv, color = pais)) +\n  geom_line(size = 1.3) +\n  scale_color_brewer(palette = \"Set1\")\n\n\n\n\n\n\n\nA Figura 9.4 mostra a lista com as possíveis paletas de cores do pacote RColorBrewer, documentadas em https://colorbrewer2.org/#type=sequential&scheme=BuGn&n=3.\n\n\n\n\n\n\n\nFigura 9.4: Lista com as paletas de cores disponíveis para aplicarmos em nossos gráficos.\n\n\n\n\nVocê pode encontrar mais tipos de paletas de cores no pacote ggthemes.\nCaso queira saber mais sobre as escalas de cores existentes no R, confira o post do site The R Graph Gallery: Dealing with colors in ggplot2.\n\n9.5.2 Formatos\nTambém podemos diferenciar variáveis categóricas pelo formato das linhas. Para isso, utilizamos o argumento linetype =.\n\nggplot(prod_milho, aes(x = ano, y = produtiv, linetype = pais)) +\n  geom_line()\n\n\n\n\n\n\n\nCada tipo de linha é representado por um número, cuja legenda pode ser conferida na Figura 9.5.\n\n\n\n\n\n\n\nFigura 9.5: Possíveis tipos de linhas a partir do argumento linetype =.\n\n\n\n\nPara alterar o tipo de linha a ser adotado para cada variável, utilizamos a função scale_linetype_manual() junto ao argumento values =, no qual passamos um vetor com o número das legendas ou o nome dos tipos de pontos.\n\nggplot(prod_milho, aes(x = ano, y = produtiv, linetype = pais)) +\n  geom_line() +\n  scale_linetype_manual(values = c(2, 5, 1, 6))\n\n\n\n\n\n\n\n\n9.5.3 Escalas\nA família de funções scale_() também apresenta opções para mudar as escalas dos eixos dos gráficos.\nPara quebrarmos (breaks =) as escalas dos eixos x e y e redefinirmos outra sequência (seq()), utilizamos as funções scale_x_continuous() e scale_y_continuous(), respectivamente. Como fatores do argumento seq(), definimos o limite inferior (from =), o limite superior (to =) e de quanto em quanto (by =).\n\nggplot(prod_milho, aes(x = ano, y = produtiv, color = pais)) +\n  geom_line() +\n  scale_x_continuous(breaks = seq(from = 1961, to = 2019, by = 2)) +\n  scale_y_continuous(breaks = seq(from = 0, to = 12, by = 1))\n\n\n\n\n\n\n\nPerceba que, no eixo x, os anos ficaram apertados e mal apresentados. Para melhorar sua aparência, podemos alterar a angulação do texto (angle =) com o argumento axis.text.x = element_text() dentro da função theme().\n\nggplot(prod_milho, aes(x = ano, y = produtiv, color = pais)) +\n  geom_line() +\n  scale_x_continuous(breaks = seq(from = 1961, to = 2019, by = 2)) +\n  scale_y_continuous(breaks = seq(from = 0, to = 12, by = 1)) +\n  theme(axis.text.x = element_text(angle = 90))\n\n\n\n\n\n\n\n\n9.5.4 Rótulos\nPara trocar o nome das categorias na legenda, usamos as funções do tipo scale_*_discrete() junto ao argumento labels =. A seguir, listamos algumas das possibilidades:\n\nscale_color_discrete(): altera o nome das variáveis contidas no argumento color =;\nscale_fill_discrete(): altera o nome das variáveis contidas no argumento fill =;\nscale_alpha_discrete(): altera o nome das variáveis contidas no argumento alpha =;\nscale_size_discrete(): altera o nome das variáveis contidas no argumento size =.\n\n\nggplot(prod_milho, aes(x = ano, y = produtiv, color = pais)) +\n  geom_line(size = 1.2) +\n  scale_color_discrete(labels = c(\"BR\", \"CHI\", \"IND\", \"EUA\"))",
    "crumbs": [
      "Visualização",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Gráficos</span>"
    ]
  },
  {
    "objectID": "visualizar.html#juntar-gráficos",
    "href": "visualizar.html#juntar-gráficos",
    "title": "9  Gráficos",
    "section": "\n9.6 Juntar gráficos",
    "text": "9.6 Juntar gráficos\nTemos a possibilidade de juntar diferentes gráficos em uma mesma apresentação. Para isso, utilizamos os recursos do pacote patchwork.\n\ninstall.packages(\"patchwork\")\n\n\nlibrary(patchwork)\n\nO pacote funciona de maneira bem simples. Para juntarmos gráficos, devemos salvá-los em um objeto e, posteriomente, uni-los com um sinal de +. Veja o exemplo a seguir.\n\ng1 &lt;- ggplot(dados_alunos, aes(x = sexo, fill = futuro)) +\n  geom_bar(position = \"dodge\")\n\ng2 &lt;- ggplot(dados_alunos, aes(x = altura, y = peso, color = sexo)) +\n  geom_point()\n\n\ng1 + g2\n\n\n\n\n\n\n\nPodemos dispô-los um embaixo do outro com o operador /.\n\ng1 / g2\n\n\n\n\n\n\n\nAlém disso, podemos inserir mais gráficos ao conjunto.\n\ng3 &lt;- ggplot(dados_alunos, aes(x = horas_estudo, y = media_ponderada, fill = sexo)) +\n  geom_col()\n\n\ng2 / (g1 + g3)\n\n\n\n\n\n\n\n\ng2 + (g1 / g3)\n\n\n\n\n\n\n\nAssim, dependendo da combinação de operações entre objetos, é possível dispor os gráficos de diferentes formas. Conheça mais sobre o pacote patchwork em https://patchwork.data-imaginist.com/.",
    "crumbs": [
      "Visualização",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Gráficos</span>"
    ]
  },
  {
    "objectID": "visualizar.html#resumo",
    "href": "visualizar.html#resumo",
    "title": "9  Gráficos",
    "section": "\n9.7 Resumo",
    "text": "9.7 Resumo\nAo longo deste capítulo, vimos que o pacote ggplot2 possui ferramentas robustas e versáteis para criar gráficos. O pacote oferece uma variedade de funcionalidades, incluindo outros pacotes que funcionam como extensão ao ggplot e que merecem ser exploradas com mais detalhes. Neste primeiro momento, as informações apresentadas servem como base ao leitor, capacitando-o a criar os primeiros gráficos em R. Além disso, visa proporcionar uma introdução que o habilite a aprofundar e aprimorar seus gráficos de forma mais independente.\nPara os leitores que desejam aprofundar o conhecimento no pacote ggplot2 e suas extensões, deixo como recomendação alguns materiais, todos disponíveis gratuitamente online.\n\n\nLivros:\n\nR Graphics Cookbook;\nggplot2: Elegant Graphics for Data Analysis;\nFundamentals of Data Visualization;\nMapas do Brasil em R.\n\n\n\nSites com exemplos de gráficos:\n\nThe R Graph Gallery;\nR Gallery Book;\nggplot2 extensions.\n\n\n\nNo capítulo a seguir, trataremos de uma extensão do ggplot2 que constrói gráficos de modo interativo. Trata-se do pacote esquisse.",
    "crumbs": [
      "Visualização",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Gráficos</span>"
    ]
  },
  {
    "objectID": "esquisse.html",
    "href": "esquisse.html",
    "title": "10  Gráficos Interativos",
    "section": "",
    "text": "Uma maneira muito simples e intuitiva de elaborar gráficos com o ggplot2 é com o pacote esquisse. Este pacote apresenta uma ferramenta interativa que permite criar gráficos baseado na sintaxe do ggplot2.\n\ninstall.packages(\"esquisse\")\n\n\nlibrary(esquisse)\n\nPara abrir a ferramenta, utilizamos a função esquisser().\n\nesquisser()\n\nAo executar a função, será aberta a seguinte janela no RStudio.\n\n\n\n\n\n\n\n\nO primeiro passo é importar o conjunto de dados para o esquisse. Podemos utilizar objetos do tipo data frame salvos no Environment ou presentes em outros pacotes. Também é possível importar outros dados que não estejam presentes no RStudio, semelhante ao realizado no Capítulo 4.\nCaso você tenha um objeto contendo um data frame, é possível indicá-lo diretamente na função esquisser(), antes de abrir a ferramenta. Para isso, colocamos no argumento data = o nome do objeto. Faremos isso com os dados do arquivo alunos.csv, o mesmo utilizado no Capítulo 9.\n\ndados_alunos &lt;- readr::read_csv(\"dados/alunos.csv\")\n\nesquisser(data = dados_alunos)\n\nAo selecionar um conjunto de dados, podemos visualizá-lo clicando na aba View. Na aba Update, podemos selecionar, renomear e alterar a classe de variáveis antes de importar os dados à ferramenta. Selecionado e ajustado o conjunto de dados, clicamos em Import data para importá-los.\nA tela de entrada do esquisse tem a seguinte aparência.\n\n\n\n\n\n\n\n\nComo componentes, temos diversos parâmetros. Logo acima, temos uma caixa com as variáveis do conjunto de dados. Perceba que as cores das variáveis são diferenciadas conforme o seu tipo (quantitativa ou qualitativa).\nEm seguida, temos os parâmetros estéticos do ggplot2. Para definir uma variável a um dos parâmetros, arrastamo-as para o respectivo bloco.\nAo arrastar as variáveis para os parâmetros, a ferramenta atribui, automaticamente, uma geometria condizente com os tipo de dados. Para alterar a geometria, clicamos na caixa logo ao lado das já citadas.\nO espaço em branco é o local onde o gráfico será construído. Além disso, apresenta um botão que permite exportar o gráfico gerado.\nNo menu inferior, temos diversas opções de alteração do gráfico:\n\nLabels & Title: adicionamos legendas e rótulos ao gráfico e aos eixos;\nPlot options: altera parâmetros do gráfico, variando com o tipo de geometria;\nAppearance: permite modificar as cores, o tema e a posição das legendas;\nData: apresenta ferramentas que transformam os dados, utilizando a lógica dos pacotes de transformação, principalmente o dplyr (Capítulo 7);\nCode: mostra a prévia do código conforme as alterações realizadas.\n\nPor fim, no menu superior, podemos alterar o conjunto de dados a ser utilizado, visualizar os dados e adicionar outros parâmetros.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTambém temos a opção de abrir a ferramenta em outros locais. Utilizando o argumento viewer =, podemos abri-la na aba Viewer do RStudio (\"viewer = pane\") ou no navegador de internet (\"viewer = browser\").\n\nesquisser(viewer = \"pane\")\nesquisser(viewer = \"browser\")\n\nDessa forma, o esquisse se apresenta como uma excelente ferramenta para aprendermos a lógica do ggplot2 de maneira simples e intuitiva.\nPara mais informações sobre o pacote esquisse, confira o seguinte link: https://cran.r-project.org/web/packages/esquisse/vignettes/get-started.html.",
    "crumbs": [
      "Visualização",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Gráficos Interativos</span>"
    ]
  },
  {
    "objectID": "graficos-estatisticos.html",
    "href": "graficos-estatisticos.html",
    "title": "11  Estatíticas",
    "section": "",
    "text": "11.1 Introdução\nNeste capítulo, trataremos sobre alguns gráficos comuns na área da estatística, utilizando o pacote ggplot2.\nlibrary(ggplot2)\nPara os exemplos, utilizaremos o mesmo conjunto de dados utilizados no Capítulo 9, presente no arquivo alunos.csv.\ndados_alunos &lt;- readr::read_csv(\"dados/alunos.csv\")\n\ndados_alunos\n#&gt; # A tibble: 64 × 7\n#&gt;    sexo  idade altura  peso horas_estudo media_ponderada futuro   \n#&gt;    &lt;chr&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;        &lt;dbl&gt;           &lt;dbl&gt; &lt;chr&gt;    \n#&gt;  1 M        23   1.75    80            2             7.5 academico\n#&gt;  2 F        19   1.67    65            2             8.3 mercado  \n#&gt;  3 M        19   1.7     90            3             6.9 mercado  \n#&gt;  4 M        22   1.73    87            3             7.1 academico\n#&gt;  5 M        19   1.83    71            2             6.5 mercado  \n#&gt;  6 M        19   1.8     80            3             8.6 mercado  \n#&gt;  7 M        20   1.9     90            2             7.8 academico\n#&gt;  8 F        20   1.6     55            1             8   mercado  \n#&gt;  9 F        24   1.62    55            2             8.2 academico\n#&gt; 10 F        18   1.64    60            2             7.3 mercado  \n#&gt; # ℹ 54 more rows",
    "crumbs": [
      "Visualização",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Estatíticas</span>"
    ]
  },
  {
    "objectID": "graficos-estatisticos.html#histogramas",
    "href": "graficos-estatisticos.html#histogramas",
    "title": "11  Estatíticas",
    "section": "\n11.2 Histogramas",
    "text": "11.2 Histogramas\nNeste primeiro caso, faremos um histograma referente à média ponderada dos alunos.\nEsse tipo de gráfico é útil para verificar a frequência e a distribuição de uma variável numérica que assume uma ampla gama de valores (variável quantitativa contínua). Sua construção é dada pela divisão do eixo x em barras igualmente espaçadas e, no eixo y, apresenta o número de observações dos respectivos intervalos.\nPara isso, utilizamos a função geom_histogram(), sendo necessário indicar somente o argumento x =, pois o eixo y será construído, automaticamente, pela contagem dos valores.\n\nggplot(dados_alunos, aes(x = media_ponderada)) +\n  geom_histogram()\n#&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\nPodemos definir a largura dos intervalos ou a quantidade de barras de um histograma utilizando os argumentos binwidth = e bins =, respectivamente. Em relação à largura dos intervalos, o argumento recebe uma medida nas unidades da variável x. Já a quantidade de barras, por padrão, é atribuído 30 intervalos.\n# Gráfico à esquerda\nggplot(dados_alunos, aes(x = media_ponderada)) +\n  geom_histogram(binwidth = 0.5)\n\n# Gráfico à direita\nggplot(dados_alunos, aes(x = media_ponderada)) +\n  geom_histogram(bins = 8)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo gráfico à esquerda, definimos uma largura de intervalos em 0.5, ou seja, as notas vão de 0.5 em 0.5. Enquanto isso, no gráfico à direita, definimos 8 barras para a apresentação do histograma.\nDe acordo com o valor atribuído a quaisquer dos argumentos, podemos observar diferentes padrões. Dessa forma, é importante explorar uma variedade de valores até que os dados estejam bem ajustados ao histograma.\nPara melhorar a aparência do histograma, utilizamos o argumento color = para colorir as bordas das barras e o fill = para preencher o seu interior com cor.\n# Gráfico à esquerda\nggplot(dados_alunos, aes(x = media_ponderada)) +\n  geom_histogram(binwidth = 0.5, color = \"black\", fill = \"#00AEF3\")\n\n# Gráfico à direita\nggplot(dados_alunos, aes(x = media_ponderada)) +\n  geom_histogram(bins = 8, color = \"black\", fill = \"#1FC361\")",
    "crumbs": [
      "Visualização",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Estatíticas</span>"
    ]
  },
  {
    "objectID": "graficos-estatisticos.html#gráfico-de-densidade",
    "href": "graficos-estatisticos.html#gráfico-de-densidade",
    "title": "11  Estatíticas",
    "section": "\n11.3 Gráfico de densidade",
    "text": "11.3 Gráfico de densidade\nUma outra alternativa para representar variáveis numéricas contínuas é o gráfico de densidade. Para isso, utilizamos a função geom_density(). Este gráfico é uma versão suavizada do histograma que nos fornece uma noção sobre a simetria dos dados.\n\nggplot(dados_alunos, aes(x = media_ponderada)) +\n  geom_density()\n\n\n\n\n\n\n\nPodemos preencher seu interior com o argumento fill = e alterar a transparência da cor com o alpha =.\n\nggplot(dados_alunos, aes(x = media_ponderada)) +\n  geom_density(fill = \"#AEC70D\", alpha = 0.3)\n\n\n\n\n\n\n\nTambém podemos representar mais de uma densidade em um mesmo gráfico. Basta atribuir uma variável categórica ao argumento fill = e/ou color = para diferenciar as densidades.\n\nggplot(dados_alunos, aes(x = media_ponderada, color = sexo, fill = sexo)) +\n  geom_density(alpha = 0.3)",
    "crumbs": [
      "Visualização",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Estatíticas</span>"
    ]
  },
  {
    "objectID": "graficos-estatisticos.html#boxplot",
    "href": "graficos-estatisticos.html#boxplot",
    "title": "11  Estatíticas",
    "section": "\n11.4 Boxplot",
    "text": "11.4 Boxplot\nO boxplot ou gráfico de caixas é muito útil para observarmos a posição e a distribuição de valores. Além disso, permite identificar possíveis observações atípicas do conjunto de dados. Para fazermos os boxplots, utilizamos a função geom_boxplot().\n\nggplot(dados_alunos, aes(y = media_ponderada)) +\n  geom_boxplot()\n\n\n\n\n\n\n\nNesse primeiro caso, fizemos um boxplot da média ponderada de todos os alunos. A observação representada por um ponto é um valor atípico aos dados.\nPodemos incluir uma variável categórica ao boxplot. Como por exemplo, distinguir os dados de acordo com a variável futuro.\n\nggplot(dados_alunos, aes(x = futuro, y = media_ponderada)) +\n  geom_boxplot()\n\n\n\n\n\n\n\nNeste caso, podemos ver a distribuição da média ponderada dos estudantes de acordo com as perspectivas futuras de cada um. Para isso, atribuímos a variável categórica futuro ao eixo x.\nAinda, podemos incluir uma segunda variável categórica. Agora, dividiremos os dados de acordo com as perspectivas futuras e o sexo.\n\nggplot(dados_alunos, aes(x = futuro, y = media_ponderada, fill = sexo)) +\n  geom_boxplot()\n\n\n\n\n\n\n\nPara isso, atribuimos a variável sexo ao argumento fill =, distinguindo o sexo dos estudantes por cor. Como resultado, podemos observar a distribuição das médias ponderadas de acordo com o sexo e a perspectiva futura dos alunos.\nPara conferir os valores utilizados para construir o boxplot, podemos utilizar a função summary().\n\n# Todos os valores de `media_ponderada`\nsummary(dados_alunos$media_ponderada)\n#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#&gt;   5.000   7.000   7.400   7.425   8.000   8.700\n\n# Valores agrupados por `futuro`\ndados_alunos |&gt; \n  dplyr::group_by(futuro) |&gt; \n  dplyr::summarise(\n    summary(media_ponderada) |&gt; rbind() |&gt; tibble::as_tibble()\n  )\n#&gt; # A tibble: 2 × 7\n#&gt;   futuro     Min. `1st Qu.` Median  Mean `3rd Qu.`  Max.\n#&gt;   &lt;chr&gt;     &lt;dbl&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 academico   6.6      7.1     7.5  7.58       8.1   8.7\n#&gt; 2 mercado     5        6.95    7.4  7.37       8     8.7\n\n# Valores agrupados por `futuro` e `sexo`\ndados_alunos |&gt; \n  dplyr::group_by(futuro, sexo) |&gt; \n  dplyr::summarise(\n    summary(media_ponderada) |&gt; rbind() |&gt; tibble::as_tibble()\n  )\n#&gt; # A tibble: 4 × 8\n#&gt; # Groups:   futuro [2]\n#&gt;   futuro    sexo   Min. `1st Qu.` Median  Mean `3rd Qu.`  Max.\n#&gt;   &lt;chr&gt;     &lt;chr&gt; &lt;dbl&gt;     &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 academico F       6.6      6.85   8.2   7.74      8.5    8.7\n#&gt; 2 academico M       6.9      7.2    7.4   7.46      7.75   8.1\n#&gt; 3 mercado   F       6.7      7.2    7.5   7.61      8      8.4\n#&gt; 4 mercado   M       5        6.72   7.15  7.21      7.93   8.7\n\nPor fim, para calcular a amplitude interquartil (cujo cálculo se dá pela subtração do valor do 3º quartil com o do 1º quartil) utilizamos a função IQR().\n\n# Todos os valores de `media_ponderada`\nIQR(dados_alunos$media_ponderada)\n#&gt; [1] 1\n\n# Valores agrupados por `futuro`\ndados_alunos |&gt; \n  dplyr::group_by(futuro) |&gt; \n  dplyr::summarise(iqr = IQR(media_ponderada))\n#&gt; # A tibble: 2 × 2\n#&gt;   futuro      iqr\n#&gt;   &lt;chr&gt;     &lt;dbl&gt;\n#&gt; 1 academico  1   \n#&gt; 2 mercado    1.05\n\n# Valores agrupados por `futuro` e `sexo`\ndados_alunos |&gt; \n  dplyr::group_by(futuro, sexo) |&gt; \n  dplyr::summarise(iqr = IQR(media_ponderada))\n#&gt; # A tibble: 4 × 3\n#&gt; # Groups:   futuro [2]\n#&gt;   futuro    sexo    iqr\n#&gt;   &lt;chr&gt;     &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1 academico F      1.65\n#&gt; 2 academico M      0.55\n#&gt; 3 mercado   F      0.8 \n#&gt; 4 mercado   M      1.20",
    "crumbs": [
      "Visualização",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Estatíticas</span>"
    ]
  },
  {
    "objectID": "graficos-estatisticos.html#gráfico-de-barras-com-desvios-padrão",
    "href": "graficos-estatisticos.html#gráfico-de-barras-com-desvios-padrão",
    "title": "11  Estatíticas",
    "section": "\n11.5 Gráfico de barras com desvios padrão",
    "text": "11.5 Gráfico de barras com desvios padrão\nPara adicionar desvios padrão ao gráfico de barras no ggplot2, usamos a função geom_errorbar(), que adiciona barras de erro representando a variação dos dados.\nPara isso, utilizaremos os dados do data frame diamonds, conjunto de dados do próprio pacote ggplot2.\n\ndiamonds\n#&gt; # A tibble: 53,940 × 10\n#&gt;    carat cut       color clarity depth table price     x     y     z\n#&gt;    &lt;dbl&gt; &lt;ord&gt;     &lt;ord&gt; &lt;ord&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt;  1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n#&gt;  2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n#&gt;  3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n#&gt;  4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n#&gt;  5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n#&gt;  6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n#&gt;  7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n#&gt;  8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n#&gt;  9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n#&gt; 10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n#&gt; # ℹ 53,930 more rows\n\nPrimeiramente, criaremos um resumo dos dados com média e desvio padrão a partir das funções group_by() e summarise() (vide Seção 7.5).\n\ndiamonds_resumo &lt;- diamonds |&gt; \n  dplyr::group_by(cut) |&gt; \n  dplyr::summarise(\n    media_preco = mean(price),\n    desvio_padrao = sd(price)\n  )\ndiamonds_resumo\n#&gt; # A tibble: 5 × 3\n#&gt;   cut       media_preco desvio_padrao\n#&gt;   &lt;ord&gt;           &lt;dbl&gt;         &lt;dbl&gt;\n#&gt; 1 Fair            4359.         3560.\n#&gt; 2 Good            3929.         3682.\n#&gt; 3 Very Good       3982.         3936.\n#&gt; 4 Premium         4584.         4349.\n#&gt; 5 Ideal           3458.         3808.\n\nCom as medidas calculadas, construiremos o gráfico de barras com a função geom_bar() e colocar os desvios padrão com a função geom_errorbar().\n\nggplot(diamonds_resumo, aes(x = cut, y = media_preco)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  geom_errorbar(\n    aes(\n      ymin = media_preco - desvio_padrao,\n      ymax = media_preco + desvio_padrao\n    ), \n    width = 0.2\n  )\n\n\n\n\n\n\n\nNote que os limites inferior e superior da barra de erro foram construídos a partir da subtração e da soma pela média dos preços de diamantes, respectivamente. Com o argumento width = definimos a largura da barra de erro.",
    "crumbs": [
      "Visualização",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Estatíticas</span>"
    ]
  },
  {
    "objectID": "graficos-estatisticos.html#resumo",
    "href": "graficos-estatisticos.html#resumo",
    "title": "11  Estatíticas",
    "section": "\n11.6 Resumo",
    "text": "11.6 Resumo\nPara saber mais sobre os gráficos estatísticos, confira o seguinte material R Gallery Book.",
    "crumbs": [
      "Visualização",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Estatíticas</span>"
    ]
  },
  {
    "objectID": "referencias.html",
    "href": "referencias.html",
    "title": "Referências",
    "section": "",
    "text": "Além dos materiais complementares listados ao longo dos capítulos, a seguir, estão listadas outras referências recomendadas e utilizadas para a construção deste material. A ordem das obras estão categorizadas de acordo com sua complexidade (iniciando pelas literaturas básicas).\n\nHands-On Programming with R - Grolemund (2014).\nCiência de Dados em R - Curso R (2022).\n[R for Data Science](https://r4ds.hadley.nz/.) - Wickham, Çetinkaya-Rundel e Grolemund (2023).\nR Graphics Cookbook - Chang (2021).\nAdvanced R - Wickham (2023).",
    "crumbs": [
      "Referências"
    ]
  }
]